/*$file${.::ihm.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: fmw-torrador-v3.qm
* File:  ${.::ihm.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::ihm.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "common.h"
#include "esp_log.h"
#include <string.h>
#include <time.h>
#include "esp_unicviewad.h"

Q_DEFINE_THIS_FILE

#define MAIN_MENU_PICID 0
#define MANUAL_MODE_PICID 1
#define CONFIG_PICID 2
#define CONTROLS_PICID 3
#define SUMMARY_PICID 4
#define ROASTS_PICID 5
#define ROAST_PICID 6
#define WARN_NEW_ROAST_PICID 7
#define WARN_REPEAT_RECIPE_PICID 8
#define WARN_REPLAY_RECIPE_PICID 9
#define WARN_SAVE_RECIPE_PICID 10
#define WARN_TEMP_PRE_PICID 11
#define WARN_TEMP_COOL_PICID 12

#define STAGE_STATUS_ICON_VP 38
#define STAGE_BTN_ICON_VP 48
#define SUBSTAGE_BTN_ICON_VP 436
#define NAVBAR_ICON_HOME_VP 36
#define NAVBAR_ICON_GEAR_VP 37
#define NEXT_COMMAND_ICON_VP 85
#define CONTROL_POTENCIA_ICON_VP 79
#define CONTROL_CILINDRO_ICON_VP 81
#define CONTROL_RESFRIADOR_ICON_VP 83
#define CONTROL_TURBINA_ICON_VP 84

#define SENSOR_GAS_TEXT_VP 0
#define SENSOR_AR_TEXT_VP 49
#define DELTA_AR_TEXT_VP 55
#define SENSOR_GRAO_TEXT_VP 61
#define DELTA_GRAO_TEXT_VP 67
#define NAVBAR_TEXT_VP 1
#define STAGE_TIMER_TEXT_VP 39
#define NEXT_COMMAND_TEXT_VP 95
#define NEXT_COMMAND_TIMER_TEXT_VP 86
#define CONTROL_POTENCIA_TEXT_VP 426
#define CONTROL_CILINDRO_TEXT_VP 431

#define SENSOR_GAS_TEXT_LEN 4
#define SENSOR_AR_TEXT_LEN 6
#define DELTA_AR_TEXT_LEN 6
#define SENSOR_GRAO_TEXT_LEN 6
#define DELTA_GRAO_TEXT_LEN 6
#define NAVBAR_TEXT_LEN 35
#define STAGE_TIMER_TEXT_LEN 9
#define NEXT_COMMAND_TEXT_LEN 15
#define NEXT_COMMAND_TIMER_TEXT_LEN 9
#define CONTROL_POTENCIA_TEXT_LEN 4
#define CONTROL_CILINDRO_TEXT_LEN 4

static const char * TAG = "IHM";

/*$declare${Components::IhmStage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmStage} ..................................................*/
typedef struct {
/* protected: */
    QHsm super;

/* public: */
    time_t timer_start;
} IhmStage;

/* public: */
static void IhmStage_setTimer(IhmStage * const me,
    bool reset,
    bool visible);

/* protected: */
static QState IhmStage_initial(IhmStage * const me, void const * const par);
static QState IhmStage_idle(IhmStage * const me, QEvt const * const e);
static QState IhmStage_pre_heating(IhmStage * const me, QEvt const * const e);
static QState IhmStage_timing(IhmStage * const me, QEvt const * const e);
static QState IhmStage_roasting(IhmStage * const me, QEvt const * const e);
static QState IhmStage_cooling(IhmStage * const me, QEvt const * const e);
static QState IhmStage_summary(IhmStage * const me, QEvt const * const e);
/*$enddecl${Components::IhmStage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$declare${Components::IhmSubstage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmSubstage} ...............................................*/
typedef struct {
/* protected: */
    QHsm super;
} IhmSubstage;

/* protected: */
static QState IhmSubstage_initial(IhmSubstage * const me, void const * const par);
static QState IhmSubstage_idle(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_q1(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_f(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_q2(IhmSubstage * const me, QEvt const * const e);
/*$enddecl${Components::IhmSubstage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$declare${AOs::Ihm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm} ..............................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */
    IhmState state;
    QTimeEvt stageTimerEvt;

/* private: */
    IhmStage stage;
    IhmSubstage substage;

/* private state histories */
    QStateHandler hist_manual_page;
} Ihm;

/* private: */
static void Ihm_setupPageManualMode(void);
static void Ihm_setupPageMainMenu(void);
static void Ihm_setupPageManualControls(void);
static void Ihm_setupPageSummary(void);
static void Ihm_setupPageConfig(void);
static void Ihm_resetState(Ihm * const me);

/* protected: */
static QState Ihm_initial(Ihm * const me, void const * const par);
static QState Ihm_main_menu(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_mode(Ihm * const me, QEvt const * const e);
static QState Ihm_warn_new(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_page(Ihm * const me, QEvt const * const e);
static QState Ihm_idle(Ihm * const me, QEvt const * const e);
static QState Ihm_active(Ihm * const me, QEvt const * const e);
static QState Ihm_pre_heating(Ihm * const me, QEvt const * const e);
static QState Ihm_chart(Ihm * const me, QEvt const * const e);
static QState Ihm_roasting(Ihm * const me, QEvt const * const e);
static QState Ihm_cooling(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_controls(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_config(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_mode(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_controls(Ihm * const me, QEvt const * const e);
static QState Ihm_recipes(Ihm * const me, QEvt const * const e);
static QState Ihm_roasts(Ihm * const me, QEvt const * const e);
static QState Ihm_summary(Ihm * const me, QEvt const * const e);
static QState Ihm_config(Ihm * const me, QEvt const * const e);
/*$enddecl${AOs::Ihm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


static Ihm l_ihm; /* a única instância do AO IHM */
static IhmStage l_ihmStage; /* a única instância do AO IHM */
static IhmSubstage l_ihmSubstage; /* a única instância do AO IHM */

#define STAGE_TIMER_INTERVAL  \
    (QTimeEvtCtr)((1 * CONFIG_FREERTOS_HZ))

QActive * const AO_Ihm = &l_ihm.super;

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${Components::IhmStage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmStage} ..................................................*/

/*${Components::IhmStage::setTimer} ........................................*/
static void IhmStage_setTimer(IhmStage * const me,
    bool reset,
    bool visible)
{
    time_t rawtime;
    struct tm *info;
    char buffer[8];

    time( &rawtime );

    if(reset) {
        me->timer_start = rawtime;
    }

    if(visible) {
        time_t elapsed = rawtime-me->timer_start;

        info = localtime( &elapsed );
        strftime(buffer,80,"%H:%M:%S", info);

        postUart_setString(STAGE_TIMER_TEXT_VP, buffer, false, STAGE_TIMER_TEXT_LEN);
    } else {
        postUart_setString(STAGE_TIMER_TEXT_VP, "\0", true, STAGE_TIMER_TEXT_LEN);
    }


}

/*${Components::IhmStage::SM} ..............................................*/
static QState IhmStage_initial(IhmStage * const me, void const * const par) {
    /*${Components::IhmStage::SM::initial} */
    return Q_TRAN(&IhmStage_idle);
}

/*${Components::IhmStage::SM::idle} ........................................*/
static QState IhmStage_idle(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[STAGE][IDLE][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 0);
            postUart_setIcon(STAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[STAGE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::idle::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_pre_heating);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::pre_heating} .................................*/
static QState IhmStage_pre_heating(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[STAGE][PRE_HEATING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 1);
            postUart_setIcon(STAGE_BTN_ICON_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[STAGE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::pre_heating::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_roasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::timing} ......................................*/
static QState IhmStage_timing(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::timing} */
        case Q_EXIT_SIG: {
            IhmStage_setTimer(me, true, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::IHM_STAGE_TIMER_TIMEOUT} */
        case IHM_STAGE_TIMER_TIMEOUT_SIG: {
            IhmStage_setTimer(me, false, true);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::timing::roasting} ............................*/
static QState IhmStage_roasting(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::timing::roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[STAGE][ROASTING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 2);
            postUart_setIcon(STAGE_BTN_ICON_VP, 2);

            IhmStage_setTimer(me, true, true);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[STAGE][ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::roasting::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_cooling);
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_timing);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::timing::cooling} .............................*/
static QState IhmStage_cooling(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::timing::cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[STAGE][COOLING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 3);
            postUart_setIcon(STAGE_BTN_ICON_VP, 3);

            IhmStage_setTimer(me, true, true);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[STAGE][COOLING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::cooling::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_summary);
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_timing);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::summary} .....................................*/
static QState IhmStage_summary(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::summary::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${Components::IhmStage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${Components::IhmSubstage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmSubstage} ...............................................*/

/*${Components::IhmSubstage::SM} ...........................................*/
static QState IhmSubstage_initial(IhmSubstage * const me, void const * const par) {
    /*${Components::IhmSubstage::SM::initial} */
    return Q_TRAN(&IhmSubstage_idle);
}

/*${Components::IhmSubstage::SM::idle} .....................................*/
static QState IhmSubstage_idle(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][IDLE][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::idle::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_f);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::q1} .......................................*/
static QState IhmSubstage_q1(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::q1} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][Q1][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 2);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::q1} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::q1::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_q2);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::f} ........................................*/
static QState IhmSubstage_f(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::f} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][F][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::f} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::f::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_q1);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::q2} .......................................*/
static QState IhmSubstage_q2(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::q2} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][Q2][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::q2} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][COOLING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::q2::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${Components::IhmSubstage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${AOs::Ihm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm} ..............................................................*/

/*${AOs::Ihm::setupPageManualMode} .........................................*/
static void Ihm_setupPageManualMode(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MANUAL_MODE]");

    postUart_setPage(MANUAL_MODE_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "MODO_MANUAL", true, NAVBAR_TEXT_LEN);

    postUart_setString(SENSOR_AR_TEXT_VP, "0\0", true, SENSOR_AR_TEXT_LEN);
    postUart_setString(DELTA_AR_TEXT_VP, "0\0", true, DELTA_AR_TEXT_LEN);

    postUart_setString(SENSOR_GRAO_TEXT_VP, "0\0", true, SENSOR_GRAO_TEXT_LEN);
    postUart_setString(DELTA_GRAO_TEXT_VP, "0\0", true, DELTA_GRAO_TEXT_LEN);
}

/*${AOs::Ihm::setupPageMainMenu} ...........................................*/
static void Ihm_setupPageMainMenu(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MAIN_MENU]");

    postUart_setPage(MAIN_MENU_PICID);

    postUart_setString(NAVBAR_TEXT_VP, "HOME", true, NAVBAR_TEXT_LEN);
    postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
}

/*${AOs::Ihm::setupPageManualControls} .....................................*/
static void Ihm_setupPageManualControls(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MANUAL_CONTROLS]");

    postUart_setPage(CONTROLS_PICID);

    postUart_setIcon(NEXT_COMMAND_ICON_VP, 0);
    postUart_setString(NEXT_COMMAND_TEXT_VP, "\0", true, NEXT_COMMAND_TEXT_LEN);
    postUart_setString(NEXT_COMMAND_TIMER_TEXT_VP, "\0", true, NEXT_COMMAND_TIMER_TEXT_LEN);

    postUart_setIcon(CONTROL_POTENCIA_ICON_VP, 0);
    postUart_setString(CONTROL_POTENCIA_TEXT_VP, "\0", true, CONTROL_POTENCIA_TEXT_LEN);

    postUart_setIcon(CONTROL_CILINDRO_ICON_VP, 0);
    postUart_setString(CONTROL_CILINDRO_TEXT_VP, "\0", true, CONTROL_CILINDRO_TEXT_LEN);

    postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, 0);
    postUart_setIcon(CONTROL_TURBINA_ICON_VP, 0);
}

/*${AOs::Ihm::setupPageSummary} ............................................*/
static void Ihm_setupPageSummary(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MANUAL_MODE]");

    postUart_setPage(SUMMARY_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "RESUMO", true, NAVBAR_TEXT_LEN);
    postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
}

/*${AOs::Ihm::setupPageConfig} .............................................*/
static void Ihm_setupPageConfig(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_CONFIG]");

    postUart_setPage(CONFIG_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "CONFIGURACOES", true, NAVBAR_TEXT_LEN);
    postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 0);
}

/*${AOs::Ihm::resetState} ..................................................*/
static void Ihm_resetState(Ihm * const me) {
    me->state.control = (ControlState){
        .potencia = 0,
        .cilindro = 0,
        .turbina = TOGGLE_OFF,
        .resfriador = TOGGLE_OFF
    };
}

/*${AOs::Ihm::SM} ..........................................................*/
static QState Ihm_initial(Ihm * const me, void const * const par) {
    /*${AOs::Ihm::SM::initial} */
    /* (!) trigger the initial transition in the component */
    QHSM_INIT((QHsm *)&me->stage, (void *)0, me->super.prio);

    /* (!) trigger the initial transition in the component */
    QHSM_INIT((QHsm *)&me->substage, (void *)0, me->super.prio);
    /* state history attributes */
    me->hist_manual_page = Q_STATE_CAST(&Ihm_idle);
    return Q_TRAN(&Ihm_main_menu);
}

/*${AOs::Ihm::SM::main_menu} ...............................................*/
static QState Ihm_main_menu(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::main_menu} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MAIN_MENU][ENTRY]");

            Ihm_setupPageMainMenu();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::main_menu} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MAIN_MENU][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_manual_mode);
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            else if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_recipes);
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            else if (ihmEv->length == 5) {
                status_ = Q_TRAN(&Ihm_roasts);
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            else if (ihmEv->length == 2) {
                status_ = Q_TRAN(&Ihm_config);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode} .............................................*/
static QState Ihm_manual_mode(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ENTRY]");

            Ihm_resetState(me);

            RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
            ram->mode = MODE_MANUAL;
            strcpy(ram->roast, "");
            QACTIVE_POST(AO_DataBroker, &ram->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][EXIT]");

            RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
            ram->mode = MODE_NONE;
            strcpy(ram->roast, "");

            QACTIVE_POST(AO_DataBroker, &ram->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Ihm_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::warn_new} ...................................*/
static QState Ihm_warn_new(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::warn_new} */
        case Q_ENTRY_SIG: {
            postUart_setPage(WARN_NEW_ROAST_PICID);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::warn_new::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::warn_new::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::manual_mode::warn_new::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                Ihm_setupPageManualMode();
                status_ = Q_TRAN(&Ihm_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::warn_new::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_pre_heating);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_page} ................................*/
static QState Ihm_manual_page(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_page} */
        case Q_ENTRY_SIG: {
            Ihm_setupPageManualMode();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page} */
        case Q_EXIT_SIG: {
            /* save deep history */
            me->hist_manual_page = QHsm_state(Q_HSM_UPCAST(me));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

            ControlType control = contEv->control;
            void *payload = contEv->payload;

            if(contEv->control == POTENCIA) {
                me->state.control.potencia = (int) payload;
            } else if(contEv->control == CILINDRO) {
                me->state.control.cilindro = (int) payload;
            } else if(contEv->control == TURBINA) {
                me->state.control.turbina = (ControlToggle) payload;
            } else if(contEv->control == RESFRIADOR) {
                me->state.control.resfriador = (ControlToggle) payload;
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::SENSOR_DATA} */
        case SENSOR_DATA_SIG: {
            SensorDataEvt *sensorEv = Q_EVT_CAST(SensorDataEvt);

            SensorType type = sensorEv->type;
            int value = sensorEv->value;
            int delta = sensorEv->delta;

            if(type == SENSOR_GRAO) {
                char graoStr[6] = {0};
                sprintf(graoStr, "%d C", value);
                postUart_setString(SENSOR_GRAO_TEXT_VP, graoStr, true, SENSOR_GRAO_TEXT_LEN);

                char graoDeltaStr[6] = {0};
                sprintf(graoDeltaStr, "%d", delta);
                postUart_setString(DELTA_GRAO_TEXT_VP, graoDeltaStr, true, DELTA_GRAO_TEXT_LEN);
            } else if(sensorEv->type == SENSOR_AR) {
                char arStr[6] = {0};
                sprintf(arStr, "%d C", value);
                postUart_setString(SENSOR_AR_TEXT_VP, arStr, true, SENSOR_AR_TEXT_LEN);

                char arDeltaStr[6] = {0};
                sprintf(arDeltaStr, "%d", delta);
                postUart_setString(DELTA_AR_TEXT_VP, arDeltaStr, true, DELTA_AR_TEXT_LEN);
            } else if(sensorEv->type == SENSOR_GAS) {
                char gasStr[6] = {0};
                sprintf(gasStr, "%d", value);
                postUart_setString(SENSOR_GAS_TEXT_VP, gasStr, true, SENSOR_GAS_TEXT_LEN);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::CHART_DATA} */
        case CHART_DATA_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_page::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_manual_controls);
            }
            /*${AOs::Ihm::SM::manual_mode::manual_page::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            else if (ihmEv->length == 2) {
                status_ = Q_TRAN(&Ihm_manual_config);
            }
            /*${AOs::Ihm::SM::manual_mode::manual_page::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_page::idle} ..........................*/
static QState Ihm_idle(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_page::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][IDLE][ENTRY]");

            postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
            postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::idle::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_page::idle::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_warn_new);
            }
            /*${AOs::Ihm::SM::manual_mode::manual_page::idle::IHM_INPUT_TOUCH::[ihmEv->length==1]} */
            else if (ihmEv->length == 1) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_page);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_page::active} ........................*/
static QState Ihm_active(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_page::active} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][ENTRY]");

            postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
            postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_page);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_page::active::pre_heating} ...........*/
static QState Ihm_pre_heating(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][PRE_HEATING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::pre_heating::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_roasting);
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::pre_heating::SENSOR_DATA} */
        case SENSOR_DATA_SIG: {
            /*${AOs::Ihm::SM::manual_mode::manual_page::active::pre_heating::SENSOR_DATA::[false]} */
            if (false) {
                ESP_LOGD(TAG, "Sensor data here!");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_page::active::chart} .................*/
static QState Ihm_chart(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ENTRY]");

            QTimeEvt_armX(&me->stageTimerEvt, STAGE_TIMER_INTERVAL, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][EXIT]");

            QTimeEvt_disarm(&me->stageTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::IHM_STAGE_TIMER_TIMEOUT} */
        case IHM_STAGE_TIMER_TIMEOUT_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);

            QTimeEvt_rearm(&me->stageTimerEvt, STAGE_TIMER_INTERVAL);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::roasting} .......*/
static QState Ihm_roasting(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::roasting::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_cooling);
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::roasting::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::roasting::IHM_INPUT_TOUCH::[SUBSTAGE]} */
            if (ihmEv->length == 5) {
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_chart);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::cooling} ........*/
static QState Ihm_cooling(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][COOLING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_page::active::chart::cooling::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&Ihm_summary);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_chart);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_controls} ............................*/
static QState Ihm_manual_controls(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&Ihm_manual_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_config} ..............................*/
static QState Ihm_manual_config(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_config} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[CONFIG][ENTRY]");

            Ihm_setupPageConfig();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_config} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[CONFIG][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_config::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_config::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN_HIST(me->hist_manual_page);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode} ...............................................*/
static QState Ihm_auto_mode(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ENTRY]");

            Ihm_setupPageManualMode();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::auto_mode::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::auto_mode::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_controls} ...........................................*/
static QState Ihm_auto_controls(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::recipes} .................................................*/
static QState Ihm_recipes(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::roasts} ..................................................*/
static QState Ihm_roasts(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::summary} .................................................*/
static QState Ihm_summary(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUMMARY][ENTRY]");

            Ihm_setupPageSummary();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::summary} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUMMARY][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::config} ..................................................*/
static QState Ihm_config(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::config} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[CONFIG][ENTRY]");

            Ihm_setupPageConfig();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::config} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[CONFIG][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::config::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::config::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Ihm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${AOs::Ihm_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm_ctor} .........................................................*/
void Ihm_ctor(void) {
    Ihm *me = &l_ihm;
    IhmStage *stage = &l_ihmStage;
    IhmSubstage *substage = &l_ihmSubstage;

    QActive_ctor(&me->super, Q_STATE_CAST(&Ihm_initial));
    me->state.control = (ControlState){
        .potencia = 0,
        .cilindro = 0,
        .turbina = TOGGLE_OFF,
        .resfriador = TOGGLE_OFF
    };

    QHsm_ctor(&me->stage, Q_STATE_CAST(&IhmStage_initial));
    QHsm_ctor(&me->substage, Q_STATE_CAST(&IhmSubstage_initial));

    QTimeEvt_ctorX(&me->stageTimerEvt, &me->super, IHM_STAGE_TIMER_TIMEOUT_SIG, 0U);
}
/*$enddef${AOs::Ihm_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
