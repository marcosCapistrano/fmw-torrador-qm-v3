/*$file${.::ihm.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: fmw-torrador-v3.qm
* File:  ${.::ihm.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::ihm.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include <math.h>
#include "common.h"
#include "esp_log.h"
#include <string.h>
#include <time.h>
#include "esp_unicviewad.h"

Q_DEFINE_THIS_FILE

#define MAIN_MENU_PICID 0
#define MANUAL_MODE_PICID 1
#define CONFIG_PICID 2
#define CONTROLS_PICID 3
#define SUMMARY_PICID 4
#define ROASTS_PICID 5
#define ROAST_PICID 6
#define WARN_NEW_ROAST_PICID 7
#define WARN_REPEAT_RECIPE_PICID 8
#define WARN_REPLAY_RECIPE_PICID 9
#define WARN_SAVE_RECIPE_PICID 10
#define WARN_TEMP_PRE_PICID 11
#define WARN_TEMP_COOL_PICID 12

#define STAGE_STATUS_ICON_VP 38
#define STAGE_BTN_ICON_VP 48
#define SUBSTAGE_BTN_ICON_VP 436
#define NAVBAR_ICON_HOME_VP 36
#define NAVBAR_ICON_GEAR_VP 37
#define NEXT_COMMAND_ICON_VP 85
#define CONTROL_POTENCIA_ICON_VP 79
#define CONTROL_CILINDRO_ICON_VP 81
#define CONTROL_RESFRIADOR_ICON_VP 83
#define CONTROL_TURBINA_ICON_VP 84

#define SENSOR_GAS_TEXT_VP 0
#define SENSOR_AR_TEXT_VP 49
#define DELTA_AR_TEXT_VP 55
#define SENSOR_GRAO_TEXT_VP 61
#define DELTA_GRAO_TEXT_VP 67
#define NAVBAR_TEXT_VP 1
#define STAGE_TIMER_TEXT_VP 39
#define NEXT_COMMAND_TEXT_VP 95
#define NEXT_COMMAND_TIMER_TEXT_VP 86
#define CONTROL_POTENCIA_TEXT_VP 426
#define CONTROL_CILINDRO_TEXT_VP 431
#define SUMMARY_TITLE_TEXT_VP 111
#define SUMMARY_SUBTITLE_TEXT_VP 147
#define SUMMARY_SUBTITLE2_TEXT_VP 162

#define SENSOR_GAS_TEXT_LEN 4
#define SENSOR_AR_TEXT_LEN 6
#define DELTA_AR_TEXT_LEN 6
#define SENSOR_GRAO_TEXT_LEN 6
#define DELTA_GRAO_TEXT_LEN 6
#define NAVBAR_TEXT_LEN 35
#define STAGE_TIMER_TEXT_LEN 9
#define NEXT_COMMAND_TEXT_LEN 15
#define NEXT_COMMAND_TIMER_TEXT_LEN 9
#define CONTROL_POTENCIA_TEXT_LEN 4
#define CONTROL_CILINDRO_TEXT_LEN 4
#define SUMMARY_TITLE_TEXT_LEN 35
#define SUMMARY_SUBTITLE_TEXT_LEN 16
#define SUMMARY_SUBTITLE2_TEXT_LEN 23


#define CONFIG_PRE_HEAT_NUMBER_VP 73
#define CONFIG_ROAST_NUMBER_VP 76

#define CONTROL_POTENCIA_SLIDER_VP 80
#define CONTROL_CILINDRO_SLIDER_VP 82

static const char * TAG = "IHM";

/*$declare${Components::IhmStage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmStage} ..................................................*/
typedef struct {
/* protected: */
    QHsm super;

/* public: */
    time_t timer_start;
} IhmStage;

/* public: */
static void IhmStage_setTimer(IhmStage * const me,
    bool reset,
    bool visible);

/* protected: */
static QState IhmStage_initial(IhmStage * const me, void const * const par);
static QState IhmStage_idle(IhmStage * const me, QEvt const * const e);
static QState IhmStage_pre_heating(IhmStage * const me, QEvt const * const e);
static QState IhmStage_timing(IhmStage * const me, QEvt const * const e);
static QState IhmStage_roasting(IhmStage * const me, QEvt const * const e);
static QState IhmStage_cooling(IhmStage * const me, QEvt const * const e);
static QState IhmStage_summary(IhmStage * const me, QEvt const * const e);
/*$enddecl${Components::IhmStage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$declare${Components::IhmSubstage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmSubstage} ...............................................*/
typedef struct {
/* protected: */
    QHsm super;
} IhmSubstage;

/* protected: */
static QState IhmSubstage_initial(IhmSubstage * const me, void const * const par);
static QState IhmSubstage_idle(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_state1(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_q1(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_f(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_q2(IhmSubstage * const me, QEvt const * const e);
/*$enddecl${Components::IhmSubstage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$declare${AOs::Ihm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm} ..............................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */
    IhmState state;
    QTimeEvt stageTimerEvt;

/* private: */
    IhmStage stage;
    IhmSubstage substage;

/* private state histories */
    QStateHandler hist_manual_page;
} Ihm;

/* private: */
static void Ihm_setupPageManualMode(void);
static void Ihm_setupPageMainMenu(void);
static void Ihm_setupPageManualControls(void);
static void Ihm_setupPageSummary(void);
static void Ihm_setupPageConfig(void);
static void Ihm_resetState(Ihm * const me);
static void Ihm_setupPageControls(Ihm * const me);
static void Ihm_requestExitMode(void);

/* protected: */
static QState Ihm_initial(Ihm * const me, void const * const par);
static QState Ihm_main_menu(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_mode(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_config(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_events(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_page(Ihm * const me, QEvt const * const e);
static QState Ihm_idle(Ihm * const me, QEvt const * const e);
static QState Ihm_active(Ihm * const me, QEvt const * const e);
static QState Ihm_pre_heating(Ihm * const me, QEvt const * const e);
static QState Ihm_chart(Ihm * const me, QEvt const * const e);
static QState Ihm_roasting(Ihm * const me, QEvt const * const e);
static QState Ihm_cooling(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_controls(Ihm * const me, QEvt const * const e);
static QState Ihm_warn_new(Ihm * const me, QEvt const * const e);
static QState Ihm_summary(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_mode(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_controls(Ihm * const me, QEvt const * const e);
static QState Ihm_recipes(Ihm * const me, QEvt const * const e);
static QState Ihm_roasts(Ihm * const me, QEvt const * const e);
static QState Ihm_config(Ihm * const me, QEvt const * const e);
/*$enddecl${AOs::Ihm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


static Ihm l_ihm; /* a única instância do AO IHM */
static IhmStage l_ihmStage; /* a única instância do AO IHM */
static IhmSubstage l_ihmSubstage; /* a única instância do AO IHM */

#define STAGE_TIMER_INTERVAL  \
    (QTimeEvtCtr)((1 * CONFIG_FREERTOS_HZ))

QActive * const AO_Ihm = &l_ihm.super;

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${Components::IhmStage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmStage} ..................................................*/

/*${Components::IhmStage::setTimer} ........................................*/
static void IhmStage_setTimer(IhmStage * const me,
    bool reset,
    bool visible)
{
    time_t rawtime;
    struct tm *info;
    char buffer[8];

    time( &rawtime );

    if(reset) {
        me->timer_start = rawtime;
    }

    if(visible) {
        time_t elapsed = rawtime-me->timer_start;

        info = localtime( &elapsed );
        strftime(buffer,80,"%H:%M:%S", info);

        postUart_setString(STAGE_TIMER_TEXT_VP, buffer, false, STAGE_TIMER_TEXT_LEN);
    } else {
        postUart_setString(STAGE_TIMER_TEXT_VP, "\0", true, STAGE_TIMER_TEXT_LEN);
    }


}

/*${Components::IhmStage::SM} ..............................................*/
static QState IhmStage_initial(IhmStage * const me, void const * const par) {
    /*${Components::IhmStage::SM::initial} */
    return Q_TRAN(&IhmStage_idle);
}

/*${Components::IhmStage::SM::idle} ........................................*/
static QState IhmStage_idle(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][IDLE][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 0);
            postUart_setIcon(STAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::idle::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_pre_heating);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::pre_heating} .................................*/
static QState IhmStage_pre_heating(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][PRE_HEATING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 1);
            postUart_setIcon(STAGE_BTN_ICON_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::pre_heating::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_roasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::timing} ......................................*/
static QState IhmStage_timing(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::timing} */
        case Q_EXIT_SIG: {
            IhmStage_setTimer(me, true, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::IHM_STAGE_TIMER_TIMEOUT} */
        case IHM_STAGE_TIMER_TIMEOUT_SIG: {
            IhmStage_setTimer(me, false, true);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::timing::roasting} ............................*/
static QState IhmStage_roasting(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::timing::roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][ROASTING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 2);
            postUart_setIcon(STAGE_BTN_ICON_VP, 2);

            IhmStage_setTimer(me, true, true);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][ROASTING][EXIT]");

            IhmStage_setTimer(me, true, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::roasting::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_cooling);
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_timing);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::timing::cooling} .............................*/
static QState IhmStage_cooling(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::timing::cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][COOLING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 3);
            postUart_setIcon(STAGE_BTN_ICON_VP, 3);

            IhmStage_setTimer(me, true, true);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][COOLING][EXIT]");

            IhmStage_setTimer(me, true, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::timing::cooling::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_summary);
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_timing);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::summary} .....................................*/
static QState IhmStage_summary(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][SUMMARy][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::summary} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][SUMMARy][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::summary::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            status_ = Q_TRAN(&IhmStage_pre_heating);
            break;
        }
        /*${Components::IhmStage::SM::summary::NOTIFY_MODE} */
        case NOTIFY_MODE_SIG: {
            NotifyModeEvt *rme = Q_EVT_CAST(NotifyModeEvt);
            /*${Components::IhmStage::SM::summary::NOTIFY_MODE::[rme->mode==MODE_NONE]} */
            if (rme->mode == MODE_NONE) {
                status_ = Q_TRAN(&IhmStage_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${Components::IhmStage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${Components::IhmSubstage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmSubstage} ...............................................*/

/*${Components::IhmSubstage::SM} ...........................................*/
static QState IhmSubstage_initial(IhmSubstage * const me, void const * const par) {
    /*${Components::IhmSubstage::SM::initial} */
    return Q_TRAN(&IhmSubstage_idle);
}

/*${Components::IhmSubstage::SM::idle} .....................................*/
static QState IhmSubstage_idle(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][IDLE][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::idle::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_state1);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::state1} ...................................*/
static QState IhmSubstage_state1(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::state1::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&IhmSubstage_f);
            break;
        }
        /*${Components::IhmSubstage::SM::state1::NOTIFY_SUBSTAGE_EXIT} */
        case NOTIFY_SUBSTAGE_EXIT_SIG: {
            status_ = Q_TRAN(&IhmSubstage_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::state1::q1} ...............................*/
static QState IhmSubstage_q1(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::state1::q1} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][Q1][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 2);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::q1} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::q1::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_q2);
            break;
        }
        /*${Components::IhmSubstage::SM::state1::q1::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${Components::IhmSubstage::SM::state1::q1::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            if (ihmEv->length == 5) {
                RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
                stageEv->substage = Q2;
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmSubstage_state1);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::state1::f} ................................*/
static QState IhmSubstage_f(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::state1::f} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][F][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::f} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][F][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::f::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_q1);
            break;
        }
        /*${Components::IhmSubstage::SM::state1::f::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${Components::IhmSubstage::SM::state1::f::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            if (ihmEv->length == 5) {
                RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
                stageEv->substage = Q1;
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmSubstage_state1);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::state1::q2} ...............................*/
static QState IhmSubstage_q2(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::state1::q2} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][Q2][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::q2} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][COOLING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmSubstage_state1);
            break;
        }
    }
    return status_;
}
/*$enddef${Components::IhmSubstage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${AOs::Ihm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm} ..............................................................*/

/*${AOs::Ihm::setupPageManualMode} .........................................*/
static void Ihm_setupPageManualMode(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MANUAL_MODE]");

    postUart_setPage(MANUAL_MODE_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "MODO MANUAL", true, NAVBAR_TEXT_LEN);

    postUart_setString(SENSOR_AR_TEXT_VP, "0\0", true, SENSOR_AR_TEXT_LEN);
    postUart_setString(DELTA_AR_TEXT_VP, "0\0", true, DELTA_AR_TEXT_LEN);

    postUart_setString(SENSOR_GRAO_TEXT_VP, "0\0", true, SENSOR_GRAO_TEXT_LEN);
    postUart_setString(DELTA_GRAO_TEXT_VP, "0\0", true, DELTA_GRAO_TEXT_LEN);
}

/*${AOs::Ihm::setupPageMainMenu} ...........................................*/
static void Ihm_setupPageMainMenu(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MAIN_MENU]");

    postUart_setPage(MAIN_MENU_PICID);

    postUart_setString(NAVBAR_TEXT_VP, "HOME", true, NAVBAR_TEXT_LEN);
    postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
}

/*${AOs::Ihm::setupPageManualControls} .....................................*/
static void Ihm_setupPageManualControls(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MANUAL_CONTROLS]");

    postUart_setPage(CONTROLS_PICID);

    postUart_setIcon(NEXT_COMMAND_ICON_VP, 0);
    postUart_setString(NEXT_COMMAND_TEXT_VP, "\0", true, NEXT_COMMAND_TEXT_LEN);
    postUart_setString(NEXT_COMMAND_TIMER_TEXT_VP, "\0", true, NEXT_COMMAND_TIMER_TEXT_LEN);

    postUart_setIcon(CONTROL_POTENCIA_ICON_VP, 0);
    postUart_setString(CONTROL_POTENCIA_TEXT_VP, "\0", true, CONTROL_POTENCIA_TEXT_LEN);

    postUart_setIcon(CONTROL_CILINDRO_ICON_VP, 0);
    postUart_setString(CONTROL_CILINDRO_TEXT_VP, "\0", true, CONTROL_CILINDRO_TEXT_LEN);

    postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, 0);
    postUart_setIcon(CONTROL_TURBINA_ICON_VP, 0);
}

/*${AOs::Ihm::setupPageSummary} ............................................*/
static void Ihm_setupPageSummary(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MANUAL_MODE]");

    postUart_setPage(SUMMARY_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "RESUMO", true, NAVBAR_TEXT_LEN);

    postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 0);
}

/*${AOs::Ihm::setupPageConfig} .............................................*/
static void Ihm_setupPageConfig(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_CONFIG]");

    postUart_setPage(CONFIG_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "CONFIGURACOES", true, NAVBAR_TEXT_LEN);
    postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 0);

    postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, 0);
    postUart_setNumber(CONFIG_ROAST_NUMBER_VP, 0);
}

/*${AOs::Ihm::resetState} ..................................................*/
static void Ihm_resetState(Ihm * const me) {
    me->state.control = (ControlState){
        .potencia = 0,
        .cilindro = 0,
        .turbina = TOGGLE_OFF,
        .resfriador = TOGGLE_OFF
    };
}

/*${AOs::Ihm::setupPageControls} ...........................................*/
static void Ihm_setupPageControls(Ihm * const me) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_CONTROLS]");

    postUart_setPage(CONTROLS_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "CONTROLES", true, NAVBAR_TEXT_LEN);

    postUart_setString(SENSOR_AR_TEXT_VP, "0\0", true, SENSOR_AR_TEXT_LEN);
    postUart_setString(DELTA_AR_TEXT_VP, "0\0", true, DELTA_AR_TEXT_LEN);

    postUart_setString(SENSOR_GRAO_TEXT_VP, "0\0", true, SENSOR_GRAO_TEXT_LEN);
    postUart_setString(DELTA_GRAO_TEXT_VP, "0\0", true, DELTA_GRAO_TEXT_LEN);

    uint8_t potValue = ceil(me->state.control.potencia / 5) * 5;
    uint8_t potIcon = ceil(potValue / 5);
    char potStr[100] = {0};
    strcpy(potStr, itoa(potValue, potStr, 10));

    postUart_setString(CONTROL_POTENCIA_TEXT_VP, potStr, true, CONTROL_POTENCIA_TEXT_LEN);
    postUart_setIcon(CONTROL_POTENCIA_ICON_VP, potIcon);

    uint8_t cilValue = ceil(me->state.control.cilindro / 5) * 5;
    uint8_t cilIcon = ceil(cilValue / 5);
    char cilStr[100] = {0};
    strcpy(cilStr, itoa(cilValue, cilStr, 10));

    postUart_setString(CONTROL_CILINDRO_TEXT_VP, cilStr, true, CONTROL_CILINDRO_TEXT_LEN);
    postUart_setIcon(CONTROL_CILINDRO_ICON_VP, cilIcon);
}

/*${AOs::Ihm::requestExitMode} .............................................*/
static void Ihm_requestExitMode(void) {
    RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
    ram->mode = MODE_NONE;
    strcpy(ram->roast, "");

    QACTIVE_POST(AO_DataBroker, &ram->super, me);
}

/*${AOs::Ihm::SM} ..........................................................*/
static QState Ihm_initial(Ihm * const me, void const * const par) {
    /*${AOs::Ihm::SM::initial} */
    /* (!) trigger the initial transition in the component */
    QHSM_INIT((QHsm *)&me->stage, (void *)0, me->super.prio);

    /* (!) trigger the initial transition in the component */
    QHSM_INIT((QHsm *)&me->substage, (void *)0, me->super.prio);
    /* state history attributes */
    me->hist_manual_page = Q_STATE_CAST(&Ihm_idle);
    return Q_TRAN(&Ihm_main_menu);
}

/*${AOs::Ihm::SM::main_menu} ...............................................*/
static QState Ihm_main_menu(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::main_menu} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MAIN_MENU][ENTRY]");

            Ihm_setupPageMainMenu();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::main_menu} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MAIN_MENU][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_manual_mode);
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            else if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_recipes);
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            else if (ihmEv->length == 5) {
                status_ = Q_TRAN(&Ihm_roasts);
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            else if (ihmEv->length == 2) {
                status_ = Q_TRAN(&Ihm_config);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode} .............................................*/
static QState Ihm_manual_mode(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ENTRY]");

            Ihm_resetState(me);

            RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
            ram->mode = MODE_MANUAL;
            strcpy(ram->roast, "");
            QACTIVE_POST(AO_DataBroker, &ram->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Ihm_idle);
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::NOTIFY_MODE} */
        case NOTIFY_MODE_SIG: {
            NotifyModeEvt *nme = Q_EVT_CAST(NotifyModeEvt);
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            /*${AOs::Ihm::SM::manual_mode::NOTIFY_MODE::[nme->mode==MODE_NONE]} */
            if (nme->mode == MODE_NONE) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_config} ..............................*/
static QState Ihm_manual_config(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_config} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[CONFIG][ENTRY]");

            ESP_LOGE(TAG, "size: %d", sizeof(unsigned short));

            Ihm_setupPageConfig();

            RequestConfigEvt *confEv = Q_NEW(RequestConfigEvt, REQUEST_CONFIG_SIG);
            QACTIVE_POST(AO_DataBroker, confEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_config} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[CONFIG][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_config::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_config::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN_HIST(me->hist_manual_page);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_config::IHM_INPUT_CONFIG_SAVE} */
        case IHM_INPUT_CONFIG_SAVE_SIG: {
            IhmInputConfigSaveEvt *ev = Q_EVT_CAST(IhmInputConfigSaveEvt);

            ConfigUpdateEvt *confEv = Q_NEW(ConfigUpdateEvt, CONFIG_UPDATE_SIG);
            confEv->pre_heat = ev->pre;
            confEv->roast = ev->roast;

            QACTIVE_POST(AO_DataBroker, confEv, me);
            status_ = Q_TRAN_HIST(me->hist_manual_page);
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_config::RESPONSE_CONFIG} */
        case RESPONSE_CONFIG_SIG: {
            ResponseConfigEvt *respEv = Q_EVT_CAST(ResponseConfigEvt);

            //POST to uart
            postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, respEv->pre_heat);
            postUart_setNumber(CONFIG_ROAST_NUMBER_VP, respEv->roast);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events} ..............................*/
static QState Ihm_manual_events(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

            ControlType control = contEv->control;
            int value = contEv->value;

            if(contEv->control == POTENCIA) {
                me->state.control.potencia = value;
            } else if(contEv->control == CILINDRO) {
                me->state.control.cilindro = value;
            } else if(contEv->control == TURBINA) {
                if(value == 0)
                    me->state.control.turbina = TOGGLE_OFF;
                else if(value == 70)
                    me->state.control.turbina = TOGGLE_SEVENTY;
                else if(value == 80)
                    me->state.control.turbina = TOGGLE_EIGHTY;
                else if(value == 90)
                    me->state.control.turbina = TOGGLE_NINETY;
                else if(value == 100)
                    me->state.control.turbina = TOGGLE_MAX;
            } else if(contEv->control == RESFRIADOR) {
                if(value == 0)
                    me->state.control.resfriador = TOGGLE_OFF;
                else
                    me->state.control.resfriador = TOGGLE_MAX;
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::SENSOR_DATA} */
        case SENSOR_DATA_SIG: {
            SensorDataEvt *sensorEv = Q_EVT_CAST(SensorDataEvt);

            SensorType type = sensorEv->type;
            int value = sensorEv->value;
            int delta = sensorEv->delta;

            if(type == SENSOR_GRAO) {
                char graoStr[6] = {0};
                sprintf(graoStr, "%d C", value);
                postUart_setString(SENSOR_GRAO_TEXT_VP, graoStr, true, SENSOR_GRAO_TEXT_LEN);

                char graoDeltaStr[6] = {0};
                sprintf(graoDeltaStr, "%d", delta);
                postUart_setString(DELTA_GRAO_TEXT_VP, graoDeltaStr, true, DELTA_GRAO_TEXT_LEN);
            } else if(sensorEv->type == SENSOR_AR) {
                char arStr[6] = {0};
                sprintf(arStr, "%d C", value);
                postUart_setString(SENSOR_AR_TEXT_VP, arStr, true, SENSOR_AR_TEXT_LEN);

                char arDeltaStr[6] = {0};
                sprintf(arDeltaStr, "%d", delta);
                postUart_setString(DELTA_AR_TEXT_VP, arDeltaStr, true, DELTA_AR_TEXT_LEN);
            } else if(sensorEv->type == SENSOR_GAS) {
                char gasStr[6] = {0};
                sprintf(gasStr, "%d", value);
                postUart_setString(SENSOR_GAS_TEXT_VP, gasStr, true, SENSOR_GAS_TEXT_LEN);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events::manual_page} .................*/
static QState Ihm_manual_page(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page} */
        case Q_ENTRY_SIG: {
            Ihm_setupPageManualMode();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page} */
        case Q_EXIT_SIG: {
            /* save deep history */
            me->hist_manual_page = QHsm_state(Q_HSM_UPCAST(me));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::CHART_DATA} */
        case CHART_DATA_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_manual_controls);
            }
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            else if (ihmEv->length == 2) {
                status_ = Q_TRAN(&Ihm_manual_config);
            }
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_events);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::idle} ...........*/
static QState Ihm_idle(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][IDLE][ENTRY]");

            postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
            postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::idle::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::idle::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_warn_new);
            }
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::idle::IHM_INPUT_TOUCH::[ihmEv->length==1]} */
            else if (ihmEv->length == 1) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_page);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active} .........*/
static QState Ihm_active(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][ENTRY]");

            postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
            postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_page);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::pre_heating}*/
static QState Ihm_pre_heating(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][PRE_HEATING][ENTRY]");


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::pre_heating::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_roasting);
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::pre_heating::SENSOR_DATA} */
        case SENSOR_DATA_SIG: {
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::pre_heating::SENSOR_DATA::[false]} */
            if (false) {
                ESP_LOGD(TAG, "Sensor data here!");
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart} ..*/
static QState Ihm_chart(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ENTRY]");

            QTimeEvt_armX(&me->stageTimerEvt, STAGE_TIMER_INTERVAL, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][EXIT]");

            QTimeEvt_disarm(&me->stageTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::IHM_STAGE_TIMER_TIMEOUT} */
        case IHM_STAGE_TIMER_TIMEOUT_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);

            QTimeEvt_rearm(&me->stageTimerEvt, STAGE_TIMER_INTERVAL);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::roasting}*/
static QState Ihm_roasting(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][ENTRY]");

            RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
            stageEv->substage = F;
            QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][EXIT]");

            NotifySubstageExitEvt *stageEv = Q_NEW(NotifySubstageExitEvt, NOTIFY_SUBSTAGE_EXIT_SIG);
            QHSM_DISPATCH((QHsm *)&me->substage, stageEv, me->super.prio);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::roasting::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_cooling);
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::roasting::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::roasting::IHM_INPUT_TOUCH::[SUBSTAGE]} */
            if (ihmEv->length == 5) {
                QHSM_DISPATCH((QHsm *)&me->substage, e, me->super.prio);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::roasting::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            NotifyNextSubstageEvt *subEv = Q_EVT_CAST(NotifyNextSubstageEvt);

            QHSM_DISPATCH((QHsm *)&me->substage, subEv, me->super.prio);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_chart);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::cooling}*/
static QState Ihm_cooling(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][COOLING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_page::active::chart::cooling::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_summary);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_chart);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls} .............*/
static QState Ihm_manual_controls(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][CONTROLS}[ENTRY]");
            Ihm_setupPageControls(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][CONTROLS}[EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            if (ihmEv->length == 2) {
                status_ = Q_TRAN_HIST(me->hist_manual_page);
            }
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls::IHM_INPUT_TOUCH::[RESFRIADOR]} */
            else if (ihmEv->length == 3) {
                ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
                contEv->control = RESFRIADOR;

                if(me->state.control.resfriador == TOGGLE_OFF) {
                    ESP_LOGE(TAG, "Sending 1");
                    contEv->value = 1;
                } else {
                    ESP_LOGE(TAG, "Sending 0");
                    contEv->value = 0;
                }

                QACTIVE_POST(AO_DataBroker, contEv, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls::IHM_INPUT_TOUCH::[TURBINA]} */
            else if (ihmEv->length == 4) {
                ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
                contEv->control = TURBINA;

                if(me->state.control.turbina == TOGGLE_OFF) {
                    contEv->value = 70;
                } else if(me->state.control.turbina == TOGGLE_SEVENTY) {
                    contEv->value = 80;
                } else if(me->state.control.turbina == TOGGLE_EIGHTY) {
                    contEv->value = 90;
                } else if(me->state.control.turbina == TOGGLE_NINETY) {
                    contEv->value = 100;
                } else if(me->state.control.turbina == TOGGLE_MAX) {
                    contEv->value = 0;
                }

                QACTIVE_POST(AO_DataBroker, contEv, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls::IHM_INPUT_SLIDER} */
        case IHM_INPUT_SLIDER_SIG: {
            IhmInputSliderEvt *ihmEv = Q_EVT_CAST(IhmInputSliderEvt);
            ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);

            uint8_t value = ceil(ihmEv->value / 5) * 5;
            uint8_t icon = ceil(value / 5);

            ESP_LOGE(TAG, "%d, %d, %d", ihmEv->control, value, icon);

            if(ihmEv->control == POTENCIA) {
                contEv->control = POTENCIA;
                contEv->value = value;
            } else if(ihmEv->control == CILINDRO) {
                contEv->control = CILINDRO;
                contEv->value = value;
            }

            QACTIVE_POST(AO_DataBroker, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::manual_events::manual_controls::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

            ControlType control = contEv->control;
            int value = contEv->value;
            int icon = ceil(value / 5);

            if(contEv->control == POTENCIA) {
                me->state.control.potencia = value;

                char potStr[100] = {0};
                strcpy(potStr, itoa(value, potStr, 10));

                postUart_setString(CONTROL_POTENCIA_TEXT_VP, potStr, true, CONTROL_POTENCIA_TEXT_LEN);
                postUart_setIcon(CONTROL_POTENCIA_ICON_VP, icon);
            } else if(contEv->control == CILINDRO) {
                me->state.control.cilindro = value;

                char cilStr[100] = {0};
                strcpy(cilStr, itoa(value, cilStr, 10));

                postUart_setString(CONTROL_CILINDRO_TEXT_VP, cilStr, true, CONTROL_POTENCIA_TEXT_LEN);
                postUart_setIcon(CONTROL_CILINDRO_ICON_VP, icon);
            } else if(contEv->control == TURBINA) {
                int icon = 0;

                if(value == 0) {
                    me->state.control.turbina = TOGGLE_OFF;
                    icon = 0;
                } else if(value == 70) {
                    me->state.control.turbina = TOGGLE_SEVENTY;
                    icon = 1;
                } else if(value == 80) {
                    me->state.control.turbina = TOGGLE_EIGHTY;
                    icon = 2;
                } else if(value == 90) {
                    me->state.control.turbina = TOGGLE_NINETY;
                    icon = 3;
                } else if(value == 100) {
                    me->state.control.turbina = TOGGLE_MAX;
                    icon = 4;
                }

                 postUart_setIcon(CONTROL_TURBINA_ICON_VP, icon);
            } else if(contEv->control == RESFRIADOR) {
                int icon = 0;

                if(value == 0) {
                    icon = 0;
                    me->state.control.resfriador = TOGGLE_OFF;
                } else {
                    icon = 4;
                    me->state.control.resfriador = TOGGLE_MAX;
                }
                postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, icon);
            }


            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_events);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::warn_new} ...................................*/
static QState Ihm_warn_new(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::warn_new} */
        case Q_ENTRY_SIG: {
            postUart_setPage(WARN_NEW_ROAST_PICID);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::warn_new::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::warn_new::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::manual_mode::warn_new::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                Ihm_setupPageManualMode();
                status_ = Q_TRAN(&Ihm_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::warn_new::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_pre_heating);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::manual_mode::summary} ....................................*/
static QState Ihm_summary(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::manual_mode::summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUMMARY][ENTRY]");

            Ihm_setupPageSummary();

            RequestSummaryEvt *reqEv = Q_NEW(RequestSummaryEvt, REQUEST_SUMMARY_SIG);
            QACTIVE_POST(AO_DataBroker, reqEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::summary} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUMMARY][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::summary::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::manual_mode::summary::IHM_INPUT_TOUCH::[ihmEv->length==1||ihmEv->length~} */
            if (ihmEv->length == 1 || ihmEv->length == 4) {
                RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
                ram->mode = MODE_NONE;
                strcpy(ram->roast, "");
                QACTIVE_POST(AO_DataBroker, &ram->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::manual_mode::summary::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::summary::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_pre_heating);
            break;
        }
        /*${AOs::Ihm::SM::manual_mode::summary::RESPONSE_SUMMARY} */
        case RESPONSE_SUMMARY_SIG: {
            ResponseSummaryEvt *resEv = Q_EVT_CAST(ResponseSummaryEvt);

            char fullStr[SUMMARY_TITLE_TEXT_LEN] = "\0";
            sprintf(fullStr, "Torra salva: Torra %s", resEv->name);

            postUart_setString(SUMMARY_TITLE_TEXT_VP, fullStr, true, SUMMARY_TITLE_TEXT_LEN);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode} ...............................................*/
static QState Ihm_auto_mode(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ENTRY]");

            Ihm_setupPageManualMode();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::auto_mode::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::auto_mode::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_controls} ...........................................*/
static QState Ihm_auto_controls(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::recipes} .................................................*/
static QState Ihm_recipes(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::roasts} ..................................................*/
static QState Ihm_roasts(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::config} ..................................................*/
static QState Ihm_config(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::config} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[CONFIG][ENTRY]");

            Ihm_setupPageConfig();

            RequestConfigEvt *reqEv = Q_NEW(RequestConfigEvt, REQUEST_CONFIG_SIG);
            QACTIVE_POST(AO_DataBroker, reqEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::config} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[CONFIG][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::config::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::config::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::config::RESPONSE_CONFIG} */
        case RESPONSE_CONFIG_SIG: {
            ResponseConfigEvt *respEv = Q_EVT_CAST(ResponseConfigEvt);

            //POST to uart
            postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, respEv->pre_heat);
            postUart_setNumber(CONFIG_ROAST_NUMBER_VP, respEv->roast);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Ihm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${AOs::Ihm_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm_ctor} .........................................................*/
void Ihm_ctor(void) {
    Ihm *me = &l_ihm;
    IhmStage *stage = &l_ihmStage;
    IhmSubstage *substage = &l_ihmSubstage;

    QActive_ctor(&me->super, Q_STATE_CAST(&Ihm_initial));
    me->state.control = (ControlState){
        .potencia = 0,
        .cilindro = 0,
        .turbina = TOGGLE_OFF,
        .resfriador = TOGGLE_OFF
    };

    QHsm_ctor(&me->stage, Q_STATE_CAST(&IhmStage_initial));
    QHsm_ctor(&me->substage, Q_STATE_CAST(&IhmSubstage_initial));

    QTimeEvt_ctorX(&me->stageTimerEvt, &me->super, IHM_STAGE_TIMER_TIMEOUT_SIG, 0U);
}
/*$enddef${AOs::Ihm_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
