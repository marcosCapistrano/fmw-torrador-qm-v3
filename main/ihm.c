/*$file${.::ihm.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: fmw-torrador-v3.qm
* File:  ${.::ihm.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::ihm.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include <math.h>
#include "common.h"
#include "esp_log.h"
#include <string.h>
#include <time.h>
#include "esp_unicviewad.h"

Q_DEFINE_THIS_FILE

#define VP_CHART_LINE_GRAO 3827
#define VP_CHART_CIRCLE_GRAO 3572
#define VP_CHART_LINE_AR 3317
#define VP_CHART_CIRCLE_AR 3062

#define MAIN_MENU_PICID 0
#define MANUAL_MODE_PICID 1
#define CONFIG_PICID 2
#define CONTROLS_PICID 3
#define SUMMARY_PICID 4
#define ROASTS_PICID 5
#define ROAST_PICID 6
#define WARN_NEW_ROAST_PICID 7
#define WARN_REPEAT_RECIPE_PICID 8
#define WARN_REPLAY_RECIPE_PICID 9
#define WARN_SAVE_RECIPE_PICID 10
#define WARN_TEMP_PRE_PICID 11
#define WARN_TEMP_COOL_PICID 12

#define STAGE_STATUS_ICON_VP 38
#define STAGE_BTN_ICON_VP 48
#define SUBSTAGE_BTN_ICON_VP 436
#define NAVBAR_ICON_HOME_VP 36
#define NAVBAR_ICON_GEAR_VP 37
#define NEXT_COMMAND_ICON_VP 85
#define CONTROL_POTENCIA_ICON_VP 79
#define CONTROL_CILINDRO_ICON_VP 81
#define CONTROL_RESFRIADOR_ICON_VP 83
#define CONTROL_TURBINA_ICON_VP 84
#define ROASTS_ICON_LEFT_VP 185
#define ROASTS_ICON_RIGHT_VP 186
#define ROASTS_ICON_ROAST1_VP 187
#define ROASTS_ICON_ROAST2_VP 188
#define ROASTS_ICON_ROAST3_VP 189
#define ROAST_BTN_ICON_VP 185

#define SENSOR_GAS_TEXT_VP 4082
#define SENSOR_AR_TEXT_VP 61
#define DELTA_AR_TEXT_VP 67
#define SENSOR_GRAO_TEXT_VP 49
#define DELTA_GRAO_TEXT_VP 67
#define NAVBAR_TEXT_VP 1
#define STAGE_TIMER_TEXT_VP 39
#define NEXT_COMMAND_TEXT_VP 95
#define NEXT_COMMAND_TIMER_TEXT_VP 86
#define CONTROL_POTENCIA_TEXT_VP 426
#define CONTROL_CILINDRO_TEXT_VP 431
#define SUMMARY_TITLE_TEXT_VP 111
#define SUMMARY_SUBTITLE_TEXT_VP 147
#define SUMMARY_SUBTITLE2_TEXT_VP 162
#define ROASTS_TEXT_ROAST1_VP 437
#define ROASTS_TEXT_ROAST2_VP 462
#define ROASTS_TEXT_ROAST3_VP 487

#define SENSOR_GAS_TEXT_LEN 4
#define SENSOR_AR_TEXT_LEN 6
#define DELTA_AR_TEXT_LEN 6
#define SENSOR_GRAO_TEXT_LEN 6
#define DELTA_GRAO_TEXT_LEN 6
#define NAVBAR_TEXT_LEN 35
#define STAGE_TIMER_TEXT_LEN 9
#define NEXT_COMMAND_TEXT_LEN 15
#define NEXT_COMMAND_TIMER_TEXT_LEN 9
#define CONTROL_POTENCIA_TEXT_LEN 4
#define CONTROL_CILINDRO_TEXT_LEN 4
#define SUMMARY_TITLE_TEXT_LEN 35
#define SUMMARY_SUBTITLE_TEXT_LEN 16
#define SUMMARY_SUBTITLE2_TEXT_LEN 23
#define ROASTS_TEXT_ROAST1_LEN 25
#define ROASTS_TEXT_ROAST2_LEN 25
#define ROASTS_TEXT_ROAST3_LEN 25


#define CONFIG_PRE_HEAT_NUMBER_VP 73
#define CONFIG_ROAST_NUMBER_VP 76

#define CONTROL_POTENCIA_SLIDER_VP 80
#define CONTROL_CILINDRO_SLIDER_VP 82

static const char * TAG = "IHM";

/*$declare${Components::IhmStage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmStage} ..................................................*/
typedef struct {
/* protected: */
    QHsm super;

/* public: */
    time_t timer_start;
} IhmStage;

/* public: */
static void IhmStage_setTimer(IhmStage * const me,
    bool reset,
    bool visible);

/* protected: */
static QState IhmStage_initial(IhmStage * const me, void const * const par);
static QState IhmStage_state1(IhmStage * const me, QEvt const * const e);
static QState IhmStage_idle(IhmStage * const me, QEvt const * const e);
static QState IhmStage_pre_heating(IhmStage * const me, QEvt const * const e);
static QState IhmStage_timing(IhmStage * const me, QEvt const * const e);
static QState IhmStage_roasting(IhmStage * const me, QEvt const * const e);
static QState IhmStage_cooling(IhmStage * const me, QEvt const * const e);
static QState IhmStage_summary(IhmStage * const me, QEvt const * const e);
/*$enddecl${Components::IhmStage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$declare${Components::IhmSubstage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmSubstage} ...............................................*/
typedef struct {
/* protected: */
    QHsm super;
} IhmSubstage;

/* protected: */
static QState IhmSubstage_initial(IhmSubstage * const me, void const * const par);
static QState IhmSubstage_idle(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_state1(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_q1(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_f(IhmSubstage * const me, QEvt const * const e);
static QState IhmSubstage_q2(IhmSubstage * const me, QEvt const * const e);
/*$enddecl${Components::IhmSubstage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$declare${AOs::Ihm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm} ..............................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt stageTimerEvt;
    IhmStage stage;
    IhmSubstage substage;
    RoastsPageData roasts_page;
    RoastPageData roast_page;

/* private state histories */
    QStateHandler hist_auto_page;
} Ihm;

/* private: */
static void Ihm_resetData(Ihm * const me);
static void Ihm_resetState(Ihm * const me);
static void Ihm_resetRoastsPageData(Ihm * const me);
static void Ihm_resetRoastPageData(Ihm * const me);
static void Ihm_resetChart(Ihm * const me);
static void Ihm_setupPageMainMenu(void);
static void Ihm_setupPageSummary(void);
static void Ihm_requestExitMode(void);
static void Ihm_setupPageRoasts(Ihm * const me,
    bool recipes);
static void Ihm_setupPageRoast(Ihm * const me,
    bool recipe);
static void Ihm_postTemperatures(
    unsigned short int vp,
    SensorType sensor,
    int * values,
    int count,
    int minX,
    int maxX,
    int minY,
    int maxY,
    bool deltaBound,
    int deltaBoundX,
    int maxTemp,
    int minTemp,
    int originY,
    bool isDelta);
static void Ihm_setupPageControls(void);
static void Ihm_requestPageControls(
    int max_pre_heat,
    int max_roast);
static void Ihm_hidratePageControls(Ihm * const me,
    uint16_t sensor_grao,
    uint16_t sensor_ar,
    uint16_t potencia,
    uint16_t cilindro,
    uint16_t turbina,
    uint16_t resfriador);
static void Ihm_setupPageConfig(void);
static void Ihm_requestPageConfig(
    int max_pre_heat,
    int max_roast);
static void Ihm_hidratePageConfig(Ihm * const me,
    uint16_t max_pre_heat,
    uint16_t max_roast);
static void Ihm_updateComponentControl(
    ControlType type,
    uint16_t value);
static void Ihm_setupPageSensoring(void);
static void Ihm_requestPageSensoring(void);
static void Ihm_hidratePageSensoring(void);
static void Ihm_updateComponentSensor(
    SensorType type,
    uint16_t value,
    uint16_t delta);

/* protected: */
static QState Ihm_initial(Ihm * const me, void const * const par);
static QState Ihm_main_menu(Ihm * const me, QEvt const * const e);
static QState Ihm_sensoring(Ihm * const me, QEvt const * const e);
static QState Ihm_manual_events(Ihm * const me, QEvt const * const e);
static QState Ihm_sensoring_page(Ihm * const me, QEvt const * const e);
static QState Ihm_idle(Ihm * const me, QEvt const * const e);
static QState Ihm_active(Ihm * const me, QEvt const * const e);
static QState Ihm_pre_heating(Ihm * const me, QEvt const * const e);
static QState Ihm_chart(Ihm * const me, QEvt const * const e);
static QState Ihm_roasting(Ihm * const me, QEvt const * const e);
static QState Ihm_cooling(Ihm * const me, QEvt const * const e);
static QState Ihm_controls_page(Ihm * const me, QEvt const * const e);
static QState Ihm_warn_new(Ihm * const me, QEvt const * const e);
static QState Ihm_summary_page(Ihm * const me, QEvt const * const e);
static QState Ihm_config_page(Ihm * const me, QEvt const * const e);
static QState Ihm_recipes(Ihm * const me, QEvt const * const e);
static QState Ihm_roasts(Ihm * const me, QEvt const * const e);
static QState Ihm_config(Ihm * const me, QEvt const * const e);
static QState Ihm_recipe(Ihm * const me, QEvt const * const e);
static QState Ihm_roast(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_mode(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_summary(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_events(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_controls(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_page(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_active(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_pre_heating(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_chart(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_cooling(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_roasting(Ihm * const me, QEvt const * const e);
static QState Ihm_auto_config(Ihm * const me, QEvt const * const e);
/*$enddecl${AOs::Ihm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


static Ihm l_ihm; /* a única instância do AO IHM */
static IhmStage l_ihmStage; /* a única instância do AO IHM */
static IhmSubstage l_ihmSubstage; /* a única instância do AO IHM */

#define STAGE_TIMER_INTERVAL  \
    (QTimeEvtCtr)((1 * CONFIG_FREERTOS_HZ))

QActive * const AO_Ihm = &l_ihm.super;

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${Components::IhmStage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmStage} ..................................................*/

/*${Components::IhmStage::setTimer} ........................................*/
static void IhmStage_setTimer(IhmStage * const me,
    bool reset,
    bool visible)
{
    time_t rawtime;
    struct tm *info;
    char buffer[8];

    time( &rawtime );

    if(reset) {

    }

    if(visible) {
        time_t elapsed = rawtime-me->timer_start;

        info = localtime( &elapsed );
        strftime(buffer,80,"%H:%M:%S", info);

        postUart_setString(STAGE_TIMER_TEXT_VP, buffer, false, STAGE_TIMER_TEXT_LEN);
    } else {
        postUart_setString(STAGE_TIMER_TEXT_VP, "\0", true, STAGE_TIMER_TEXT_LEN);
    }


}

/*${Components::IhmStage::SM} ..............................................*/
static QState IhmStage_initial(IhmStage * const me, void const * const par) {
    /*${Components::IhmStage::SM::initial} */
    return Q_TRAN(&IhmStage_idle);
}

/*${Components::IhmStage::SM::state1} ......................................*/
static QState IhmStage_state1(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::state1::NOTIFY_STAGE} */
        case NOTIFY_STAGE_SIG: {
            NotifyStageEvt *stageEv = Q_EVT_CAST(NotifyStageEvt);

            StageType stage = stageEv->stage;
            time_t stage_start = stageEv->stage_start;
            /*${Components::IhmStage::SM::state1::NOTIFY_STAGE::[stage==SENSORING]} */
            if (stage == SENSORING) {
                status_ = Q_TRAN(&IhmStage_idle);
            }
            /*${Components::IhmStage::SM::state1::NOTIFY_STAGE::[stage==PRE_HEAT]} */
            else if (stage == PRE_HEAT) {
                status_ = Q_TRAN(&IhmStage_pre_heating);
            }
            /*${Components::IhmStage::SM::state1::NOTIFY_STAGE::[stage==ROAST]} */
            else if (stage == ROAST) {
                me->timer_start = stage_start;
                status_ = Q_TRAN(&IhmStage_roasting);
            }
            /*${Components::IhmStage::SM::state1::NOTIFY_STAGE::[stage==COOL]} */
            else if (stage == COOL) {
                me->timer_start = stage_start;
                status_ = Q_TRAN(&IhmStage_cooling);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::state1::idle} ................................*/
static QState IhmStage_idle(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::state1::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][IDLE][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 0);
            postUart_setIcon(STAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::state1::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_state1);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::state1::pre_heating} .........................*/
static QState IhmStage_pre_heating(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::state1::pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][PRE_HEATING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 1);
            postUart_setIcon(STAGE_BTN_ICON_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::state1::pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_state1);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::state1::timing} ..............................*/
static QState IhmStage_timing(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::state1::timing} */
        case Q_EXIT_SIG: {
            IhmStage_setTimer(me, true, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::state1::timing::IHM_STAGE_TIMER_TIMEOUT} */
        case IHM_STAGE_TIMER_TIMEOUT_SIG: {
            IhmStage_setTimer(me, false, true);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_state1);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::state1::timing::roasting} ....................*/
static QState IhmStage_roasting(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::state1::timing::roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][ROASTING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 2);
            postUart_setIcon(STAGE_BTN_ICON_VP, 2);

            IhmStage_setTimer(me, true, true);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::state1::timing::roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][ROASTING][EXIT]");

            IhmStage_setTimer(me, true, false);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_timing);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::state1::timing::cooling} .....................*/
static QState IhmStage_cooling(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::state1::timing::cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][COOLING][ENTRY]");

            postUart_setIcon(STAGE_STATUS_ICON_VP, 3);
            postUart_setIcon(STAGE_BTN_ICON_VP, 3);

            IhmStage_setTimer(me, true, true);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::state1::timing::cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][COOLING][EXIT]");

            IhmStage_setTimer(me, true, false);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_timing);
            break;
        }
    }
    return status_;
}

/*${Components::IhmStage::SM::state1::summary} .............................*/
static QState IhmStage_summary(IhmStage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmStage::SM::state1::summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[STAGE][SUMMARy][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmStage::SM::state1::summary} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[STAGE][SUMMARy][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmStage_state1);
            break;
        }
    }
    return status_;
}
/*$enddef${Components::IhmStage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${Components::IhmSubstage} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Components::IhmSubstage} ...............................................*/

/*${Components::IhmSubstage::SM} ...........................................*/
static QState IhmSubstage_initial(IhmSubstage * const me, void const * const par) {
    /*${Components::IhmSubstage::SM::initial} */
    return Q_TRAN(&IhmSubstage_idle);
}

/*${Components::IhmSubstage::SM::idle} .....................................*/
static QState IhmSubstage_idle(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][IDLE][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::idle::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_state1);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::state1} ...................................*/
static QState IhmSubstage_state1(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::state1::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&IhmSubstage_f);
            break;
        }
        /*${Components::IhmSubstage::SM::state1::NOTIFY_SUBSTAGE_EXIT} */
        case NOTIFY_SUBSTAGE_EXIT_SIG: {
            status_ = Q_TRAN(&IhmSubstage_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::state1::q1} ...............................*/
static QState IhmSubstage_q1(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::state1::q1} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][Q1][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 2);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::q1} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::q1::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_q2);
            break;
        }
        /*${Components::IhmSubstage::SM::state1::q1::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${Components::IhmSubstage::SM::state1::q1::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            if (ihmEv->length == 5) {
                RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
                stageEv->substage = Q2;
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmSubstage_state1);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::state1::f} ................................*/
static QState IhmSubstage_f(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::state1::f} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][F][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::f} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][F][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::f::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            status_ = Q_TRAN(&IhmSubstage_q1);
            break;
        }
        /*${Components::IhmSubstage::SM::state1::f::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${Components::IhmSubstage::SM::state1::f::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            if (ihmEv->length == 5) {
                RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
                stageEv->substage = Q1;
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmSubstage_state1);
            break;
        }
    }
    return status_;
}

/*${Components::IhmSubstage::SM::state1::q2} ...............................*/
static QState IhmSubstage_q2(IhmSubstage * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${Components::IhmSubstage::SM::state1::q2} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][Q2][ENTRY]");

            postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${Components::IhmSubstage::SM::state1::q2} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUBSTAGE][COOLING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&IhmSubstage_state1);
            break;
        }
    }
    return status_;
}
/*$enddef${Components::IhmSubstage} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${AOs::Ihm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm} ..............................................................*/

/*${AOs::Ihm::resetData} ...................................................*/
static void Ihm_resetData(Ihm * const me) {
    Ihm_resetState(me);
    Ihm_resetRoastsPageData(me);
    Ihm_resetRoastPageData(me);
}

/*${AOs::Ihm::resetState} ..................................................*/
static void Ihm_resetState(Ihm * const me) {
    me->state.control = (ControlState){
        .potencia = 0,
        .cilindro = 0,
        .turbina = TOGGLE_OFF,
        .resfriador = TOGGLE_OFF
    };

    /*
    strcpy(me->next_command.command, "");
    me->next_command.time = 0;
    */
}

/*${AOs::Ihm::resetRoastsPageData} .........................................*/
static void Ihm_resetRoastsPageData(Ihm * const me) {
    me->roasts_page = (RoastsPageData){
        .page = 0,
        .roast1 = "",
        .roast2 = "",
        .roast3 = "",
    };
}

/*${AOs::Ihm::resetRoastPageData} ..........................................*/
static void Ihm_resetRoastPageData(Ihm * const me) {
    me->roast_page = (RoastPageData){
        .roast = ""
    };
}

/*${AOs::Ihm::resetChart} ..................................................*/
static void Ihm_resetChart(Ihm * const me) {
    UartOutputChartEvt *chartEv = Q_NEW(UartOutputChartEvt, UART_OUTPUT_CHART_SIG);
    chartEv->vp = VP_CHART_LINE_GRAO;
    chartEv->sensor = SENSOR_GRAO;
    chartEv->values = 0;
    chartEv->count = 0;
    chartEv->minX = 0;
    chartEv->maxX = 0;
    chartEv->minY = 0;
    chartEv->maxY = 0;
    chartEv->deltaBound = true;
    chartEv->deltaBoundX = 0;
    chartEv->maxTemp = 0;
    chartEv->minTemp = 0;
    chartEv->originY = 0;
    chartEv->isDelta = true;
    QACTIVE_POST(AO_Uart, &chartEv->super, me);

    UartOutputChartEvt *chartEv2 = Q_NEW(UartOutputChartEvt, UART_OUTPUT_CHART_SIG);
    chartEv->vp = VP_CHART_LINE_AR;
    chartEv->sensor = SENSOR_AR;
    chartEv->values = 0;
    chartEv->count = 0;
    chartEv->minX = 0;
    chartEv->maxX = 0;
    chartEv->minY = 0;
    chartEv->maxY = 0;
    chartEv->deltaBound = true;
    chartEv->deltaBoundX = 0;
    chartEv->maxTemp = 0;
    chartEv->minTemp = 0;
    chartEv->originY = 0;
    chartEv->isDelta = true;
    QACTIVE_POST(AO_Uart, &chartEv2->super, me);
}

/*${AOs::Ihm::setupPageMainMenu} ...........................................*/
static void Ihm_setupPageMainMenu(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MAIN_MENU]");

    postUart_setPage(MAIN_MENU_PICID);

    postUart_setString(NAVBAR_TEXT_VP, "HOME", true, NAVBAR_TEXT_LEN);
    postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
}

/*${AOs::Ihm::setupPageSummary} ............................................*/
static void Ihm_setupPageSummary(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MANUAL_MODE]");

    postUart_setPage(SUMMARY_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "RESUMO", true, NAVBAR_TEXT_LEN);

    postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 0);
}

/*${AOs::Ihm::requestExitMode} .............................................*/
static void Ihm_requestExitMode(void) {
    RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
    ram->mode = MODE_NONE;
    strcpy(ram->roast, "");

    QACTIVE_POST(AO_DataBroker, &ram->super, me);
}

/*${AOs::Ihm::setupPageRoasts} .............................................*/
static void Ihm_setupPageRoasts(Ihm * const me,
    bool recipes)
{
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_ROASTS]");

    postUart_setPage(ROASTS_PICID);


    postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);

    if(me->roasts_page.prev)
        postUart_setIcon(ROASTS_ICON_LEFT_VP, 1);
    else
        postUart_setIcon(ROASTS_ICON_LEFT_VP, 0);

    if(me->roasts_page.next)
        postUart_setIcon(ROASTS_ICON_RIGHT_VP, 2);
    else
        postUart_setIcon(ROASTS_ICON_RIGHT_VP, 0);

    ESP_LOGE(TAG, "%s-%s-%s", me->roasts_page.roast1, me->roasts_page.roast2,me->roasts_page.roast3);

    if(strcmp(me->roasts_page.roast1, "") == 0) {
        postUart_setIcon(ROASTS_ICON_ROAST1_VP, 0);
        postUart_setString(ROASTS_TEXT_ROAST1_VP, "", true, ROASTS_TEXT_ROAST1_LEN);
    } else {
        postUart_setIcon(ROASTS_ICON_ROAST1_VP, 1);
        postUart_setString(ROASTS_TEXT_ROAST1_VP, me->roasts_page.roast1, true, ROASTS_TEXT_ROAST1_LEN);
    }

    if(strcmp(me->roasts_page.roast2, "") == 0) {
        postUart_setIcon(ROASTS_ICON_ROAST2_VP, 0);
        postUart_setString(ROASTS_TEXT_ROAST2_VP, "", true, ROASTS_TEXT_ROAST2_LEN);
    } else {
        postUart_setIcon(ROASTS_ICON_ROAST2_VP, 1);
        postUart_setString(ROASTS_TEXT_ROAST2_VP, me->roasts_page.roast2, true, ROASTS_TEXT_ROAST2_LEN);
    }

    if(strcmp(me->roasts_page.roast3, "") == 0) {
        postUart_setIcon(ROASTS_ICON_ROAST3_VP, 0);
        postUart_setString(ROASTS_TEXT_ROAST3_VP, "", true, ROASTS_TEXT_ROAST3_LEN);
    } else {
        postUart_setIcon(ROASTS_ICON_ROAST3_VP, 1);
        postUart_setString(ROASTS_TEXT_ROAST3_VP, me->roasts_page.roast3, true, ROASTS_TEXT_ROAST3_LEN);
    }

    if(recipes) {
        postUart_setString(NAVBAR_TEXT_VP, "RECEITAS", true, NAVBAR_TEXT_LEN);
    } else {
        postUart_setString(NAVBAR_TEXT_VP, "TORRAS", true, NAVBAR_TEXT_LEN);
    }
}

/*${AOs::Ihm::setupPageRoast} ..............................................*/
static void Ihm_setupPageRoast(Ihm * const me,
    bool recipe)
{
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_ROAST]");

    postUart_setPage(ROAST_PICID);

    postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);

    if(recipe) {
        postUart_setString(NAVBAR_TEXT_VP, "RECEITA", true, NAVBAR_TEXT_LEN);
        postUart_setIcon(ROAST_BTN_ICON_VP, 1);
    } else {
        postUart_setString(NAVBAR_TEXT_VP, "TORRA", true, NAVBAR_TEXT_LEN);
        postUart_setIcon(ROAST_BTN_ICON_VP, 0);
    }
}

/*${AOs::Ihm::postTemperatures} ............................................*/
static void Ihm_postTemperatures(
    unsigned short int vp,
    SensorType sensor,
    int * values,
    int count,
    int minX,
    int maxX,
    int minY,
    int maxY,
    bool deltaBound,
    int deltaBoundX,
    int maxTemp,
    int minTemp,
    int originY,
    bool isDelta)
{
    UartOutputChartEvt *chartEv = Q_NEW(UartOutputChartEvt, UART_OUTPUT_CHART_SIG);
    chartEv->vp = vp;
    chartEv->sensor = sensor;
    chartEv->values = values;
    chartEv->count = count;
    chartEv->minX = minX;
    chartEv->maxX = maxX;
    chartEv->minY = minY;
    chartEv->maxY = maxY;
    chartEv->deltaBound = deltaBound;
    chartEv->deltaBoundX = deltaBoundX;
    chartEv->maxTemp = maxTemp;
    chartEv->minTemp = minTemp;
    chartEv->originY = originY;
    chartEv->isDelta = isDelta;
    /*
    if(isDelta) {
        printf("\nDeltas:[");
        for(int i=0;i<count;i++) {
            printf("%d, ", values[i]);
        }
        printf("]\n");
    } else {
        printf("\nTemperaturas:[");
        for(int i=0;i<count;i++) {
            printf("%d, ", values[i]);
        }
        printf("]\n");
    }
    */
    QACTIVE_POST(AO_Uart, &chartEv->super, me);
}

/*${AOs::Ihm::setupPageControls} ...........................................*/
static void Ihm_setupPageControls(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_CONTROLS]");

    postUart_setPage(CONTROLS_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "CONTROLES", true, NAVBAR_TEXT_LEN);

    postUart_setString(SENSOR_AR_TEXT_VP, "0\0", true, SENSOR_AR_TEXT_LEN);
    postUart_setString(DELTA_AR_TEXT_VP, "0\0", true, DELTA_AR_TEXT_LEN);

    postUart_setString(SENSOR_GRAO_TEXT_VP, "0\0", true, SENSOR_GRAO_TEXT_LEN);
    postUart_setString(DELTA_GRAO_TEXT_VP, "0\0", true, DELTA_GRAO_TEXT_LEN);

    Ihm_updateComponentControl(POTENCIA, 0);
    Ihm_updateComponentControl(CILINDRO, 0);
    Ihm_updateComponentControl(TURBINA, 0);
    Ihm_updateComponentControl(RESFRIADOR, 0);
}

/*${AOs::Ihm::requestPageControls} .........................................*/
static void Ihm_requestPageControls(
    int max_pre_heat,
    int max_roast)
{
    ESP_LOGV(TAG, "[IHM_REQUEST_PAGE_CONTROLS]");

    postData_requestData(
        DATA_PAGE,
        (Data){
            .page_data.type = PAGE_CONTROLS
        )
    );
}

/*${AOs::Ihm::hidratePageControls} .........................................*/
static void Ihm_hidratePageControls(Ihm * const me,
    uint16_t sensor_grao,
    uint16_t sensor_ar,
    uint16_t potencia,
    uint16_t cilindro,
    uint16_t turbina,
    uint16_t resfriador)
{
    ESP_LOGV(TAG, "[HIDRATE_PAGE_CONTROLS]");

    postUart_setNumberAsString(SENSOR_GRAO_TEXT_VP, sensor_grao, " C", true, SENSOR_GRAO_TEXT_LEN);
    postUart_setNumberAsString(SENSOR_AR_TEXT_VP, sensor_ar, " C", true, SENSOR_AR_TEXT_LEN);

    Ihm_updateComponentControl(POTENCIA, potencia);
    Ihm_updateComponentControl(CILINDRO, cilindro);
    Ihm_updateComponentControl(TURBINA, turbina);
    Ihm_updateComponentControl(RESFRIADOR, resfriador);
}

/*${AOs::Ihm::setupPageConfig} .............................................*/
static void Ihm_setupPageConfig(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_CONFIG]");

    postUart_setPage(CONFIG_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "CONFIGURACOES", true, NAVBAR_TEXT_LEN);
    postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
    postUart_setIcon(NAVBAR_ICON_GEAR_VP, 0);

    postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, 0);
    postUart_setNumber(CONFIG_ROAST_NUMBER_VP, 0);
}

/*${AOs::Ihm::requestPageConfig} ...........................................*/
static void Ihm_requestPageConfig(
    int max_pre_heat,
    int max_roast)
{
    ESP_LOGV(TAG, "[IHM_REQUEST_PAGE_CONFIG]");

    postData_requestData(
        DATA_PAGE,
        (Data){
            .page_data.type = PAGE_CONFIG
        )
    );
}

/*${AOs::Ihm::hidratePageConfig} ...........................................*/
static void Ihm_hidratePageConfig(Ihm * const me,
    uint16_t max_pre_heat,
    uint16_t max_roast)
{
    ESP_LOGD(TAG, "[IHM_HIDRATE_PAGE_CONFIG]");

    postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, max_pre_heat);
    postUart_setNumber(CONFIG_ROAST_NUMBER_VP, max_roast);
}

/*${AOs::Ihm::updateComponentControl} ......................................*/
static void Ihm_updateComponentControl(
    ControlType type,
    uint16_t value)
{
    ESP_LOGD(TAG, "[UPDATE_COMPONENT_CONTROL]");

    uint16_t new_value = ceil(value / 5) * 5;
    uint8_t icon = ceil(new_value / 5);

    char str[10];
    memset(str, "\0", sizeof(str));
    itoa(new_value, str, 10);

    switch(type) {
        case POTENCIA:
            postUart_setString(CONTROL_POTENCIA_TEXT_VP, str, true, CONTROL_POTENCIA_TEXT_LEN);
            postUart_setIcon(CONTROL_POTENCIA_ICON_VP, icon);
        break;

        case CILINDRO:
            postUart_setString(CONTROL_CILINDRO_TEXT_VP, str, true, CONTROL_CILINDRO_TEXT_LEN);
            postUart_setIcon(CONTROL_CILINDRO_ICON_VP, icon);
        break;

        case TURBINA:
            icon = 0;
            if(value == 0) {
                icon = 0;
            } else if(value == 70) {
                icon = 1;
            } else if(value == 80) {
                icon = 2;
            } else if(value == 90) {
                icon = 3;
            } else if(value == 100) {
                icon = 4;
            } else {
                ESP_LOGE(TAG, "Turbina recebendo valor outro além dos possiveis: %d", value);
            }

            postUart_setIcon(CONTROL_TURBINA_ICON_VP, icon);
        break;

        case RESFRIADOR:
            icon = 0;
            if(value == 0) {
                icon = 0;
            } else if(value == 100) {
                icon = 4;
            } else {
                ESP_LOGE(TAG, "Resfriador recebendo valor outro além dos possiveis: %d", value);
            }

            postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, icon);
        break;
    }
}

/*${AOs::Ihm::setupPageSensoring} ..........................................*/
static void Ihm_setupPageSensoring(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_SENSORING]");

    postUart_setPage(SENSORING_PICID);
    postUart_setString(NAVBAR_TEXT_VP, "CARREGANDO...", true, NAVBAR_TEXT_LEN);

    postUart_setString(SENSOR_AR_TEXT_VP, "0\0", true, SENSOR_AR_TEXT_LEN);
    postUart_setString(DELTA_AR_TEXT_VP, "0\0", true, DELTA_AR_TEXT_LEN);

    postUart_setString(SENSOR_GRAO_TEXT_VP, "0\0", true, SENSOR_GRAO_TEXT_LEN);
    postUart_setString(DELTA_GRAO_TEXT_VP, "0\0", true, DELTA_GRAO_TEXT_LEN);
}

/*${AOs::Ihm::requestPageSensoring} ........................................*/
static void Ihm_requestPageSensoring(void) {
    ESP_LOGV(TAG, "[IHM_REQUEST_PAGE_CONFIG]");

    postData_requestData(
        DATA_PAGE,
        (Data){
            .page_data.type = PAGE_SENSORING
        )
    );
}

/*${AOs::Ihm::hidratePageSensoring} ........................................*/
static void Ihm_hidratePageSensoring(void) {
    ESP_LOGD(TAG, "[IHM_SETUP_PAGE_MANUAL_CONTROLS]");

    postUart_setPage(CONTROLS_PICID);

    postUart_setIcon(NEXT_COMMAND_ICON_VP, 0);
    postUart_setString(NEXT_COMMAND_TEXT_VP, "\0", true, NEXT_COMMAND_TEXT_LEN);
    postUart_setString(NEXT_COMMAND_TIMER_TEXT_VP, "\0", true, NEXT_COMMAND_TIMER_TEXT_LEN);

    postUart_setIcon(CONTROL_POTENCIA_ICON_VP, 0);
    postUart_setString(CONTROL_POTENCIA_TEXT_VP, "\0", true, CONTROL_POTENCIA_TEXT_LEN);

    postUart_setIcon(CONTROL_CILINDRO_ICON_VP, 0);
    postUart_setString(CONTROL_CILINDRO_TEXT_VP, "\0", true, CONTROL_CILINDRO_TEXT_LEN);

    postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, 0);
    postUart_setIcon(CONTROL_TURBINA_ICON_VP, 0);
}

/*${AOs::Ihm::updateComponentSensor} .......................................*/
static void Ihm_updateComponentSensor(
    SensorType type,
    uint16_t value,
    uint16_t delta)
{
    ESP_LOGD(TAG, "[UPDATE_COMPONENT_SENSOR]");

    char str[6];
    char delta_str[6];

    memset(str, "\0", sizeof(str));
    memset(delta_str, "\0", sizeof(delta_str));

    sprintf(str, "%d C", value);
    sprintf(delta_str, "%d", delta);

    switch(type) {
        case SENSOR_GRAO:
            postUart_setString(SENSOR_GRAO_TEXT_VP, str, true, SENSOR_GRAO_TEXT_LEN);
            postUart_setString(DELTA_GRAO_TEXT_VP, delta_str, true, DELTA_GRAO_TEXT_LEN);
        break;

        case SENSOR_AR:
            postUart_setString(SENSOR_AR_TEXT_VP, str, true, SENSOR_AR_TEXT_LEN);
            postUart_setString(DELTA_AR_TEXT_VP, delta_str, true, DELTA_AR_TEXT_LEN);
        break;

        case SENSOR_GAS:
            postUart_setString(SENSOR_GAS_TEXT_VP, str, true, SENSOR_GAS_TEXT_LEN);
        break;
    }


}

/*${AOs::Ihm::SM} ..........................................................*/
static QState Ihm_initial(Ihm * const me, void const * const par) {
    /*${AOs::Ihm::SM::initial} */
    /* (!) trigger the initial transition in the component */
    QHSM_INIT((QHsm *)&me->stage, (void *)0, me->super.prio);

    /* (!) trigger the initial transition in the component */
    QHSM_INIT((QHsm *)&me->substage, (void *)0, me->super.prio);
    /* state history attributes */
    me->hist_auto_page = Q_STATE_CAST(&Ihm_auto_active);
    return Q_TRAN(&Ihm_main_menu);
}

/*${AOs::Ihm::SM::main_menu} ...............................................*/
static QState Ihm_main_menu(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::main_menu} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MAIN_MENU][ENTRY]");

            Ihm_setupPageMainMenu();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::main_menu} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MAIN_MENU][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[MANUAL_MODE]} */
            if (ihmEv->length == 3) {
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            else if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_recipes);
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            else if (ihmEv->length == 5) {
                status_ = Q_TRAN(&Ihm_roasts);
            }
            /*${AOs::Ihm::SM::main_menu::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            else if (ihmEv->length == 2) {
                status_ = Q_TRAN(&Ihm_config);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::main_menu::NOTIFY_MODE} */
        case NOTIFY_MODE_SIG: {
            NotifyModeEvt *nme = Q_EVT_CAST(NotifyModeEvt);
            /*${AOs::Ihm::SM::main_menu::NOTIFY_MODE::[nme->mode==MODE_MANUAL||nme->mo~} */
            if (nme->mode == MODE_MANUAL || nme->mode == MODE_AUTO) {
                status_ = Q_TRAN(&Ihm_sensoring_page);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring} ...............................................*/
static QState Ihm_sensoring(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SENSORING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::NOTIFY_MODE} */
        case NOTIFY_MODE_SIG: {
            NotifyModeEvt *nme = Q_EVT_CAST(NotifyModeEvt);
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            /*${AOs::Ihm::SM::sensoring::NOTIFY_MODE::[nme->mode==MODE_NONE]} */
            if (nme->mode == MODE_NONE) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events} ................................*/
static QState Ihm_manual_events(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

            ControlType control = contEv->control;
            int value = contEv->value;

            if(contEv->control == POTENCIA) {
                me->state.control.potencia = value;
            } else if(contEv->control == CILINDRO) {
                me->state.control.cilindro = value;
            } else if(contEv->control == TURBINA) {
                if(value == 0)
                    me->state.control.turbina = TOGGLE_OFF;
                else if(value == 70)
                    me->state.control.turbina = TOGGLE_SEVENTY;
                else if(value == 80)
                    me->state.control.turbina = TOGGLE_EIGHTY;
                else if(value == 90)
                    me->state.control.turbina = TOGGLE_NINETY;
                else if(value == 100)
                    me->state.control.turbina = TOGGLE_MAX;
            } else if(contEv->control == RESFRIADOR) {
                if(value == 0)
                    me->state.control.resfriador = TOGGLE_OFF;
                else
                    me->state.control.resfriador = TOGGLE_MAX;
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::SENSOR_DATA} */
        case SENSOR_DATA_SIG: {
            SensorDataEvt *sensorEv = Q_EVT_CAST(SensorDataEvt);

            SensorType type = sensorEv->type;
            int value = sensorEv->value;
            int delta = sensorEv->delta;

            if(type == SENSOR_GRAO) {
                char graoStr[6] = {0};
                sprintf(graoStr, "%d C", value);
                postUart_setString(SENSOR_GRAO_TEXT_VP, graoStr, true, SENSOR_GRAO_TEXT_LEN);

                char graoDeltaStr[6] = {0};
                sprintf(graoDeltaStr, "%d", delta);
                postUart_setString(DELTA_GRAO_TEXT_VP, graoDeltaStr, true, DELTA_GRAO_TEXT_LEN);
            } else if(sensorEv->type == SENSOR_AR) {
                char arStr[6] = {0};
                sprintf(arStr, "%d C", value);
                postUart_setString(SENSOR_AR_TEXT_VP, arStr, true, SENSOR_AR_TEXT_LEN);

                char arDeltaStr[6] = {0};
                sprintf(arDeltaStr, "%d", delta);
                postUart_setString(DELTA_AR_TEXT_VP, arDeltaStr, true, DELTA_AR_TEXT_LEN);
            } else if(sensorEv->type == SENSOR_GAS) {
                char gasStr[6] = {0};
                sprintf(gasStr, "%d", value);
                postUart_setString(SENSOR_GAS_TEXT_VP, gasStr, true, SENSOR_GAS_TEXT_LEN);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_sensoring);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page} ................*/
static QState Ihm_sensoring_page(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page} */
        case Q_ENTRY_SIG: {
            ESP_LOGV(TAG, "[MANUAL_MODE][CONTROLS}[ENTRY]");

            Ihm_setupPageSensoring();
            Ihm_requestPageSensoring();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->stageTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::CHART_DATA} */
        case CHART_DATA_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_controls_page);
            }
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            else if (ihmEv->length == 2) {
                status_ = Q_TRAN(&Ihm_config_page);
            }
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::DATA_RESPONSE} */
        case DATA_RESPONSE_SIG: {
            DataResponseEvt *resEv = Q_EVT_CAST(DataResponseEvt);

            DataType type = resEv->type;
            Data data = resEv->data;
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::DATA_RESPONSE::[type==DATA_PAGE&&data.page_data~} */
            if (type == DATA_PAGE && data.page_data.page == PAGE_SENSORING && data.page_data.data.stage == SENSORING) {
                SensoringPageData page_data = data.page_data.data;
                StageType stage = page_data->stage;
                SensorData sensor_data = page_data->sensor_data;
                time_t stage_start = page_data->stage_start;

                Ihm_updateComponentSensor(SENSOR_GRAO, sensor_data.grao.temp, sensor_data.grao.delta);
                Ihm_updateComponentSensor(SENSOR_AR, sensor_data.ar.temp, sensor_data.ar.delta);

                NotifyStageEvt *stageEv = Q_NEW(NotifyStageEvt, NOTIFY_STAGE_SIG);
                stageEv->stage = SENSORING;
                stageEv->stage_start = 0;
                QHSM_DISPATCH((QHsm *)&me->stage, stageEv, me->super.prio);
                status_ = Q_TRAN(&Ihm_idle);
            }
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::DATA_RESPONSE::[type==DATA_PAGE&&data.page_data~} */
            else if (type == DATA_PAGE && data.page_data.page == PAGE_SENSORING && data.page_data.data.stage == PRE_HEAT) {
                SensoringPageData page_data = data.page_data.data;
                StageType stage = page_data->stage;
                SensorData sensor_data = page_data->sensor_data;
                time_t stage_start = page_data->stage_start;

                Ihm_updateComponentSensor(SENSOR_GRAO, sensor_data.grao.temp, sensor_data.grao.delta);
                Ihm_updateComponentSensor(SENSOR_AR, sensor_data.ar.temp, sensor_data.ar.delta);

                NotifyStageEvt *stageEv = Q_NEW(NotifyStageEvt, NOTIFY_STAGE_SIG);
                stageEv->stage = PRE_HEAT;
                stageEv->stage_start = 0;
                QHSM_DISPATCH((QHsm *)&me->stage, stageEv, me->super.prio);
                status_ = Q_TRAN(&Ihm_pre_heating);
            }
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::DATA_RESPONSE::[type==DATA_PAGE&&data.page_data~} */
            else if (type == DATA_PAGE && data.page_data.page == PAGE_SENSORING && data.page_data.data.stage == ROAST) {
                SensoringPageData page_data = data.page_data.data;
                StageType stage = page_data->stage;
                SensorData sensor_data = page_data->sensor_data;
                time_t stage_start = page_data->stage_start;

                Ihm_updateComponentSensor(SENSOR_GRAO, sensor_data.grao.temp, sensor_data.grao.delta);
                Ihm_updateComponentSensor(SENSOR_AR, sensor_data.ar.temp, sensor_data.ar.delta);

                NotifyStageEvt *stageEv = Q_NEW(NotifyStageEvt, NOTIFY_STAGE_SIG);
                stageEv->stage = ROAST;
                stageEv->stage_start = stage_start;
                QHSM_DISPATCH((QHsm *)&me->stage, stageEv, me->super.prio);
                status_ = Q_TRAN(&Ihm_roasting);
            }
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::DATA_RESPONSE::[type==DATA_PAGE&&data.page_data~} */
            else if (type == DATA_PAGE && data.page_data.page == PAGE_SENSORING && data.page_data.data.stage == COOL) {
                SensoringPageData page_data = data.page_data.data;
                StageType stage = page_data->stage;
                SensorData sensor_data = page_data->sensor_data;
                time_t stage_start = page_data->stage_start;

                Ihm_updateComponentSensor(SENSOR_GRAO, sensor_data.grao.temp, sensor_data.grao.delta);
                Ihm_updateComponentSensor(SENSOR_AR, sensor_data.ar.temp, sensor_data.ar.delta);

                NotifyStageEvt *stageEv = Q_NEW(NotifyStageEvt, NOTIFY_STAGE_SIG);
                stageEv->stage = COOL;
                stageEv->stage_start = stage_start;
                QHSM_DISPATCH((QHsm *)&me->stage, stageEv, me->super.prio);
                status_ = Q_TRAN(&Ihm_cooling);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_events);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::idle} ..........*/
static QState Ihm_idle(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][IDLE][ENTRY]");

            postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
            postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::idle::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::idle::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_warn_new);
            }
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::idle::IHM_INPUT_TOUCH::[ihmEv->length==1]} */
            else if (ihmEv->length == 1) {
                RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
                ram->mode = MODE_NONE;
                strcpy(ram->roast, "");
                QACTIVE_POST(AO_DataBroker, &ram->super, me);
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_sensoring_page);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active} ........*/
static QState Ihm_active(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][ENTRY]");

            postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
            postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_sensoring_page);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::pre_heating}*/
static QState Ihm_pre_heating(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][PRE_HEATING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::pre_heating::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_roasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart}*/
static QState Ihm_chart(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ENTRY]");

            QTimeEvt_armX(&me->stageTimerEvt, STAGE_TIMER_INTERVAL, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][EXIT]");

            QTimeEvt_disarm(&me->stageTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::IHM_STAGE_TIMER_TIMEOUT} */
        case IHM_STAGE_TIMER_TIMEOUT_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);

            QTimeEvt_rearm(&me->stageTimerEvt, STAGE_TIMER_INTERVAL);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::roasting}*/
static QState Ihm_roasting(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][ENTRY]");

            RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
            stageEv->substage = F;
            QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][EXIT]");

            NotifySubstageExitEvt *stageEv = Q_NEW(NotifySubstageExitEvt, NOTIFY_SUBSTAGE_EXIT_SIG);
            QHSM_DISPATCH((QHsm *)&me->substage, stageEv, me->super.prio);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::roasting::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_cooling);
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::roasting::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::roasting::IHM_INPUT_TOUCH::[SUBSTAGE]} */
            if (ihmEv->length == 5) {
                QHSM_DISPATCH((QHsm *)&me->substage, e, me->super.prio);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::roasting::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            NotifyNextSubstageEvt *subEv = Q_EVT_CAST(NotifyNextSubstageEvt);

            QHSM_DISPATCH((QHsm *)&me->substage, subEv, me->super.prio);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_chart);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::cooling}*/
static QState Ihm_cooling(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][COOLING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::sensoring_page::active::chart::cooling::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_summary_page);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_chart);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::manual_events::controls_page} .................*/
static QState Ihm_controls_page(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::manual_events::controls_page} */
        case Q_ENTRY_SIG: {
            ESP_LOGV(TAG, "[MANUAL_MODE][CONTROLS}[ENTRY]");

            Ihm_setupPageControls();
            Ihm_requestPageControls();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::controls_page} */
        case Q_EXIT_SIG: {
            ESP_LOGV(TAG, "[MANUAL_MODE][CONTROLS}[EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::controls_page::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::sensoring::manual_events::controls_page::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            if (ihmEv->length == 2) {
                status_ = Q_TRAN(&Ihm_sensoring_page);
            }
            /*${AOs::Ihm::SM::sensoring::manual_events::controls_page::IHM_INPUT_TOUCH::[RESFRIADOR]} */
            else if (ihmEv->length == 3) {
                ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
                contEv->control = RESFRIADOR;

                if(me->state.control.resfriador == TOGGLE_OFF) {
                    ESP_LOGE(TAG, "Sending 1");
                    contEv->value = 1;
                } else {
                    ESP_LOGE(TAG, "Sending 0");
                    contEv->value = 0;
                }

                QACTIVE_POST(AO_DataBroker, contEv, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::sensoring::manual_events::controls_page::IHM_INPUT_TOUCH::[TURBINA]} */
            else if (ihmEv->length == 4) {
                ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
                contEv->control = TURBINA;

                if(me->state.control.turbina == TOGGLE_OFF) {
                    contEv->value = 70;
                } else if(me->state.control.turbina == TOGGLE_SEVENTY) {
                    contEv->value = 80;
                } else if(me->state.control.turbina == TOGGLE_EIGHTY) {
                    contEv->value = 90;
                } else if(me->state.control.turbina == TOGGLE_NINETY) {
                    contEv->value = 100;
                } else if(me->state.control.turbina == TOGGLE_MAX) {
                    contEv->value = 0;
                }

                QACTIVE_POST(AO_DataBroker, contEv, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::controls_page::IHM_INPUT_SLIDER} */
        case IHM_INPUT_SLIDER_SIG: {
            IhmInputSliderEvt *ihmEv = Q_EVT_CAST(IhmInputSliderEvt);
            ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);

            uint8_t value = ceil(ihmEv->value / 5) * 5;
            uint8_t icon = ceil(value / 5);

            ESP_LOGE(TAG, "%d, %d, %d", ihmEv->control, value, icon);

            if(ihmEv->control == POTENCIA) {
                contEv->control = POTENCIA;
                contEv->value = value;
            } else if(ihmEv->control == CILINDRO) {
                contEv->control = CILINDRO;
                contEv->value = value;
            }

            QACTIVE_POST(AO_DataBroker, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::controls_page::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

            ControlType control = contEv->control;
            int value = contEv->value;
            int icon = ceil(value / 5);

            if(contEv->control == POTENCIA) {
                me->state.control.potencia = value;

                char potStr[100] = {0};
                strcpy(potStr, itoa(value, potStr, 10));

                postUart_setString(CONTROL_POTENCIA_TEXT_VP, potStr, true, CONTROL_POTENCIA_TEXT_LEN);
                postUart_setIcon(CONTROL_POTENCIA_ICON_VP, icon);
            } else if(contEv->control == CILINDRO) {
                me->state.control.cilindro = value;

                char cilStr[100] = {0};
                strcpy(cilStr, itoa(value, cilStr, 10));

                postUart_setString(CONTROL_CILINDRO_TEXT_VP, cilStr, true, CONTROL_POTENCIA_TEXT_LEN);
                postUart_setIcon(CONTROL_CILINDRO_ICON_VP, icon);
            } else if(contEv->control == TURBINA) {
                int icon = 0;

                if(value == 0) {
                    me->state.control.turbina = TOGGLE_OFF;
                    icon = 0;
                } else if(value == 70) {
                    me->state.control.turbina = TOGGLE_SEVENTY;
                    icon = 1;
                } else if(value == 80) {
                    me->state.control.turbina = TOGGLE_EIGHTY;
                    icon = 2;
                } else if(value == 90) {
                    me->state.control.turbina = TOGGLE_NINETY;
                    icon = 3;
                } else if(value == 100) {
                    me->state.control.turbina = TOGGLE_MAX;
                    icon = 4;
                }

                 postUart_setIcon(CONTROL_TURBINA_ICON_VP, icon);
            } else if(contEv->control == RESFRIADOR) {
                int icon = 0;

                if(value == 0) {
                    icon = 0;
                    me->state.control.resfriador = TOGGLE_OFF;
                } else {
                    icon = 4;
                    me->state.control.resfriador = TOGGLE_MAX;
                }
                postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, icon);
            }


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::manual_events::controls_page::DATA_RESPONSE} */
        case DATA_RESPONSE_SIG: {
            DataResponseEvt *resEv = Q_EVT_CAST(DataResponseEvt);

            DataType type = resEv->type;
            Data data = resEv->data;
            /*${AOs::Ihm::SM::sensoring::manual_events::controls_page::DATA_RESPONSE::[type==DATA_PAGE&&data.page_data~} */
            if (type == DATA_PAGE && data.page_data.page == PAGE_CONTROLS) {
                ControlPageData page_data = data.page_data.data;
                uint16_t sensor_grao = page_data->sensor_grao;
                uint16_t sensor_ar = page_data->sensor_ar;
                uint16_t potencia = page_data->potencia;
                uint16_t cilindro = page_data->cilindro;
                uint16_t turbina = page_data->turbina;
                uint16_t resfriador = page_data->resfriador;

                hidratePageControls(sensor_grao, sensor_ar, potencia, cilindro, turbina, resfriador);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_manual_events);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::warn_new} .....................................*/
static QState Ihm_warn_new(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::warn_new} */
        case Q_ENTRY_SIG: {
            postUart_setPage(WARN_NEW_ROAST_PICID);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::warn_new::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::sensoring::warn_new::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::sensoring::warn_new::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                Ihm_setupPageManualMode();
                status_ = Q_TRAN(&Ihm_sensoring_page);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::sensoring::warn_new::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_sensoring_page);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_sensoring);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::summary_page} .................................*/
static QState Ihm_summary_page(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::summary_page} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUMMARY][ENTRY]");

            Ihm_setupPageSummary();

            RequestSummaryEvt *reqEv = Q_NEW(RequestSummaryEvt, REQUEST_SUMMARY_SIG);
            QACTIVE_POST(AO_DataBroker, reqEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::summary_page} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUMMARY][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::summary_page::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::sensoring::summary_page::IHM_INPUT_TOUCH::[ihmEv->length==1||ihmEv->length~} */
            if (ihmEv->length == 1 || ihmEv->length == 4) {
                RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
                ram->mode = MODE_NONE;
                strcpy(ram->roast, "");
                QACTIVE_POST(AO_DataBroker, &ram->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::sensoring::summary_page::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::sensoring::summary_page::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_pre_heating);
            break;
        }
        /*${AOs::Ihm::SM::sensoring::summary_page::RESPONSE_SUMMARY} */
        case RESPONSE_SUMMARY_SIG: {
            ResponseSummaryEvt *resEv = Q_EVT_CAST(ResponseSummaryEvt);

            char fullStr[SUMMARY_TITLE_TEXT_LEN] = "\0";
            sprintf(fullStr, "Torra salva: Torra %s", resEv->name);

            postUart_setString(SUMMARY_TITLE_TEXT_VP, fullStr, true, SUMMARY_TITLE_TEXT_LEN);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_sensoring);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::sensoring::config_page} ..................................*/
static QState Ihm_config_page(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::sensoring::config_page} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[CONFIG][ENTRY]");

            Ihm_setupPageConfig();
            Ihm_requestDataConfig();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::config_page} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[CONFIG][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::sensoring::config_page::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::sensoring::config_page::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_sensoring_page);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::sensoring::config_page::IHM_INPUT_CONFIG_SAVE} */
        case IHM_INPUT_CONFIG_SAVE_SIG: {
            IhmInputConfigSaveEvt *ev = Q_EVT_CAST(IhmInputConfigSaveEvt);

            ConfigUpdateEvt *confEv = Q_NEW(ConfigUpdateEvt, CONFIG_UPDATE_SIG);
            confEv->pre_heat = ev->pre;
            confEv->roast = ev->roast;

            QACTIVE_POST(AO_DataBroker, confEv, me);
            status_ = Q_TRAN(&Ihm_sensoring_page);
            break;
        }
        /*${AOs::Ihm::SM::sensoring::config_page::DATA_RESPONSE} */
        case DATA_RESPONSE_SIG: {
            DataResponseEvt *resEv = Q_EVT_CAST(DataResponseEvt);

            DataType type = resEv->type;
            Data data = resEv->data;
            /*${AOs::Ihm::SM::sensoring::config_page::DATA_RESPONSE::[type==DATA_PAGE&&data.page_data~} */
            if (type == DATA_PAGE && data.page_data.page == PAGE_CONFIG) {
                ConfigPageData page_data = data.page_data.data;
                uint16_t max_pre_heat = page_data->max_pre_heat;
                uint16_t max_roast = page_data->max_roast;

                hidratePageConfig(max_pre_heat, max_roast);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_sensoring);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::recipes} .................................................*/
static QState Ihm_recipes(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::recipes} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[RECIPES][ENTRY]");

            Ihm_resetRoastsPageData(me);
            Ihm_setupPageRoasts(me, true);

            RequestRecipesEvt *reqEv = Q_NEW(RequestRecipesEvt, REQUEST_RECIPES_SIG);
            reqEv->pageNum = 0;
            QACTIVE_POST(AO_DataBroker, &reqEv->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::recipes} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[RECIPES][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::recipes::RESPONSE_RECIPES} */
        case RESPONSE_RECIPES_SIG: {
            ResponseRecipesEvt *rre = Q_EVT_CAST(ResponseRecipesEvt);

            me->roasts_page.page = rre->pageNum;
            strcpy(&me->roasts_page.roast1, rre->roast1);
            strcpy(&me->roasts_page.roast2, rre->roast2);
            strcpy(&me->roasts_page.roast3, rre->roast3);
            me->roasts_page.prev = rre->prevPage;
            me->roasts_page.next = rre->nextPage;

            Ihm_setupPageRoasts(me, true);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::recipes::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::recipes::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            if (ihmEv->length == 5) {
                RequestRecipesEvt *reqEv = Q_NEW(RequestRecipesEvt, REQUEST_RECIPES_SIG);
                reqEv->pageNum = me->roasts_page.page + 1;
                QACTIVE_POST(AO_DataBroker, &reqEv->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::recipes::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            else if (ihmEv->length == 5) {
                RequestRecipesEvt *reqEv = Q_NEW(RequestRecipesEvt, REQUEST_RECIPES_SIG);
                reqEv->pageNum = me->roasts_page.page -1;
                QACTIVE_POST(AO_DataBroker, &reqEv->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::recipes::IHM_INPUT_TOUCH::[ihmEv->length==8&&strcmp(me->ro~} */
            else if (ihmEv->length == 8 && strcmp(me->roasts_page.roast3, "") != 0) {
                strcpy(me->roast_page.roast, me->roasts_page.roast3);
                status_ = Q_TRAN(&Ihm_recipe);
            }
            /*${AOs::Ihm::SM::recipes::IHM_INPUT_TOUCH::[ihmEv->length==7&&strcmp(me->ro~} */
            else if (ihmEv->length == 7 && strcmp(me->roasts_page.roast2, "") != 0) {
                strcpy(me->roast_page.roast, me->roasts_page.roast2);
                status_ = Q_TRAN(&Ihm_recipe);
            }
            /*${AOs::Ihm::SM::recipes::IHM_INPUT_TOUCH::[ihmEv->length==6&&strcmp(me->ro~} */
            else if (ihmEv->length == 6 && strcmp(me->roasts_page.roast1, "") != 0) {
                strcpy(me->roast_page.roast, me->roasts_page.roast1);
                status_ = Q_TRAN(&Ihm_recipe);
            }
            /*${AOs::Ihm::SM::recipes::IHM_INPUT_TOUCH::[ihmEv->length==1||ihmEv->length~} */
            else if (ihmEv->length == 1 || ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::roasts} ..................................................*/
static QState Ihm_roasts(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::roasts} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[ROASTS][ENTRY]");

            Ihm_resetRoastsPageData(me);
            Ihm_setupPageRoasts(me, false);

            RequestRoastsEvt *reqEv = Q_NEW(RequestRoastsEvt, REQUEST_ROASTS_SIG);
            reqEv->pageNum = 0;
            QACTIVE_POST(AO_DataBroker, &reqEv->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::roasts} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[ROASTS][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::roasts::RESPONSE_ROASTS} */
        case RESPONSE_ROASTS_SIG: {
            ResponseRoastsEvt *rre = Q_EVT_CAST(ResponseRoastsEvt);

            me->roasts_page.page = rre->pageNum;
            strcpy(&me->roasts_page.roast1, rre->roast1);
            strcpy(&me->roasts_page.roast2, rre->roast2);
            strcpy(&me->roasts_page.roast3, rre->roast3);
            me->roasts_page.prev = rre->prevPage;
            me->roasts_page.next = rre->nextPage;

            Ihm_setupPageRoasts(me, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::roasts::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::roasts::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            if (ihmEv->length == 5) {
                RequestRoastsEvt *reqEv = Q_NEW(RequestRoastsEvt, REQUEST_ROASTS_SIG);
                reqEv->pageNum = me->roasts_page.page + 1;
                QACTIVE_POST(AO_DataBroker, &reqEv->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::roasts::IHM_INPUT_TOUCH::[ihmEv->length==5]} */
            else if (ihmEv->length == 5) {
                RequestRoastsEvt *reqEv = Q_NEW(RequestRoastsEvt, REQUEST_ROASTS_SIG);
                reqEv->pageNum = me->roasts_page.page - 1;
                QACTIVE_POST(AO_DataBroker, &reqEv->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::roasts::IHM_INPUT_TOUCH::[ihmEv->length==8&&strcmp(me->ro~} */
            else if (ihmEv->length == 8 && strcmp(me->roasts_page.roast3, "") != 0) {
                strcpy(me->roast_page.roast, me->roasts_page.roast3);
                status_ = Q_TRAN(&Ihm_roast);
            }
            /*${AOs::Ihm::SM::roasts::IHM_INPUT_TOUCH::[ihmEv->length==7&&strcmp(me->ro~} */
            else if (ihmEv->length == 7 && strcmp(me->roasts_page.roast2, "") != 0) {
                strcpy(me->roast_page.roast, me->roasts_page.roast2);
                status_ = Q_TRAN(&Ihm_roast);
            }
            /*${AOs::Ihm::SM::roasts::IHM_INPUT_TOUCH::[ihmEv->length==6&&strcmp(me->ro~} */
            else if (ihmEv->length == 6 && strcmp(me->roasts_page.roast1, "") != 0) {
                strcpy(me->roast_page.roast, me->roasts_page.roast1);
                status_ = Q_TRAN(&Ihm_roast);
            }
            /*${AOs::Ihm::SM::roasts::IHM_INPUT_TOUCH::[ihmEv->length==1||ihmEv->length~} */
            else if (ihmEv->length == 1 || ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::config} ..................................................*/
static QState Ihm_config(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::config} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[CONFIG][ENTRY]");

            Ihm_setupPageConfig();

            RequestConfigEvt *reqEv = Q_NEW(RequestConfigEvt, REQUEST_CONFIG_SIG);
            QACTIVE_POST(AO_DataBroker, reqEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::config} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[CONFIG][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::config::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::config::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::config::RESPONSE_CONFIG} */
        case RESPONSE_CONFIG_SIG: {
            ResponseConfigEvt *respEv = Q_EVT_CAST(ResponseConfigEvt);

            //POST to uart
            postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, respEv->pre_heat);
            postUart_setNumber(CONFIG_ROAST_NUMBER_VP, respEv->roast);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::recipe} ..................................................*/
static QState Ihm_recipe(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::recipe} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[RECIPE][ENTRY]");

            Ihm_setupPageRoast(me, true);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::recipe} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[RECIPE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::recipe::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::recipe::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_auto_mode);
            }
            /*${AOs::Ihm::SM::recipe::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                status_ = Q_TRAN(&Ihm_recipes);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::roast} ...................................................*/
static QState Ihm_roast(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::roast} */
        case Q_ENTRY_SIG: {
            ESP_LOGE(TAG, "[ROAST][ENTRY]");
            Ihm_setupPageRoast(me, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::roast} */
        case Q_EXIT_SIG: {
            ESP_LOGE(TAG, "[ROAST][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::roast::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::roast::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_roasts);
            }
            /*${AOs::Ihm::SM::roast::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            else if (ihmEv->length == 4) {
                RequestTransformRoastEvt *rtr = Q_NEW(RequestTransformRoastEvt, REQUEST_TRANSFORM_ROAST_SIG);
                strcpy(rtr->roast, me->roast_page.roast);

                QACTIVE_POST(AO_DataBroker, &rtr->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode} ...............................................*/
static QState Ihm_auto_mode(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[AUTO_MODE][ENTRY]");

            Ihm_resetState(me);
            RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
            ram->mode = MODE_AUTO;
            ESP_LOGE(TAG, "NAME: %s", me->roast_page.roast);
            strcpy(ram->roast, me->roast_page.roast);
            QACTIVE_POST(AO_DataBroker, &ram->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][EXIT]");
            Ihm_resetState(me);
            QTimeEvt_disarm(&me->stageTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::initial} */
        case Q_INIT_SIG: {
            NotifyNextStageEvt *notEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            QHSM_DISPATCH((QHsm *)&me->stage, notEv, me->super.prio);
            status_ = Q_TRAN(&Ihm_auto_pre_heating);
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::NOTIFY_MODE} */
        case NOTIFY_MODE_SIG: {
            NotifyModeEvt *nme = Q_EVT_CAST(NotifyModeEvt);
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            /*${AOs::Ihm::SM::auto_mode::NOTIFY_MODE::[nme->mode==MODE_NONE]} */
            if (nme->mode == MODE_NONE) {
                status_ = Q_TRAN(&Ihm_main_menu);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_summary} .................................*/
static QState Ihm_auto_summary(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[SUMMARY][ENTRY]");

            Ihm_setupPageSummary();
            RequestSummaryEvt *reqEv = Q_NEW(RequestSummaryEvt, REQUEST_SUMMARY_SIG);
            QACTIVE_POST(AO_DataBroker, reqEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_summary} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[SUMMARY][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_summary::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::auto_mode::auto_summary::IHM_INPUT_TOUCH::[ihmEv->length==1||ihmEv->length~} */
            if (ihmEv->length == 1 || ihmEv->length == 4) {
                RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
                ram->mode = MODE_NONE;
                strcpy(ram->roast, "");
                QACTIVE_POST(AO_DataBroker, &ram->super, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::auto_mode::auto_summary::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_summary::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);

            NotifyNextStageEvt *notEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            QHSM_DISPATCH((QHsm *)&me->stage, notEv, me->super.prio);
            status_ = Q_TRAN(&Ihm_auto_pre_heating);
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_summary::RESPONSE_SUMMARY} */
        case RESPONSE_SUMMARY_SIG: {
            ResponseSummaryEvt *resEv = Q_EVT_CAST(ResponseSummaryEvt);

            char fullStr[SUMMARY_TITLE_TEXT_LEN] = "\0";
            sprintf(fullStr, "Torra salva: Torra %s", resEv->name);

            postUart_setString(SUMMARY_TITLE_TEXT_VP, fullStr, true, SUMMARY_TITLE_TEXT_LEN);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events} ..................................*/
static QState Ihm_auto_events(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

            ControlType control = contEv->control;
            int value = contEv->value;

            if(contEv->control == POTENCIA) {
                me->state.control.potencia = value;
            } else if(contEv->control == CILINDRO) {
                me->state.control.cilindro = value;
            } else if(contEv->control == TURBINA) {
                if(value == 0)
                    me->state.control.turbina = TOGGLE_OFF;
                else if(value == 70)
                    me->state.control.turbina = TOGGLE_SEVENTY;
                else if(value == 80)
                    me->state.control.turbina = TOGGLE_EIGHTY;
                else if(value == 90)
                    me->state.control.turbina = TOGGLE_NINETY;
                else if(value == 100)
                    me->state.control.turbina = TOGGLE_MAX;
            } else if(contEv->control == RESFRIADOR) {
                if(value == 0)
                    me->state.control.resfriador = TOGGLE_OFF;
                else
                    me->state.control.resfriador = TOGGLE_MAX;
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::SENSOR_DATA} */
        case SENSOR_DATA_SIG: {
            SensorDataEvt *sensorEv = Q_EVT_CAST(SensorDataEvt);

            SensorType type = sensorEv->type;
            int value = sensorEv->value;
            int delta = sensorEv->delta;

            if(type == SENSOR_GRAO) {
                char graoStr[6] = {0};
                sprintf(graoStr, "%d C", value);
                postUart_setString(SENSOR_GRAO_TEXT_VP, graoStr, true, SENSOR_GRAO_TEXT_LEN);

                char graoDeltaStr[6] = {0};
                sprintf(graoDeltaStr, "%d", delta);
                postUart_setString(DELTA_GRAO_TEXT_VP, graoDeltaStr, true, DELTA_GRAO_TEXT_LEN);
            } else if(sensorEv->type == SENSOR_AR) {
                char arStr[6] = {0};
                sprintf(arStr, "%d C", value);
                postUart_setString(SENSOR_AR_TEXT_VP, arStr, true, SENSOR_AR_TEXT_LEN);

                char arDeltaStr[6] = {0};
                sprintf(arDeltaStr, "%d", delta);
                postUart_setString(DELTA_AR_TEXT_VP, arDeltaStr, true, DELTA_AR_TEXT_LEN);
            } else if(sensorEv->type == SENSOR_GAS) {
                char gasStr[6] = {0};
                sprintf(gasStr, "%d", value);
                postUart_setString(SENSOR_GAS_TEXT_VP, gasStr, true, SENSOR_GAS_TEXT_LEN);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls} ...................*/
static QState Ihm_auto_controls(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[AUTO_MODE][CONTROLS}[ENTRY]");
            Ihm_setupPageControls(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][CONTROLS}[EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            if (ihmEv->length == 2) {
                status_ = Q_TRAN_HIST(me->hist_auto_page);
            }
            /*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls::IHM_INPUT_TOUCH::[RESFRIADOR]} */
            else if (ihmEv->length == 3) {
                ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
                contEv->control = RESFRIADOR;

                if(me->state.control.resfriador == TOGGLE_OFF) {
                    ESP_LOGE(TAG, "Sending 1");
                    contEv->value = 1;
                } else {
                    ESP_LOGE(TAG, "Sending 0");
                    contEv->value = 0;
                }

                QACTIVE_POST(AO_DataBroker, contEv, me);
                status_ = Q_HANDLED();
            }
            /*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls::IHM_INPUT_TOUCH::[TURBINA]} */
            else if (ihmEv->length == 4) {
                ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
                contEv->control = TURBINA;

                if(me->state.control.turbina == TOGGLE_OFF) {
                    contEv->value = 70;
                } else if(me->state.control.turbina == TOGGLE_SEVENTY) {
                    contEv->value = 80;
                } else if(me->state.control.turbina == TOGGLE_EIGHTY) {
                    contEv->value = 90;
                } else if(me->state.control.turbina == TOGGLE_NINETY) {
                    contEv->value = 100;
                } else if(me->state.control.turbina == TOGGLE_MAX) {
                    contEv->value = 0;
                }

                QACTIVE_POST(AO_DataBroker, contEv, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls::IHM_INPUT_SLIDER} */
        case IHM_INPUT_SLIDER_SIG: {
            IhmInputSliderEvt *ihmEv = Q_EVT_CAST(IhmInputSliderEvt);
            ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);

            uint8_t value = ceil(ihmEv->value / 5) * 5;
            uint8_t icon = ceil(value / 5);

            ESP_LOGE(TAG, "%d, %d, %d", ihmEv->control, value, icon);

            if(ihmEv->control == POTENCIA) {
                contEv->control = POTENCIA;
                contEv->value = value;
            } else if(ihmEv->control == CILINDRO) {
                contEv->control = CILINDRO;
                contEv->value = value;
            }

            QACTIVE_POST(AO_DataBroker, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_controls::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

            ControlType control = contEv->control;
            int value = contEv->value;
            int icon = ceil(value / 5);

            if(contEv->control == POTENCIA) {
                me->state.control.potencia = value;

                char potStr[100] = {0};
                strcpy(potStr, itoa(value, potStr, 10));

                postUart_setString(CONTROL_POTENCIA_TEXT_VP, potStr, true, CONTROL_POTENCIA_TEXT_LEN);
                postUart_setIcon(CONTROL_POTENCIA_ICON_VP, icon);
            } else if(contEv->control == CILINDRO) {
                me->state.control.cilindro = value;

                char cilStr[100] = {0};
                strcpy(cilStr, itoa(value, cilStr, 10));

                postUart_setString(CONTROL_CILINDRO_TEXT_VP, cilStr, true, CONTROL_POTENCIA_TEXT_LEN);
                postUart_setIcon(CONTROL_CILINDRO_ICON_VP, icon);
            } else if(contEv->control == TURBINA) {
                int icon = 0;

                if(value == 0) {
                    me->state.control.turbina = TOGGLE_OFF;
                    icon = 0;
                } else if(value == 70) {
                    me->state.control.turbina = TOGGLE_SEVENTY;
                    icon = 1;
                } else if(value == 80) {
                    me->state.control.turbina = TOGGLE_EIGHTY;
                    icon = 2;
                } else if(value == 90) {
                    me->state.control.turbina = TOGGLE_NINETY;
                    icon = 3;
                } else if(value == 100) {
                    me->state.control.turbina = TOGGLE_MAX;
                    icon = 4;
                }

                 postUart_setIcon(CONTROL_TURBINA_ICON_VP, icon);
            } else if(contEv->control == RESFRIADOR) {
                int icon = 0;

                if(value == 0) {
                    icon = 0;
                    me->state.control.resfriador = TOGGLE_OFF;
                } else {
                    icon = 4;
                    me->state.control.resfriador = TOGGLE_MAX;
                }
                postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, icon);
            }


            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_events);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events::auto_page} .......................*/
static QState Ihm_auto_page(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page} */
        case Q_ENTRY_SIG: {
            Ihm_setupPageAutoMode();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page} */
        case Q_EXIT_SIG: {
            /* save deep history */
            me->hist_auto_page = QHsm_state(Q_HSM_UPCAST(me));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::CHART_DATA} */
        case CHART_DATA_SIG: {
            ChartDataEvt *chartEv = Q_EVT_CAST(ChartDataEvt);
            SensorType type = chartEv->type;
            TempData *tempData = chartEv->temp_data;
            int max = chartEv->max;
            int min = chartEv->min;

            if(type == SENSOR_GRAO) {
                Ihm_postTemperatures(VP_CHART_LINE_GRAO, SENSOR_GRAO, tempData->temps, tempData->count, 0, 390, 272, 93, true, 320, max, min, 204, false);
                //Ihm_postTemperatures(VP_CHART_CIRCLE_GRAO, GRAO, deltas_grao, temps_grao_count, 0, 390, 272, 173, true, 320, sensorEv->sensorData->max_temp_delta, sensorEv->sensorData->min_temp_delta, 204, true);
            } else if(type == SENSOR_AR) {
                Ihm_postTemperatures(VP_CHART_LINE_AR, SENSOR_AR, tempData->temps, tempData->count, 0, 390, 272, 93, true, 320, max, min, 204, false);
                //Ihm_postTemperatures(VP_CHART_CIRCLE_AR, AR, deltas_ar, temps_ar_count, 0, 390, 272, 173, true, 320, sensorEv->sensorData->max_temp_delta, sensorEv->sensorData->min_temp_delta, 204, true);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::IHM_INPUT_TOUCH::[ihmEv->length==4]} */
            if (ihmEv->length == 4) {
                status_ = Q_TRAN(&Ihm_auto_controls);
            }
            /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::IHM_INPUT_TOUCH::[ihmEv->length==2]} */
            else if (ihmEv->length == 2) {
                status_ = Q_TRAN(&Ihm_auto_config);
            }
            /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            else if (ihmEv->length == 3) {
                RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
                QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_events);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active} ..........*/
static QState Ihm_auto_active(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][ENTRY]");

            postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
            postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);

            Ihm_resetChart(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_page);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_pre_heating}*/
static QState Ihm_auto_pre_heating(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][PRE_HEATING][ENTRY]");


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_pre_heating::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_auto_roasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart}*/
static QState Ihm_auto_chart(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[AUTO_MODE][ACTIVE][CHART][ENTRY]");


            QTimeEvt_armX(&me->stageTimerEvt, STAGE_TIMER_INTERVAL, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[MANUAL_MODE][ACTIVE][CHART][EXIT]");

            QTimeEvt_disarm(&me->stageTimerEvt);
            Ihm_resetChart(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::IHM_STAGE_TIMER_TIMEOUT} */
        case IHM_STAGE_TIMER_TIMEOUT_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);

            QTimeEvt_rearm(&me->stageTimerEvt, STAGE_TIMER_INTERVAL);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_cooling}*/
static QState Ihm_auto_cooling(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[AUTO_MODE][ACTIVE][CHART][COOLING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[AUTO_MODE][ACTIVE][CHART][ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_cooling::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_auto_summary);
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_chart);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_roasting}*/
static QState Ihm_auto_roasting(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[AUTO_MODE][ACTIVE][CHART][ROASTING][ENTRY]");

            RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
            stageEv->substage = F;
            QACTIVE_POST(AO_DataBroker, &stageEv->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[AUTO_MODE][ACTIVE][CHART][ROASTING][EXIT]");

            NotifySubstageExitEvt *stageEv = Q_NEW(NotifySubstageExitEvt, NOTIFY_SUBSTAGE_EXIT_SIG);
            QHSM_DISPATCH((QHsm *)&me->substage, stageEv, me->super.prio);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_roasting::NOTIFY_NEXT_STAGE} */
        case NOTIFY_NEXT_STAGE_SIG: {
            QHSM_DISPATCH((QHsm *)&me->stage, e, me->super.prio);
            status_ = Q_TRAN(&Ihm_auto_cooling);
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_roasting::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_roasting::IHM_INPUT_TOUCH::[SUBSTAGE]} */
            if (ihmEv->length == 5) {
                QHSM_DISPATCH((QHsm *)&me->substage, e, me->super.prio);
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_page::auto_active::auto_chart::auto_roasting::NOTIFY_NEXT_SUBSTAGE} */
        case NOTIFY_NEXT_SUBSTAGE_SIG: {
            NotifyNextSubstageEvt *subEv = Q_EVT_CAST(NotifyNextSubstageEvt);

            QHSM_DISPATCH((QHsm *)&me->substage, subEv, me->super.prio);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_chart);
            break;
        }
    }
    return status_;
}

/*${AOs::Ihm::SM::auto_mode::auto_events::auto_config} .....................*/
static QState Ihm_auto_config(Ihm * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_config} */
        case Q_ENTRY_SIG: {
            ESP_LOGD(TAG, "[CONFIG][ENTRY]");

            ESP_LOGE(TAG, "size: %d", sizeof(unsigned short));

            Ihm_setupPageConfig();
            RequestConfigEvt *confEv = Q_NEW(RequestConfigEvt, REQUEST_CONFIG_SIG);
            QACTIVE_POST(AO_DataBroker, confEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_config} */
        case Q_EXIT_SIG: {
            ESP_LOGD(TAG, "[CONFIG][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_config::IHM_INPUT_TOUCH} */
        case IHM_INPUT_TOUCH_SIG: {
            IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);
            /*${AOs::Ihm::SM::auto_mode::auto_events::auto_config::IHM_INPUT_TOUCH::[ihmEv->length==3]} */
            if (ihmEv->length == 3) {
                status_ = Q_TRAN_HIST(me->hist_auto_page);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_config::IHM_INPUT_CONFIG_SAVE} */
        case IHM_INPUT_CONFIG_SAVE_SIG: {
            IhmInputConfigSaveEvt *ev = Q_EVT_CAST(IhmInputConfigSaveEvt);

            ConfigUpdateEvt *confEv = Q_NEW(ConfigUpdateEvt, CONFIG_UPDATE_SIG);
            confEv->pre_heat = ev->pre;
            confEv->roast = ev->roast;

            QACTIVE_POST(AO_DataBroker, confEv, me);
            status_ = Q_TRAN_HIST(me->hist_auto_page);
            break;
        }
        /*${AOs::Ihm::SM::auto_mode::auto_events::auto_config::RESPONSE_CONFIG} */
        case RESPONSE_CONFIG_SIG: {
            ResponseConfigEvt *respEv = Q_EVT_CAST(ResponseConfigEvt);

            //POST to uart
            postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, respEv->pre_heat);
            postUart_setNumber(CONFIG_ROAST_NUMBER_VP, respEv->roast);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Ihm_auto_events);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Ihm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${AOs::Ihm_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Ihm_ctor} .........................................................*/
void Ihm_ctor(void) {
    Ihm *me = &l_ihm;
    IhmStage *stage = &l_ihmStage;
    IhmSubstage *substage = &l_ihmSubstage;

    QActive_ctor(&me->super, Q_STATE_CAST(&Ihm_initial));
    me->state.control = (ControlState){
        .potencia = 0,
        .cilindro = 0,
        .turbina = TOGGLE_OFF,
        .resfriador = TOGGLE_OFF
    };

    QHsm_ctor(&me->stage, Q_STATE_CAST(&IhmStage_initial));
    QHsm_ctor(&me->substage, Q_STATE_CAST(&IhmSubstage_initial));

    QTimeEvt_ctorX(&me->stageTimerEvt, &me->super, IHM_STAGE_TIMER_TIMEOUT_SIG, 0U);
}
/*$enddef${AOs::Ihm_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
