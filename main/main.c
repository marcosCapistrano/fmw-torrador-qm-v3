/*$file${.::main.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: fmw-torrador-v3.qm
* File:  ${.::main.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::main.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "freertos/FreeRTOS.h"
#include "esp_log.h"
#include "nvs.h"
#include "nvs_flash.h"
#include "server_controller.h"
#include "common.h"

Q_DEFINE_THIS_FILE

static const char *TAG = "main";

/*
 * small event memory pool
 */
static QF_MPOOL_EL(QEvt) smallPoolSto[CONFIG_QPC_SMALL_POOL_SIZE];

/*
 * medium size event memory pool
 * size: QEvt + CONFIG_QPC_MEDIUM_POOL_ENTRY_SIZE words
 */
typedef struct {
    QEvt super;
    uint32_t data[CONFIG_QPC_MEDIUM_POOL_ENTRY_SIZE];
} mediumPool;
static QF_MPOOL_EL(mediumPool) mediumPoolSto[CONFIG_QPC_MEDIUM_POOL_SIZE];

/*
 * large size event memory pool
 * size: QEvt + CONFIG_QPC_LARGE_POOL_ENTRY_SIZE words
 */
typedef struct {
    QEvt super;
    uint32_t data[CONFIG_QPC_LARGE_POOL_ENTRY_SIZE];
} largePool;
static QF_MPOOL_EL(largePool) largePoolSto[CONFIG_QPC_LARGE_POOL_SIZE];

static QEvt const *ihmQueueSto[30];
static QEvt const *perifQueueSto[20];
static QEvt const *dataBrokerQueueSto[20];
static QEvt const *uartQueueSto[30];

static QSubscrList subscrSto[25];
static StackType_t ihmStack[8192];
static StackType_t perifStack[4096];
static StackType_t dataBrokerStack[16384];
static StackType_t uartStack[8192];

void setup_peripherals();
void storage_init();
void server_controller_init();

void app_main() {
    ESP_LOGI(TAG, "Iniciando NVS");
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        // NVS partition was truncated and needs to be erased
        // Retry nvs_flash_init
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    ESP_ERROR_CHECK(err);
    ESP_LOGI(TAG, "NVS Ok!");

    Uart_ctor();
    Ihm_ctor();
    Perif_ctor();
    DataBroker_ctor();
    setup_peripherals();
    storage_init();
    server_controller_init();

    QF_init();

    /* initialize publish-subscribe... */
    QF_psInit(subscrSto, Q_DIM(subscrSto));

    /* Initialize Event Memory Pool */
    QF_poolInit(smallPoolSto, sizeof(smallPoolSto), sizeof(smallPoolSto[0]));
    QF_poolInit(mediumPoolSto, sizeof(mediumPoolSto), sizeof(mediumPoolSto[0]));
    QF_poolInit(largePoolSto, sizeof(largePoolSto), sizeof(largePoolSto[0]));

    QActive_setAttr(AO_Uart, TASK_NAME_ATTR, "UART");
    QACTIVE_START(AO_Uart,             /* AO to start */
                  (uint_fast8_t)(5),  /* QP priority of the AO */
                  uartQueueSto,        /* event queue storage */
                  Q_DIM(uartQueueSto), /* queue length [events] */
                  uartStack,           /* stack storage */
                  sizeof(uartStack),   /* stack size [bytes] */
                  (QEvt *)0);         /* initialization event (not used) */

    QActive_setAttr(AO_Ihm, TASK_NAME_ATTR, "IHM");
    QACTIVE_START(AO_Ihm,             /* AO to start */
                  (uint_fast8_t)(4),  /* QP priority of the AO */
                  ihmQueueSto,        /* event queue storage */
                  Q_DIM(ihmQueueSto), /* queue length [events] */
                  ihmStack,           /* stack storage */
                  sizeof(ihmStack),   /* stack size [bytes] */
                  (QEvt *)0);         /* initialization event (not used) */

    QActive_setAttr(AO_Perif, TASK_NAME_ATTR, "PERIF");
    QACTIVE_START(AO_Perif,             /* AO to start */
                  (uint_fast8_t)(3),    /* QP priority of the AO */
                  perifQueueSto,        /* event queue storage */
                  Q_DIM(perifQueueSto), /* queue length [events] */
                  perifStack,           /* stack storage */
                  sizeof(perifStack),   /* stack size [bytes] */
                  (QEvt *)0);           /* initialization event (not used) */

 QActive_setAttr(AO_DataBroker, TASK_NAME_ATTR, "DATA_BROKER");
    QACTIVE_START(AO_DataBroker,             /* AO to start */
                  (uint_fast8_t)(2),   /* QP priority of the AO */
                  dataBrokerQueueSto,        /* event queue storage */
                  Q_DIM(dataBrokerQueueSto), /* queue length [events] */
                  dataBrokerStack,           /* stack storage */
                  sizeof(dataBrokerStack),   /* stack size [bytes] */
                  (QEvt *)0);          /* initialization event (not used) */

    /* start the active objects... */
    QF_run();

    ESP_LOGI(TAG, "Goodbye app_main()");
}
