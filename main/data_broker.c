/*$file${.::data_broker.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: fmw-torrador-v3.qm
* File:  ${.::data_broker.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::data_broker.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "common.h"
#include "esp_log.h"
#include <time.h>
#include <string.h>
#include "storage.h"

Q_DEFINE_THIS_FILE

static const char * TAG = "DATA_BROKER";

/*$declare${AOs::DataBroker} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::DataBroker} .......................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    Config config;
    RoastData curr_roast;
    RecipeData curr_recipe;
    QTimeEvt recipeTimerEvt;
    time_t timer_start;
} DataBroker;

/* private: */
static void DataBroker_updateSensorData(DataBroker * const me,
    SensorType type,
    int value,
    bool enqueue);
static void DataBroker_setupRecipe(DataBroker * const me);
static void DataBroker_resetData(DataBroker * const me);
static void DataBroker_resetConfig(DataBroker * const me);
static void DataBroker_resetRoast(DataBroker * const me);
static void DataBroker_resetRecipe(DataBroker * const me);

/* protected: */
static QState DataBroker_initial(DataBroker * const me, void const * const par);
static QState DataBroker_state1(DataBroker * const me, QEvt const * const e);
static QState DataBroker_idle(DataBroker * const me, QEvt const * const e);
static QState DataBroker_active_mode(DataBroker * const me, QEvt const * const e);
static QState DataBroker_pre_heating(DataBroker * const me, QEvt const * const e);
static QState DataBroker_auto_pre_heating(DataBroker * const me, QEvt const * const e);
static QState DataBroker_manual_pre_heating(DataBroker * const me, QEvt const * const e);
static QState DataBroker_roasting(DataBroker * const me, QEvt const * const e);
static QState DataBroker_auto_roasting(DataBroker * const me, QEvt const * const e);
static QState DataBroker_manual_roasting(DataBroker * const me, QEvt const * const e);
static QState DataBroker_cooling(DataBroker * const me, QEvt const * const e);
static QState DataBroker_auto_cooling(DataBroker * const me, QEvt const * const e);
static QState DataBroker_manual_cooling(DataBroker * const me, QEvt const * const e);
static QState DataBroker_summary(DataBroker * const me, QEvt const * const e);
static QState DataBroker_manual_summary(DataBroker * const me, QEvt const * const e);
static QState DataBroker_auto_summary(DataBroker * const me, QEvt const * const e);
static QState DataBroker_sensoring(DataBroker * const me, QEvt const * const e);
/*$enddecl${AOs::DataBroker} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static DataBroker l_dataBroker; /* a única instância do AO IHM */

QActive * const AO_DataBroker = &l_dataBroker.super;

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${AOs::DataBroker} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::DataBroker} .......................................................*/

/*${AOs::DataBroker::updateSensorData} .....................................*/
static void DataBroker_updateSensorData(DataBroker * const me,
    SensorType type,
    int value,
    bool enqueue)
{
    SensorData *data = &(me->curr_roast.sensor_data);
    TempData *arData = &data->ar;
    TempData *graoData = &data->grao;
    int *max = &data->max;
    int *min = &data->min;
    int *max_delta = &data->max_delta;
    int *min_delta = &data->min_delta;
    int *grao_aux = &data->grao_aux;
    int *ar_aux = &data->ar_aux;

    if(value > *max) {
       *max = value;
    } else if(value < *min) {
       *min = value;
    }

    if(type == SENSOR_GRAO && graoData->count > 0) {
        int value_cmp = (value - graoData->deltas[graoData->count-1])*10;

        if(value_cmp > *max_delta) {
           *max_delta = value_cmp;
        } else if(value_cmp < *min_delta) {
            *min_delta = value_cmp;
        }
    } else if(type == SENSOR_AR && graoData->count > 0) {
        int value_cmp = (value - graoData->deltas[graoData->count-1])*10;

        if(value_cmp > *max_delta) {
            *max_delta = value_cmp;
        } else if(value_cmp < *min_delta) {
            *min_delta = value_cmp;
        }
    }

    if(!enqueue) {
        if(type == SENSOR_GRAO) {
            graoData->temps[0] = value;
            graoData->deltas[0] = 0;

            graoData->count = 1;
        } else if(type == SENSOR_AR) {
            arData->temps[0] = value;
            arData->deltas[0] = 0;

            arData->count = 1;
        }
    } else {
        if(type == SENSOR_GRAO) {
            if(graoData->count < 31) {
                int new_count = graoData->count+1;
                graoData->count = new_count;
                graoData->temps[new_count-1] = value;

                if(graoData->count > 1) {
                    graoData->deltas[new_count-1] = value - graoData->temps[new_count-2];
                } else if(graoData->count == 1) {
                    graoData->deltas[0] = 0;
                }
            } else {
                graoData->temps[*grao_aux] = (graoData->temps[*grao_aux] + graoData->temps[*grao_aux+1]) / 2;
                graoData->deltas[*grao_aux] = (graoData->deltas[*grao_aux] + graoData->deltas[(*grao_aux)+1]) / 2;
                for(int i=(*grao_aux)+1; i < 30; i++) {
                    graoData->temps[i] = graoData->temps[i+1];
                    graoData->deltas[i] = graoData->deltas[i+1];
                }
                graoData->temps[30] = value;
                graoData->deltas[30] = value - graoData->temps[29];

                (*grao_aux)++;
                *grao_aux = (*grao_aux) % 25;
            }
        } else if(type == SENSOR_AR) {
            if(arData->count < 31) {
                int new_count = arData->count + 1;
                arData->count = new_count;
                arData->temps[new_count-1] = value;

                if(arData->count > 1) {
                    arData->deltas[new_count-1] = value - arData->temps[new_count-2];
                } else if(arData->count == 1) {
                    arData->deltas[0] = 0;
                }
            } else {
                arData->temps[*ar_aux] = (arData->temps[*ar_aux] + arData->temps[(*ar_aux)+1]) / 2;
                arData->deltas[*ar_aux] = (arData->deltas[*ar_aux] + arData->deltas[(*ar_aux)+1]) / 2;
                for(int i=(*ar_aux)+1; i < 30; i++) {
                    arData->temps[i] = arData->temps[i+1];
                    arData->deltas[i] = arData->deltas[i+1];
                }
                arData->temps[30] = value;
                arData->deltas[30] = value - arData->temps[29];

                (*ar_aux)++;
                *ar_aux = (*ar_aux) % 25;
            }
        }
    }
}

/*${AOs::DataBroker::setupRecipe} ..........................................*/
static void DataBroker_setupRecipe(DataBroker * const me) {
    /*
    me->recipe_commands = (RecipeCommands){
        .intervals = {0},
        .controls = {0},
        .values = {0},
        .count = 0,
    };
    me->curr_command = 0;
    storage_get_recipe_commands(me->curr_mode.roast, &me->recipe_commands);
    */
}

/*${AOs::DataBroker::resetData} ............................................*/
static void DataBroker_resetData(DataBroker * const me) {
    DataBroker_resetConfig(me);
    DataBroker_resetRoast(me);
    DataBroker_resetRecipe(me);

    me->timer_start = 0;
}

/*${AOs::DataBroker::resetConfig} ..........................................*/
static void DataBroker_resetConfig(DataBroker * const me) {
    uint16_t pre_heat = 0;
    uint16_t roast = 0;
    storage_get_global_config(&pre_heat, &roast);

    me->config.max_pre_heat = pre_heat;
    me->config.max_roast = roast;
}

/*${AOs::DataBroker::resetRoast} ...........................................*/
static void DataBroker_resetRoast(DataBroker * const me) {
    me->curr_roast.time_start = 0;
    me->curr_roast.time_end = 0;

    me->curr_roast.sensor_data.ar.count = 0;
    /*
    me->sensor_data.ar.temps = {0};
    me->sensor_data.ar.deltas = {0};
    */

    me->curr_roast.sensor_data.grao.count = 0;
    /*
    me->sensor_data.grao.temps = {0};
    me->sensor_data.grao.deltas = {0};
    */

    me->curr_roast.sensor_data.max = 0;
    me->curr_roast.sensor_data.min = 0;
    me->curr_roast.sensor_data.max_delta = 0;
    me->curr_roast.sensor_data.min_delta = 0;

    strcpy(me->curr_roast.name, "");
}

/*${AOs::DataBroker::resetRecipe} ..........................................*/
static void DataBroker_resetRecipe(DataBroker * const me) {
    /*
    me->curr_recipe.intervals = {0};
    me->curr_recipe.controls = {0};
    me->curr_recipe.values = {0};
    */
    me->curr_recipe.count = 0;
}

/*${AOs::DataBroker::SM} ...................................................*/
static QState DataBroker_initial(DataBroker * const me, void const * const par) {
    /*${AOs::DataBroker::SM::initial} */
    return Q_TRAN(&DataBroker_idle);
}

/*${AOs::DataBroker::SM::state1} ...........................................*/
static QState DataBroker_state1(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::CONFIG_UPDATE} */
        case CONFIG_UPDATE_SIG: {
            ConfigUpdateEvt *confEv = Q_EVT_CAST(ConfigUpdateEvt);

            storage_set_global_config(confEv->pre_heat, confEv->roast);

            ESP_LOGV(TAG, "Setting new Config: %d - %d", confEv->pre_heat, confEv->roast);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::REQUEST_CONFIG} */
        case REQUEST_CONFIG_SIG: {
            uint16_t pre_heat = 0;
            uint16_t roast = 0;

            storage_get_global_config(&pre_heat, &roast);
            ESP_LOGE(TAG, "Got global config: %d, %d", pre_heat, roast);

            ResponseConfigEvt *respEv = Q_NEW(ResponseConfigEvt, RESPONSE_CONFIG_SIG);
            respEv->pre_heat = pre_heat;
            respEv->roast = roast;
            QACTIVE_POST(AO_Ihm, respEv, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::idle} .....................................*/
static QState DataBroker_idle(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[IDLE][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::idle::REQUEST_RECIPES} */
        case REQUEST_RECIPES_SIG: {
            RequestRecipesEvt *recipesEvt = Q_EVT_CAST(RequestRecipesEvt);
            uint8_t pageNum = recipesEvt->pageNum;

            RecipesResponse res = {0};
            int ret = storage_get_recipes_page(pageNum, &res);

            if(ret != -1) {
                uint8_t resPageNum = res.pageNum;
                char roast1[25];
                strcpy(roast1, res.roast1);
                char roast2[25];
                strcpy(roast2, res.roast2);
                char roast3[25];
                strcpy(roast3, res.roast3);

                bool prevPage = res.prevPage;
                bool nextPage = res.nextPage;

                ResponseRecipesEvt *rre = Q_NEW(ResponseRecipesEvt, RESPONSE_RECIPES_SIG);
                rre->pageNum = res.pageNum;
                strcpy(rre->roast1, res.roast1);
                strcpy(rre->roast2, res.roast2);
                strcpy(rre->roast3, res.roast3);
                rre->prevPage = res.prevPage;
                rre->nextPage = res.nextPage;

                QACTIVE_POST(AO_Ihm, &rre->super, me);
            } else {
                ESP_LOGE(TAG, "Algo deu errado ao buscar as receitas");
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::idle::REQUEST_RECIPE} */
        case REQUEST_RECIPE_SIG: {
            RequestRecipeEvt *reqEvt = Q_EVT_CAST(RequestRecipeEvt);
            char *roast = reqEvt->roast;

            SensorData sensorData = {0};
            RoastResponse res = {0};
            res.sensorData = &sensorData;

            int ret = storage_get_roast(roast, &res);

            if(ret != -1) {
                ResponseRecipeEvt *rre = Q_NEW(ResponseRecipeEvt, RESPONSE_RECIPE_SIG);
                strcpy(rre->roast, res.roast);
                rre->sensorData = res.sensorData;

                QACTIVE_POST(AO_Ihm, &rre->super, me);
            } else {
                ESP_LOGE(TAG, "Algo deu errado ao buscar a receita %s", roast);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::idle::REQUEST_MODE} */
        case REQUEST_MODE_SIG: {
            RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);
            /*${AOs::DataBroker::SM::state1::idle::REQUEST_MODE::[MODE_MANUAL]} */
            if (rme->mode == MODE_MANUAL) {
                NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme->mode = MODE_MANUAL;
                strcpy(nme->roast,"");
                QACTIVE_POST(AO_Perif, &nme->super, me);

                NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme2->mode = MODE_MANUAL;
                strcpy(nme2->roast,"");
                QACTIVE_POST(AO_Ihm, &nme2->super, me);

                /*
                me->curr_mode.mode = MODE_MANUAL;
                strcpy(me->curr_mode.roast, rme->roast);
                */
                status_ = Q_TRAN(&DataBroker_sensoring);
            }
            /*${AOs::DataBroker::SM::state1::idle::REQUEST_MODE::[MODE_AUTO]} */
            else if (rme->mode == MODE_AUTO) {
                NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme->mode = MODE_AUTO;
                strcpy(nme->roast, rme->roast);
                QACTIVE_POST(AO_Perif, &nme->super, me);

                NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme2->mode = MODE_AUTO;
                strcpy(nme2->roast,rme->roast);
                QACTIVE_POST(AO_Ihm, &nme2->super, me);

                /*
                me->curr_mode.mode = MODE_AUTO;
                strcpy(me->curr_mode.roast, rme->roast);
                */
                status_ = Q_TRAN(&DataBroker_auto_pre_heating);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::DataBroker::SM::state1::idle::REQUEST_ROASTS} */
        case REQUEST_ROASTS_SIG: {
            RequestRoastsEvt *roastsEvt = Q_EVT_CAST(RequestRoastsEvt);
            uint8_t pageNum = roastsEvt->pageNum;

            RoastsResponse res = {0};
            int ret = storage_get_roasts_page(pageNum, &res);

            if(ret != -1) {
                uint8_t resPageNum = res.pageNum;
                char roast1[25];
                strcpy(roast1, res.roast1);
                char roast2[25];
                strcpy(roast2, res.roast2);
                char roast3[25];
                strcpy(roast3, res.roast3);

                bool prevPage = res.prevPage;
                bool nextPage = res.nextPage;

                ResponseRoastsEvt *rre = Q_NEW(ResponseRoastsEvt, RESPONSE_ROASTS_SIG);
                rre->pageNum = res.pageNum;
                strcpy(rre->roast1, res.roast1);
                strcpy(rre->roast2, res.roast2);
                strcpy(rre->roast3, res.roast3);
                rre->prevPage = res.prevPage;
                rre->nextPage = res.nextPage;

                QACTIVE_POST(AO_Ihm, &rre->super, me);
            } else {
                ESP_LOGE(TAG, "Algo deu errado ao buscar as torras");
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::idle::REQUEST_ROAST} */
        case REQUEST_ROAST_SIG: {
            RequestRoastEvt *reqEvt = Q_EVT_CAST(RequestRoastEvt);
            char *roast = reqEvt->roast;

            SensorData sensorData = {0};
            RoastResponse res = {0};
            res.sensorData = &sensorData;

            int ret = storage_get_roast(roast, &res);

            if(ret != -1) {
                ResponseRoastEvt *rre = Q_NEW(ResponseRoastEvt, RESPONSE_ROAST_SIG);
                strcpy(rre->roast, res.roast);
                rre->sensorData = res.sensorData;

                QACTIVE_POST(AO_Ihm, &rre->super, me);
            } else {
                ESP_LOGE(TAG, "Algo deu errado ao buscar a torra %s", roast);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::idle::REQUEST_TRANSFORM_ROAST} */
        case REQUEST_TRANSFORM_ROAST_SIG: {
            RequestTransformRoastEvt *rtr = Q_EVT_CAST(RequestTransformRoastEvt);

            char roast[25];
            strcpy(roast, rtr->roast);

            storage_transform_roast(roast);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_state1);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode} ..............................*/
static QState DataBroker_active_mode(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][ENTRY]");

            //me->pre_heat_value = 0;
            //me->cooler_value = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::CONTROL_UPDATE} */
        case CONTROL_UPDATE_SIG: {
            ControlUpdateEvt *contEv = Q_EVT_CAST(ControlUpdateEvt);
            QACTIVE_POST(AO_Perif, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::REQUEST_MODE} */
        case REQUEST_MODE_SIG: {
            RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);
            /*${AOs::DataBroker::SM::state1::active_mode::REQUEST_MODE::[rme->mode==MODE_NONE]} */
            if (rme->mode == MODE_NONE) {
                NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme->mode = MODE_NONE;
                strcpy(nme->roast,"");
                QACTIVE_POST(AO_Perif, &nme->super, me);

                NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme2->mode = MODE_NONE;
                strcpy(nme2->roast,"");
                QACTIVE_POST(AO_Ihm, &nme2->super, me);

                /*
                me->curr_mode.mode = MODE_NONE;
                strcpy(me->curr_mode.roast, rme->roast);
                */
                status_ = Q_TRAN(&DataBroker_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_state1);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::pre_heating} .................*/
static QState DataBroker_pre_heating(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating} */
        case Q_ENTRY_SIG: {
            storage_create_new_roast(&me->curr_roast.name);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating::SENSOR_UPDATE} */
        case SENSOR_UPDATE_SIG: {
            SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);
            SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
            sensorDataEv->type = sensorEv->type;
            sensorDataEv->value = sensorEv->value;
            sensorDataEv->delta = 0;
            QACTIVE_POST(AO_Ihm, sensorDataEv, me);

            DataBroker_updateSensorData(me, sensorEv->type, sensorEv->value, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
            QACTIVE_POST(AO_Ihm, contEv, me);

            storage_add_roast_control_record(0, contEv->control, contEv->value);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_active_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::pre_heating::auto_pre_heating}*/
static QState DataBroker_auto_pre_heating(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating::auto_pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_PRE_HEATING][ENTRY]");

            //ESP_LOGE(TAG, "recipe: %s", me->curr_mode.roast);
            //DataBroker_setupRecipe(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating::auto_pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating::auto_pre_heating::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_auto_roasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_pre_heating);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::pre_heating::manual_pre_heating}*/
static QState DataBroker_manual_pre_heating(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating::manual_pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_PRE_HEATING][ENTRY]");

            ControlUpdateEvt *potEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
            potEv->control = POTENCIA;
            potEv->value = 100;
            QACTIVE_POST(AO_Perif, potEv, me);

            ControlUpdateEvt *cilEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
            potEv->control = CILINDRO;
            potEv->value = 100;
            QACTIVE_POST(AO_Perif, cilEv, me);

            ControlUpdateEvt *turbEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
            potEv->control = TURBINA;
            potEv->value = 70;
            QACTIVE_POST(AO_Perif, turbEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating::manual_pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::pre_heating::manual_pre_heati~::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_roasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_pre_heating);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::roasting} ....................*/
static QState DataBroker_roasting(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::roasting} */
        case Q_ENTRY_SIG: {
            time_t time_now;
            time(&time_now);

            me->curr_roast.time_start = time_now;
            me->timer_start = time_now;

            int count = me->curr_roast.sensor_data.grao.count;

            if(count > 0)
                storage_add_roast_pre_heat_record(0, me->curr_roast.sensor_data.grao.temps[count-1]);
            else
                storage_add_roast_pre_heat_record(0, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::SENSOR_UPDATE} */
        case SENSOR_UPDATE_SIG: {
            SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);
            SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
            sensorDataEv->type = sensorEv->type;
            sensorDataEv->value = sensorEv->value;
            sensorDataEv->delta = 0;
            QACTIVE_POST(AO_Ihm, sensorDataEv, me);

            DataBroker_updateSensorData(me, sensorEv->type, sensorEv->value, true);

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->curr_roast.time_start;
            storage_add_roast_sensor_record(time_elapsed, sensorEv->type, sensorEv->value);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
            QACTIVE_POST(AO_Ihm, contEv, me);

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->curr_roast.time_start;

            storage_add_roast_control_record(time_elapsed, contEv->control, contEv->value);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::REQUEST_NEXT_SUBSTAGE} */
        case REQUEST_NEXT_SUBSTAGE_SIG: {
            RequestNextSubstageEvt *subEv = Q_EVT_CAST(RequestNextSubstageEvt);
            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->curr_roast.time_start;


            if(subEv->substage == Q1)
                storage_add_roast_q1_record(time_elapsed);

            if(subEv->substage == Q2)
                storage_add_roast_q2_record(time_elapsed);


            NotifyNextSubstageEvt *stageEv = Q_NEW(NotifyNextSubstageEvt, NOTIFY_NEXT_SUBSTAGE_SIG);
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_active_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::roasting::auto_roasting} .....*/
static QState DataBroker_auto_roasting(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::auto_roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_ROASTING][ENTRY]");


            /*
            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            time_t time_command = (me->recipe_commands.intervals[me->curr_command] - time_elapsed);

            if(time_command <= 0)
                time_command = 1;

            if(me->curr_command < me->recipe_commands.count) {
                ESP_LOGD(TAG, "Scheduled command %d for %lds - value: %d", me->recipe_commands.controls[me->curr_command], time_command, me->recipe_commands.values[me->curr_command]);
                QTimeEvt_armX(&me->recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
            }
            */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::auto_roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::auto_roasting::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_auto_cooling);
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::auto_roasting::DATA_RECIPE_TIMEOUT} */
        case DATA_RECIPE_TIMEOUT_SIG: {
            QTimeEvt_disarm(&me->recipeTimerEvt);
            /*
            ControlType control = me->recipe_commands.controls[me->curr_command];
            int value = me->recipe_commands.values[me->curr_command];

            UpdateControlEvt *contEv = Q_NEW(UpdateControlEvt, UPDATE_CONTROL_SIG);
            contEv->control = control;
            contEv->value = value;
            QACTIVE_POST(AO_Perif, contEv, me);


            ControlDataEvt *contEv2 = Q_EVT_CAST(ControlDataEvt);
            contEv2->control = control;
            contEv2->value = value;
            QACTIVE_POST(AO_Ihm, contEv, me);


            me->curr_command += 1;

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            time_t time_command = (me->recipe_commands.intervals[me->curr_command] - time_elapsed);

            if(time_command <= 0)
                time_command = 1;

            if(me->curr_command < me->recipe_commands.count) {
                ESP_LOGD(TAG, "Scheduled command %d for %lds - value: %d", me->recipe_commands.controls[me->curr_command], time_command, me->recipe_commands.values[me->curr_command]);
                QTimeEvt_armX(&me->recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
            }
            */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_roasting);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::roasting::manual_roasting} ...*/
static QState DataBroker_manual_roasting(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::manual_roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_ROASTING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::manual_roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::roasting::manual_roasting::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_cooling);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_roasting);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::cooling} .....................*/
static QState DataBroker_cooling(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::cooling} */
        case Q_ENTRY_SIG: {
            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->curr_roast.time_start;

            int count = me->curr_roast.sensor_data.grao.count;

            if(count > 0)
                storage_add_roast_cooler_record(time_elapsed, me->curr_roast.sensor_data.grao.temps[count-1]);
            else
                storage_add_roast_cooler_record(time_elapsed, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::SENSOR_UPDATE} */
        case SENSOR_UPDATE_SIG: {
            SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);
            SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
            sensorDataEv->type = sensorEv->type;
            sensorDataEv->value = sensorEv->value;
            sensorDataEv->delta = 0;
            QACTIVE_POST(AO_Ihm, sensorDataEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
            QACTIVE_POST(AO_Ihm, contEv, me);

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->curr_roast.time_start;
            storage_add_roast_control_record(time_elapsed, contEv->control, contEv->value);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_active_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::cooling::auto_cooling} .......*/
static QState DataBroker_auto_cooling(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::auto_cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_COOLING][ENTRY]");


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::auto_cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_COOLING][EXIT]");

            //QTimeEvt_disarm(&me->recipeTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::auto_cooling::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_auto_summary);
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::auto_cooling::DATA_RECIPE_TIMEOUT} */
        case DATA_RECIPE_TIMEOUT_SIG: {
            QTimeEvt_disarm(&me->recipeTimerEvt);
            /*
            ControlType control = me->recipe_commands.controls[me->curr_command];
            int value = me->recipe_commands.values[me->curr_command];

            UpdateControlEvt *contEv = Q_NEW(UpdateControlEvt, UPDATE_CONTROL_SIG);
            contEv->control = control;
            contEv->value = value;
            QACTIVE_POST(AO_Perif, contEv, me);

            me->curr_command += 1;

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            time_t time_command = (me->recipe_commands.intervals[me->curr_command] - time_elapsed);

            if(time_command <= 0)
                time_command = 1;

            if(me->curr_command < me->recipe_commands.count) {
                ESP_LOGD(TAG, "Scheduled command %d for %lds - value: %d", me->recipe_commands.controls[me->curr_command], time_command, me->recipe_commands.values[me->curr_command]);
                QTimeEvt_armX(&me->recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
            }
            */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_cooling);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::cooling::manual_cooling} .....*/
static QState DataBroker_manual_cooling(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::manual_cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_COOLING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::manual_cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_COOLING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::cooling::manual_cooling::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_summary);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_cooling);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::summary} .....................*/
static QState DataBroker_summary(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::summary} */
        case Q_ENTRY_SIG: {
            //storage_get_current_roast_summary(&me->temps_ar, &me->temps_grao, &me->temps_count_ar, &me->temps_count_grao);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::summary::REQUEST_SUMMARY} */
        case REQUEST_SUMMARY_SIG: {
            RequestSummaryEvt *reqEv = Q_EVT_CAST(RequestSummaryEvt);

            ResponseSummaryEvt *resEv = Q_NEW(ResponseSummaryEvt, RESPONSE_SUMMARY_SIG);
            strcpy(resEv->name, me->curr_roast.name);

            QACTIVE_POST(AO_Ihm, resEv, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_active_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::summary::manual_summary} .....*/
static QState DataBroker_manual_summary(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::summary::manual_summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_SUMMARY][ENTRY]");


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::summary::manual_summary} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_SUMMARY][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::summary::manual_summary::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_pre_heating);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_summary);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::active_mode::summary::auto_summary} .......*/
static QState DataBroker_auto_summary(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::active_mode::summary::auto_summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_COOLING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::summary::auto_summary} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_COOLING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::active_mode::summary::auto_summary::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_auto_pre_heating);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_summary);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::state1::sensoring} ................................*/
static QState DataBroker_sensoring(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::state1::sensoring} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[MANUAL_MODE][MANUAL_IDLE][ENTRY]");

            DataBroker_resetData(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::sensoring} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[MANUAL_MODE][MANUAL_IDLE][EXIT]");

            /*
            DataBroker_sensorData.temps_grao_count = 0;
            DataBroker_sensorData.temps_ar_count = 0;
            DataBroker_sensorData.deltas_ar[0] = 0;
            DataBroker_sensorData.deltas_grao[0] = 0;
            */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::sensoring::SENSOR_UPDATE} */
        case SENSOR_UPDATE_SIG: {
            SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);

            SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
            sensorDataEv->type = sensorEv->type;
            sensorDataEv->value = sensorEv->value;
            sensorDataEv->delta = 0;
            QACTIVE_POST(AO_Ihm, sensorDataEv, me);

            DataBroker_updateSensorData(me, sensorEv->type, sensorEv->value, false);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::sensoring::REQUEST_MODE} */
        case REQUEST_MODE_SIG: {
            RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);
            /*${AOs::DataBroker::SM::state1::sensoring::REQUEST_MODE::[EXIT_MODE]} */
            if (rme->mode == MODE_NONE) {
                status_ = Q_TRAN(&DataBroker_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::DataBroker::SM::state1::sensoring::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_pre_heating);
            break;
        }
        /*${AOs::DataBroker::SM::state1::sensoring::CONTROL_UPDATE} */
        case CONTROL_UPDATE_SIG: {
            ControlUpdateEvt *contEv = Q_EVT_CAST(ControlUpdateEvt);
            QACTIVE_POST(AO_Perif, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::state1::sensoring::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
            QACTIVE_POST(AO_Ihm, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_state1);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::DataBroker} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${AOs::DataBroker_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::DataBroker_ctor} ..................................................*/
void DataBroker_ctor(void) {
    DataBroker *me = &l_dataBroker;

    QActive_ctor(&me->super, Q_STATE_CAST(&DataBroker_initial));
    QTimeEvt_ctorX(&me->recipeTimerEvt, &me->super, DATA_RECIPE_TIMEOUT_SIG, 0U);
}
/*$enddef${AOs::DataBroker_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
