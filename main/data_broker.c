/*$file${.::data_broker.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: fmw-torrador-v3.qm
* File:  ${.::data_broker.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::data_broker.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "common.h"
#include "esp_log.h"
#include <time.h>
#include <string.h>
#include "storage.h"

Q_DEFINE_THIS_FILE

static const char * TAG = "DATA_BROKER";

/*$declare${AOs::DataBroker} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::DataBroker} .......................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */
    time_t time_start;
    int pre_heat_value;
    int cooler_value;

/* private: */

/* public: */
    QTimeEvt recipeTimerEvt;

/* private: */
    RecipeCommands recipe_commands;
    int curr_command;
    ModeData curr_mode;
} DataBroker;

/* private: */
static void DataBroker_updateSensorData(DataBroker * const me,
    SensorType type,
    int value,
    SensorData * sensorData,
    bool enqueue);
static void DataBroker_setupRecipe(DataBroker * const me);
extern SensorData DataBroker_sensorData;
extern int DataBroker_aux_ar;
extern int DataBroker_aux_grao;

/* protected: */
static QState DataBroker_initial(DataBroker * const me, void const * const par);
static QState DataBroker_idle(DataBroker * const me, QEvt const * const e);
static QState DataBroker_active_mode(DataBroker * const me, QEvt const * const e);
static QState DataBroker_pre_heating(DataBroker * const me, QEvt const * const e);
static QState DataBroker_auto_pre_heating(DataBroker * const me, QEvt const * const e);
static QState DataBroker_manual_pre_heating(DataBroker * const me, QEvt const * const e);
static QState DataBroker_roasting(DataBroker * const me, QEvt const * const e);
static QState DataBroker_auto_roasting(DataBroker * const me, QEvt const * const e);
static QState DataBroker_manual_roasting(DataBroker * const me, QEvt const * const e);
static QState DataBroker_cooling(DataBroker * const me, QEvt const * const e);
static QState DataBroker_auto_cooling(DataBroker * const me, QEvt const * const e);
static QState DataBroker_manual_cooling(DataBroker * const me, QEvt const * const e);
static QState DataBroker_summary(DataBroker * const me, QEvt const * const e);
static QState DataBroker_manual_summary(DataBroker * const me, QEvt const * const e);
static QState DataBroker_auto_summary(DataBroker * const me, QEvt const * const e);
static QState DataBroker_sensoring(DataBroker * const me, QEvt const * const e);
/*$enddecl${AOs::DataBroker} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static DataBroker l_dataBroker; /* a única instância do AO IHM */

QActive * const AO_DataBroker = &l_dataBroker.super;

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${AOs::DataBroker} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::DataBroker} .......................................................*/
SensorData DataBroker_sensorData = {0};

int DataBroker_aux_ar  = 0;

int DataBroker_aux_grao  = 0;


/*${AOs::DataBroker::updateSensorData} .....................................*/
static void DataBroker_updateSensorData(DataBroker * const me,
    SensorType type,
    int value,
    SensorData * sensorData,
    bool enqueue)
{
    if(value > sensorData->max_temp) {
       sensorData->max_temp = value;
    } else if(value < sensorData->min_temp) {
        sensorData->min_temp = value;
    }

    if(type == SENSOR_GRAO && sensorData->temps_grao_count > 0) {
        int value_cmp = (value - sensorData->deltas_grao[sensorData->temps_grao_count-1])*10;

        if(value_cmp > sensorData->max_temp_delta) {
            sensorData->max_temp_delta = value_cmp;
        } else if(value_cmp < sensorData->min_temp_delta) {
            sensorData->min_temp_delta = value_cmp;
        }
    } else if(type == SENSOR_AR && sensorData->temps_ar_count > 0) {
        int value_cmp = (value - sensorData->deltas_ar[sensorData->temps_ar_count-1])*10;

        if(value_cmp > sensorData->max_temp_delta) {
            sensorData->max_temp_delta = value_cmp;
        } else if(value_cmp < sensorData->min_temp_delta) {
            sensorData->min_temp_delta = value_cmp;
        }
    }

    if(!enqueue) {
        if(type == SENSOR_GRAO) {
            sensorData->temps_grao[0] = value;
            sensorData->deltas_grao[0] = 0;

            sensorData->temps_grao_count = 1;
        } else if(type == SENSOR_AR) {
            sensorData->temps_ar[0] = value;
            sensorData->deltas_ar[0] = 0;

            sensorData->temps_ar_count = 1;
        }
    } else {
        if(type == SENSOR_GRAO) {
            if(sensorData->temps_grao_count < 31) {
                int new_count = sensorData->temps_grao_count + 1;
                sensorData->temps_grao_count = new_count;
                sensorData->temps_grao[new_count-1] = value;

                if(sensorData->temps_grao_count > 1) {
                    sensorData->deltas_grao[new_count-1] = value - sensorData->temps_grao[new_count-2];
                } else if(sensorData->temps_grao_count == 1) {
                    sensorData->deltas_grao[0] = 0;
                }
            } else {
                sensorData->temps_grao[DataBroker_aux_grao] = (sensorData->temps_grao[DataBroker_aux_grao] + sensorData->temps_grao[DataBroker_aux_grao+1]) / 2;
                sensorData->deltas_grao[DataBroker_aux_grao] = (sensorData->deltas_grao[DataBroker_aux_grao] + sensorData->deltas_grao[DataBroker_aux_grao+1]) / 2;
                for(int i=DataBroker_aux_grao+1; i < 30; i++) {
                    sensorData->temps_grao[i] = sensorData->temps_grao[i+1];
                    sensorData->deltas_grao[i] = sensorData->deltas_grao[i+1];
                }
                sensorData->temps_grao[30] = value;
                sensorData->deltas_grao[30] = value - sensorData->temps_grao[29];

                DataBroker_aux_grao++;
                DataBroker_aux_grao = DataBroker_aux_grao % 25;
            }
        } else if(type == SENSOR_AR) {
            if(sensorData->temps_ar_count < 31) {
                int new_count = sensorData->temps_ar_count + 1;
                sensorData->temps_ar_count = new_count;
                sensorData->temps_ar[new_count-1] = value;

                if(sensorData->temps_ar_count > 1) {
                    sensorData->deltas_ar[new_count-1] = value - sensorData->temps_ar[new_count-2];
                } else if(sensorData->temps_ar_count == 1) {
                    sensorData->deltas_ar[0] = 0;
                }
            } else {
                sensorData->temps_ar[DataBroker_aux_ar] = (sensorData->temps_ar[DataBroker_aux_ar] + sensorData->temps_ar[DataBroker_aux_ar+1]) / 2;
                sensorData->deltas_ar[DataBroker_aux_ar] = (sensorData->deltas_ar[DataBroker_aux_ar] + sensorData->deltas_ar[DataBroker_aux_ar+1]) / 2;
                for(int i=DataBroker_aux_ar+1; i < 30; i++) {
                    sensorData->temps_ar[i] = sensorData->temps_ar[i+1];
                    sensorData->deltas_ar[i] = sensorData->deltas_ar[i+1];
                }
                sensorData->temps_ar[30] = value;
                sensorData->deltas_ar[30] = value - sensorData->temps_ar[29];

                DataBroker_aux_ar++;
                DataBroker_aux_ar = DataBroker_aux_ar % 25;
            }
        }
    }
}

/*${AOs::DataBroker::setupRecipe} ..........................................*/
static void DataBroker_setupRecipe(DataBroker * const me) {
    me->recipe_commands = (RecipeCommands){
        .intervals = {0},
        .controls = {0},
        .values = {0},
        .count = 0,
    };
    me->curr_command = 0;
    storage_get_recipe_commands(me->curr_mode.roast, &me->recipe_commands);
}

/*${AOs::DataBroker::SM} ...................................................*/
static QState DataBroker_initial(DataBroker * const me, void const * const par) {
    /*${AOs::DataBroker::SM::initial} */
    return Q_TRAN(&DataBroker_idle);
}

/*${AOs::DataBroker::SM::idle} .............................................*/
static QState DataBroker_idle(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[IDLE][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::idle} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[IDLE][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::idle::REQUEST_RECIPES} */
        case REQUEST_RECIPES_SIG: {
            RequestRecipesEvt *recipesEvt = Q_EVT_CAST(RequestRecipesEvt);
            uint8_t pageNum = recipesEvt->pageNum;

            RecipesResponse res = {0};
            int ret = storage_get_recipes_page(pageNum, &res);

            if(ret != -1) {
                uint8_t resPageNum = res.pageNum;
                char roast1[25];
                strcpy(roast1, res.roast1);
                char roast2[25];
                strcpy(roast2, res.roast2);
                char roast3[25];
                strcpy(roast3, res.roast3);

                bool prevPage = res.prevPage;
                bool nextPage = res.nextPage;

                ResponseRecipesEvt *rre = Q_NEW(ResponseRecipesEvt, RESPONSE_RECIPES_SIG);
                rre->pageNum = res.pageNum;
                strcpy(rre->roast1, res.roast1);
                strcpy(rre->roast2, res.roast2);
                strcpy(rre->roast3, res.roast3);
                rre->prevPage = res.prevPage;
                rre->nextPage = res.nextPage;

                QACTIVE_POST(AO_Ihm, &rre->super, me);
            } else {
                ESP_LOGE(TAG, "Algo deu errado ao buscar as receitas");
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::idle::REQUEST_RECIPE} */
        case REQUEST_RECIPE_SIG: {
            RequestRecipeEvt *reqEvt = Q_EVT_CAST(RequestRecipeEvt);
            char *roast = reqEvt->roast;

            SensorData sensorData = {0};
            RoastResponse res = {0};
            res.sensorData = &sensorData;

            int ret = storage_get_roast(roast, &res);

            if(ret != -1) {
                ResponseRecipeEvt *rre = Q_NEW(ResponseRecipeEvt, RESPONSE_RECIPE_SIG);
                strcpy(rre->roast, res.roast);
                rre->sensorData = res.sensorData;

                QACTIVE_POST(AO_Ihm, &rre->super, me);
            } else {
                ESP_LOGE(TAG, "Algo deu errado ao buscar a receita %s", roast);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::idle::REQUEST_MODE} */
        case REQUEST_MODE_SIG: {
            RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);
            /*${AOs::DataBroker::SM::idle::REQUEST_MODE::[MODE_MANUAL]} */
            if (rme->mode == MODE_MANUAL) {
                NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme->mode = MODE_MANUAL;
                strcpy(nme->roast,"");
                QACTIVE_POST(AO_Perif, &nme->super, me);

                NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme2->mode = MODE_MANUAL;
                strcpy(nme2->roast,"");
                QACTIVE_POST(AO_Ihm, &nme2->super, me);

                me->curr_mode.mode = MODE_MANUAL;
                strcpy(me->curr_mode.roast, rme->roast);
                status_ = Q_TRAN(&DataBroker_sensoring);
            }
            /*${AOs::DataBroker::SM::idle::REQUEST_MODE::[MODE_AUTO]} */
            else if (rme->mode == MODE_AUTO) {
                NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme->mode = MODE_AUTO;
                strcpy(nme->roast, rme->roast);
                QACTIVE_POST(AO_Perif, &nme->super, me);

                NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme2->mode = MODE_AUTO;
                strcpy(nme2->roast,rme->roast);
                QACTIVE_POST(AO_Ihm, &nme2->super, me);

                me->curr_mode.mode = MODE_AUTO;
                strcpy(me->curr_mode.roast, rme->roast);
                status_ = Q_TRAN(&DataBroker_auto_pre_heating);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::DataBroker::SM::idle::REQUEST_ROASTS} */
        case REQUEST_ROASTS_SIG: {
            RequestRoastsEvt *roastsEvt = Q_EVT_CAST(RequestRoastsEvt);
            uint8_t pageNum = roastsEvt->pageNum;

            RoastsResponse res = {0};
            int ret = storage_get_roasts_page(pageNum, &res);

            if(ret != -1) {
                uint8_t resPageNum = res.pageNum;
                char roast1[25];
                strcpy(roast1, res.roast1);
                char roast2[25];
                strcpy(roast2, res.roast2);
                char roast3[25];
                strcpy(roast3, res.roast3);

                bool prevPage = res.prevPage;
                bool nextPage = res.nextPage;

                ResponseRoastsEvt *rre = Q_NEW(ResponseRoastsEvt, RESPONSE_ROASTS_SIG);
                rre->pageNum = res.pageNum;
                strcpy(rre->roast1, res.roast1);
                strcpy(rre->roast2, res.roast2);
                strcpy(rre->roast3, res.roast3);
                rre->prevPage = res.prevPage;
                rre->nextPage = res.nextPage;

                QACTIVE_POST(AO_Ihm, &rre->super, me);
            } else {
                ESP_LOGE(TAG, "Algo deu errado ao buscar as torras");
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::idle::REQUEST_ROAST} */
        case REQUEST_ROAST_SIG: {
            RequestRoastEvt *reqEvt = Q_EVT_CAST(RequestRoastEvt);
            char *roast = reqEvt->roast;

            SensorData sensorData = {0};
            RoastResponse res = {0};
            res.sensorData = &sensorData;

            int ret = storage_get_roast(roast, &res);

            if(ret != -1) {
                ResponseRoastEvt *rre = Q_NEW(ResponseRoastEvt, RESPONSE_ROAST_SIG);
                strcpy(rre->roast, res.roast);
                rre->sensorData = res.sensorData;

                QACTIVE_POST(AO_Ihm, &rre->super, me);
            } else {
                ESP_LOGE(TAG, "Algo deu errado ao buscar a torra %s", roast);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::idle::REQUEST_TRANSFORM_ROAST} */
        case REQUEST_TRANSFORM_ROAST_SIG: {
            RequestTransformRoastEvt *rtr = Q_EVT_CAST(RequestTransformRoastEvt);

            char roast[25];
            strcpy(roast, rtr->roast);

            storage_transform_roast(roast);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode} ......................................*/
static QState DataBroker_active_mode(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][ENTRY]");

            me->pre_heat_value = 0;
            me->cooler_value = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::UPDATE_CONTROL} */
        case UPDATE_CONTROL_SIG: {
            UpdateControlEvt *contEv = Q_EVT_CAST(UpdateControlEvt);
            QACTIVE_POST(AO_Perif, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
            QACTIVE_POST(AO_Ihm, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::REQUEST_MODE} */
        case REQUEST_MODE_SIG: {
            RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);
            /*${AOs::DataBroker::SM::active_mode::REQUEST_MODE::[rme->mode==MODE_NONE]} */
            if (rme->mode == MODE_NONE) {
                NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme->mode = MODE_NONE;
                strcpy(nme->roast,"");
                QACTIVE_POST(AO_Perif, &nme->super, me);

                NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
                nme2->mode = MODE_NONE;
                strcpy(nme2->roast,"");
                QACTIVE_POST(AO_Ihm, &nme2->super, me);

                me->curr_mode.mode = MODE_NONE;
                strcpy(me->curr_mode.roast, rme->roast);
                status_ = Q_TRAN(&DataBroker_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::pre_heating} .........................*/
static QState DataBroker_pre_heating(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::pre_heating} */
        case Q_ENTRY_SIG: {
            storage_create_new_roast();
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::pre_heating::SENSOR_UPDATE} */
        case SENSOR_UPDATE_SIG: {
            SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);

            if(sensorEv->type == SENSOR_GRAO) {
                me->pre_heat_value = sensorEv->value;
            }

            /*
            DataBroker_updateSensorData(me, sensorEv->type, sensorEv->value, &DataBroker_sensorData, false);
            SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
            sensorDataEv->sensorData = &DataBroker_sensorData;
            sensorDataEv->type = sensorEv->type;

            QACTIVE_POST(AO_Ihm, sensorDataEv, me);
            */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::pre_heating::SENSOR_GAS_UPDATE} */
        case SENSOR_GAS_UPDATE_SIG: {
            SensorGasUpdateEvt *sensorEv = Q_EVT_CAST(SensorGasUpdateEvt);

            SensorGasDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_GAS_DATA_SIG);
            sensorDataEv->value = sensorEv->value;

            QACTIVE_POST(AO_Ihm, sensorDataEv, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_active_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::pre_heating::auto_pre_heating} .......*/
static QState DataBroker_auto_pre_heating(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::pre_heating::auto_pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_PRE_HEATING][ENTRY]");

            ESP_LOGE(TAG, "recipe: %s", me->curr_mode.roast);
            DataBroker_setupRecipe(me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::pre_heating::auto_pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::pre_heating::auto_pre_heating::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_auto_roasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_pre_heating);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::pre_heating::manual_pre_heating} .....*/
static QState DataBroker_manual_pre_heating(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::pre_heating::manual_pre_heating} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_PRE_HEATING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::pre_heating::manual_pre_heating} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_PRE_HEATING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::pre_heating::manual_pre_heati~::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_roasting);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_pre_heating);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::roasting} ............................*/
static QState DataBroker_roasting(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::roasting} */
        case Q_ENTRY_SIG: {
            time_t time_now;
            time(&time_now);

            me->time_start = time_now;

            storage_add_roast_pre_heat_record(0, me->pre_heat_value);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::roasting::SENSOR_UPDATE} */
        case SENSOR_UPDATE_SIG: {
            SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);

            if(sensorEv->type == SENSOR_GRAO) {
                me->cooler_value = sensorEv->value;
            }

            /*
            DataBroker_updateSensorData(me, sensorEv->type, sensorEv->value, &DataBroker_sensorData, true);
            SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
            sensorDataEv->sensorData = &DataBroker_sensorData;
            sensorDataEv->type = sensorEv->type;

            QACTIVE_POST(AO_Ihm, sensorDataEv, me);
            */

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            storage_add_roast_sensor_record(time_elapsed, sensorEv->type, sensorEv->value);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::roasting::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
            QACTIVE_POST(AO_Ihm, contEv, me);

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            storage_add_roast_control_record(time_elapsed, contEv->control, contEv->payload);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::roasting::SENSOR_GAS_UPDATE} */
        case SENSOR_GAS_UPDATE_SIG: {
            SensorGasUpdateEvt *sensorEv = Q_EVT_CAST(SensorGasUpdateEvt);

            SensorGasDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_GAS_DATA_SIG);
            sensorDataEv->value = sensorEv->value;

            QACTIVE_POST(AO_Ihm, sensorDataEv, me);

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            storage_add_roast_gas_record(time_elapsed, sensorEv->value);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_active_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::roasting::auto_roasting} .............*/
static QState DataBroker_auto_roasting(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::roasting::auto_roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_ROASTING][ENTRY]");



            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            time_t time_command = (me->recipe_commands.intervals[me->curr_command] - time_elapsed);

            if(time_command <= 0)
                time_command = 1;

            if(me->curr_command < me->recipe_commands.count) {
                ESP_LOGD(TAG, "Scheduled command %d for %lds - value: %d", me->recipe_commands.controls[me->curr_command], time_command, me->recipe_commands.values[me->curr_command]);
                QTimeEvt_armX(&me->recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::roasting::auto_roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::roasting::auto_roasting::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_auto_cooling);
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::roasting::auto_roasting::DATA_RECIPE_TIMEOUT} */
        case DATA_RECIPE_TIMEOUT_SIG: {
            QTimeEvt_disarm(&me->recipeTimerEvt);

            ControlType control = me->recipe_commands.controls[me->curr_command];
            int value = me->recipe_commands.values[me->curr_command];

            UpdateControlEvt *contEv = Q_NEW(UpdateControlEvt, UPDATE_CONTROL_SIG);
            contEv->control = control;
            contEv->value = value;
            QACTIVE_POST(AO_Perif, contEv, me);

            /*
            ControlDataEvt *contEv2 = Q_EVT_CAST(ControlDataEvt);
            contEv2->control = control;
            contEv2->value = value;
            QACTIVE_POST(AO_Ihm, contEv, me);
            */

            me->curr_command += 1;

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            time_t time_command = (me->recipe_commands.intervals[me->curr_command] - time_elapsed);

            if(time_command <= 0)
                time_command = 1;

            if(me->curr_command < me->recipe_commands.count) {
                ESP_LOGD(TAG, "Scheduled command %d for %lds - value: %d", me->recipe_commands.controls[me->curr_command], time_command, me->recipe_commands.values[me->curr_command]);
                QTimeEvt_armX(&me->recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_roasting);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::roasting::manual_roasting} ...........*/
static QState DataBroker_manual_roasting(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::roasting::manual_roasting} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_ROASTING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::roasting::manual_roasting} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_ROASTING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::roasting::manual_roasting::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_cooling);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_roasting);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::cooling} .............................*/
static QState DataBroker_cooling(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::cooling} */
        case Q_ENTRY_SIG: {
            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            storage_add_roast_cooler_record(time_elapsed, me->cooler_value);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::cooling::SENSOR_UPDATE} */
        case SENSOR_UPDATE_SIG: {
            SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);

            /*
            DataBroker_updateSensorData(me, sensorEv->type, sensorEv->value, &DataBroker_sensorData, true);
            SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
            sensorDataEv->sensorData = &DataBroker_sensorData;
            sensorDataEv->type = sensorEv->type;

            QACTIVE_POST(AO_Ihm, sensorDataEv, me);
            */

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            storage_add_roast_sensor_record(time_elapsed, sensorEv->type, sensorEv->value);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::cooling::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
            QACTIVE_POST(AO_Ihm, contEv, me);

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            storage_add_roast_control_record(time_elapsed, contEv->control, contEv->payload);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_active_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::cooling::auto_cooling} ...............*/
static QState DataBroker_auto_cooling(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::cooling::auto_cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_COOLING][ENTRY]");




            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::cooling::auto_cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_COOLING][EXIT]");

            QTimeEvt_disarm(&me->recipeTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::cooling::auto_cooling::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_auto_summary);
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::cooling::auto_cooling::DATA_RECIPE_TIMEOUT} */
        case DATA_RECIPE_TIMEOUT_SIG: {
            QTimeEvt_disarm(&me->recipeTimerEvt);

            ControlType control = me->recipe_commands.controls[me->curr_command];
            int value = me->recipe_commands.values[me->curr_command];

            UpdateControlEvt *contEv = Q_NEW(UpdateControlEvt, UPDATE_CONTROL_SIG);
            contEv->control = control;
            contEv->value = value;
            QACTIVE_POST(AO_Perif, contEv, me);

            me->curr_command += 1;

            time_t time_now;
            time(&time_now);

            time_t time_elapsed = time_now - me->time_start;
            time_t time_command = (me->recipe_commands.intervals[me->curr_command] - time_elapsed);

            if(time_command <= 0)
                time_command = 1;

            if(me->curr_command < me->recipe_commands.count) {
                ESP_LOGD(TAG, "Scheduled command %d for %lds - value: %d", me->recipe_commands.controls[me->curr_command], time_command, me->recipe_commands.values[me->curr_command]);
                QTimeEvt_armX(&me->recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_cooling);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::cooling::manual_cooling} .............*/
static QState DataBroker_manual_cooling(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::cooling::manual_cooling} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_COOLING][ENTRY]");


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::cooling::manual_cooling} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_COOLING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::cooling::manual_cooling::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_summary);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_cooling);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::summary} .............................*/
static QState DataBroker_summary(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::summary} */
        case Q_ENTRY_SIG: {
            //storage_get_current_roast_summary(&me->temps_ar, &me->temps_grao, &me->temps_count_ar, &me->temps_count_grao);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_active_mode);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::summary::manual_summary} .............*/
static QState DataBroker_manual_summary(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::summary::manual_summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_SUMMARY][ENTRY]");


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::summary::manual_summary} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][MANUAL_SUMMARY][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::summary::manual_summary::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_pre_heating);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_summary);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::active_mode::summary::auto_summary} ...............*/
static QState DataBroker_auto_summary(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::active_mode::summary::auto_summary} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_COOLING][ENTRY]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::summary::auto_summary} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[ACTIVE_MODE][AUTO_COOLING][EXIT]");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::active_mode::summary::auto_summary::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = true;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_auto_pre_heating);
            break;
        }
        default: {
            status_ = Q_SUPER(&DataBroker_summary);
            break;
        }
    }
    return status_;
}

/*${AOs::DataBroker::SM::sensoring} ........................................*/
static QState DataBroker_sensoring(DataBroker * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::DataBroker::SM::sensoring} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "[MANUAL_MODE][MANUAL_IDLE][ENTRY]");


            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::sensoring} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "[MANUAL_MODE][MANUAL_IDLE][EXIT]");

            DataBroker_sensorData.temps_grao_count = 0;
            DataBroker_sensorData.temps_ar_count = 0;
            DataBroker_sensorData.deltas_ar[0] = 0;
            DataBroker_sensorData.deltas_grao[0] = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::sensoring::SENSOR_UPDATE} */
        case SENSOR_UPDATE_SIG: {
            SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);

            DataBroker_updateSensorData(me, sensorEv->type, sensorEv->value, &DataBroker_sensorData, false);

            /*
            SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
            sensorDataEv->sensorData = &DataBroker_sensorData;
            sensorDataEv->type = sensorEv->type;

            QACTIVE_POST(AO_Ihm, sensorDataEv, me);

            */
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::sensoring::REQUEST_MODE} */
        case REQUEST_MODE_SIG: {
            RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);
            /*${AOs::DataBroker::SM::sensoring::REQUEST_MODE::[EXIT_MODE]} */
            if (rme->mode == MODE_NONE) {
                status_ = Q_TRAN(&DataBroker_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*${AOs::DataBroker::SM::sensoring::REQUEST_NEXT_STAGE} */
        case REQUEST_NEXT_STAGE_SIG: {
            NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Ihm, &stageEv->super, me);

            NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
            stageEv->auto_mode = false;
            QACTIVE_POST(AO_Perif, &stageEv2->super, me);
            status_ = Q_TRAN(&DataBroker_manual_pre_heating);
            break;
        }
        /*${AOs::DataBroker::SM::sensoring::UPDATE_CONTROL} */
        case UPDATE_CONTROL_SIG: {
            UpdateControlEvt *contEv = Q_EVT_CAST(UpdateControlEvt);
            QACTIVE_POST(AO_Perif, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::DataBroker::SM::sensoring::CONTROL_DATA} */
        case CONTROL_DATA_SIG: {
            ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
            QACTIVE_POST(AO_Ihm, contEv, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::DataBroker} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${AOs::DataBroker_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::DataBroker_ctor} ..................................................*/
void DataBroker_ctor(void) {
    DataBroker *me = &l_dataBroker;

    QActive_ctor(&me->super, Q_STATE_CAST(&DataBroker_initial));
    QTimeEvt_ctorX(&me->recipeTimerEvt, &me->super, DATA_RECIPE_TIMEOUT_SIG, 0U);
}
/*$enddef${AOs::DataBroker_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
