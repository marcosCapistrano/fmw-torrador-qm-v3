/*$file${.::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: fmw-torrador-v3.qm
* File:  ${.::bsp.c}
*
* This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$file${.::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
 * Model: fmw-torrador-v2.qm
 * File:  ${.::bsp.c}
 *
 * This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
 * DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * This generated code is open source software: you can redistribute it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * NOTE:
 * Alternatively, this generated code may be distributed under the terms
 * of Quantum Leaps commercial licenses, which expressly supersede the GNU
 * General Public License and are specifically designed for licensees
 * interested in retaining the proprietary status of their code.
 *
 * Contact information:
 * <www.state-machine.com/licensing>
 * <info@state-machine.com>
 */
/*$endhead${.::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$file${.::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
 * Model: fmw-torrador-v2.qm
 * File:  ${.::bsp.c}
 *
 * This code has been generated by QM 5.2.2 <www.state-machine.com/qm>.
 * DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * This generated code is open source software: you can redistribute it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * NOTE:
 * Alternatively, this generated code may be distributed under the terms
 * of Quantum Leaps commercial licenses, which expressly supersede the GNU
 * General Public License and are specifically designed for licensees
 * interested in retaining the proprietary status of their code.
 *
 * Contact information:
 * <www.state-machine.com/licensing>
 * <info@state-machine.com>
 */
/*$endhead${.::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include <string.h>

#include "driver/adc.h"
#include "driver/ledc.h"
#include "driver/spi_master.h"
#include "esp_adc_cal.h"
#include "esp_freertos_hooks.h"
#include "esp_log.h"
#include "qf_port.h"
#include "qpc.h"

#define ADC1_EXAMPLE_CHAN0 ADC1_CHANNEL_6  // GPIO 25!!!!
#define ADC_EXAMPLE_ATTEN ADC_ATTEN_DB_11
#define ADC_EXAMPLE_CALI_SCHEME ESP_ADC_CAL_VAL_EFUSE_VREF

#define PIN_PWM_POTENCIA 33
#define PIN_PWM_CILINDRO 32
#define PIN_PWM_TURBINA 25

#define PIN_CILINDRO 4
#define PIN_CILINDRO_EN 21
#define PIN_RESFRIADOR 27

#define HOST VSPI_HOST

#define PIN_NUM_MISO 18
#define PIN_NUM_CLK 19
#define PIN_CS_AR 5
#define PIN_CS_GRAO 15

#define LEDC_MODE LEDC_HIGH_SPEED_MODE
#define LEDC_TIMER LEDC_TIMER_0

#define LEDC_POTENCIA_GPIO (PIN_PWM_POTENCIA)
#define LEDC_POTENCIA_CHANNEL LEDC_CHANNEL_0

#define LEDC_CILINDRO_GPIO (PIN_PWM_CILINDRO)
#define LEDC_CILINDRO_CHANNEL LEDC_CHANNEL_1

#define LEDC_TURBINA_GPIO (PIN_PWM_TURBINA)
#define LEDC_TURBINA_CHANNEL LEDC_CHANNEL_2

#define GPIO_OUTPUT_SEL ((1ULL << PIN_CILINDRO) | (1ULL << PIN_RESFRIADOR) | (1ULL << PIN_CILINDRO_EN))

Q_DEFINE_THIS_FILE

static const char* TAG = "bsp";

static bool is_cilindro_on = false;
static bool is_resfriador_on = false;

static esp_adc_cal_characteristics_t adc1_chars;
static spi_device_handle_t sensor_ar;
static spi_device_handle_t sensor_grao;

void cilindro_set_on(bool on);
void resfriador_set_on(bool on);

int_t qf_run_active = 0;

static IRAM_ATTR void freertos_tick_hook(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    if (qf_run_active != 0) {
        /* process time events for rate 0 */
        QTIMEEVT_TICK_FROM_ISR(0U, &xHigherPriorityTaskWoken, &freertos_tick_hook);
        /* notify FreeRTOS to perform context switch from ISR, if needed */
        if (xHigherPriorityTaskWoken) {
            portYIELD_FROM_ISR();
        }
    }
}

void QF_onStartup(void) {
    esp_register_freertos_tick_hook_for_cpu(freertos_tick_hook, QPC_CPU_NUM);

    /* enable QF ticks from tick hook */
    qf_run_active = 100;

    ESP_LOGI(TAG, "QF started.");

    /* Note: Additional hook stuff can be placed here */
}

IRAM_ATTR void Q_onAssert(char_t const* const module, int_t location) {
    // ESP_LOGE(TAG, "Q_onAssert: module:%s loc:%d\n", module, location);
}

static bool adc_calibration_init(void) {
    esp_err_t ret;
    bool cali_enable = false;

    ret = esp_adc_cal_check_efuse(ADC_EXAMPLE_CALI_SCHEME);
    if (ret == ESP_ERR_NOT_SUPPORTED) {
        ESP_LOGW(TAG, "Calibration scheme not supported, skip software calibration");
    } else if (ret == ESP_ERR_INVALID_VERSION) {
        ESP_LOGW(TAG, "eFuse not burnt, skip software calibration");
    } else if (ret == ESP_OK) {
        cali_enable = true;
        esp_adc_cal_characterize(ADC_UNIT_1, ADC_EXAMPLE_ATTEN, ADC_WIDTH_BIT_DEFAULT, 0, &adc1_chars);
    } else {
        ESP_LOGE(TAG, "Invalid arg");
    }

    return cali_enable;
}

void setup_peripherals() {
    ledc_timer_config_t ledc_timer = {
        .duty_resolution = LEDC_TIMER_13_BIT,  // resolution of PWM duty
        .freq_hz = 5000,                       // frequency of PWM signal
        .speed_mode = LEDC_MODE,               // timer mode
        .timer_num = LEDC_TIMER,               // timer index
        .clk_cfg = LEDC_AUTO_CLK,              // Auto select the source clock
    };

    ledc_timer_config(&ledc_timer);

    /*
     * Prepare individual configuration
     * for each channel of LED Controller
     * by selecting:
     * - controller's channel number
     * - output duty cycle, set initially to 0
     * - GPIO number where LED is connected to
     * - speed mode, either high or low
     * - timer servicing selected channel
     *   Note: if different channels use one timer,
     *         then frequency and bit_num of these channels
     *         will be the same
     */

    ledc_channel_config_t ledc_channel[3] = {
        {.gpio_num = LEDC_POTENCIA_GPIO,
         .speed_mode = LEDC_MODE,
         .channel = LEDC_POTENCIA_CHANNEL,
         .timer_sel = LEDC_TIMER,
         .duty = 0,
         .hpoint = 0,
         .flags.output_invert = 0},
        {.gpio_num = LEDC_CILINDRO_GPIO,
         .speed_mode = LEDC_MODE,
         .channel = LEDC_CILINDRO_CHANNEL,
         .timer_sel = LEDC_TIMER,
         .duty = 0,
         .hpoint = 0,
         .flags.output_invert = 1},
        {.gpio_num = LEDC_TURBINA_GPIO,
         .speed_mode = LEDC_MODE,
         .channel = LEDC_TURBINA_CHANNEL,
         .timer_sel = LEDC_TIMER,
         .duty = 0,
         .hpoint = 0,
         .flags.output_invert = 1},
    };

    ledc_channel_config(&ledc_channel[0]);  // Potencia
    ledc_channel_config(&ledc_channel[1]);  // Cilindro
    ledc_channel_config(&ledc_channel[2]);  // Turbina

    spi_bus_config_t bus_cfg = {
        .miso_io_num = PIN_NUM_MISO,
        .mosi_io_num = -1,
        .sclk_io_num = PIN_NUM_CLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = (4 * 8),
    };

    esp_err_t ret = spi_bus_initialize(HOST, &bus_cfg, SPI_DMA_CH2);
    ESP_ERROR_CHECK(ret);

    spi_device_interface_config_t dev_cfg = {
        .mode = 1,
        .clock_speed_hz = 2 * 1000 * 1000,
        .spics_io_num = PIN_CS_AR,
        .queue_size = 1,
    };

    ret = spi_bus_add_device(HOST, &dev_cfg, &sensor_ar);
    ESP_ERROR_CHECK(ret);

    spi_device_interface_config_t dev_cfg2 = {
        .mode = 1,
        .clock_speed_hz = 2 * 1000 * 1000,
        .spics_io_num = PIN_CS_GRAO,
        .queue_size = 1,
    };
    ret = spi_bus_add_device(HOST, &dev_cfg2, &sensor_grao);
    ESP_ERROR_CHECK(ret);

    gpio_config_t io_conf = {};
    io_conf.intr_type = GPIO_INTR_DISABLE;
    io_conf.mode = GPIO_MODE_OUTPUT;
    io_conf.pin_bit_mask = GPIO_OUTPUT_SEL;
    io_conf.pull_down_en = 0;
    io_conf.pull_up_en = 0;
    gpio_config(&io_conf);

    adc_calibration_init();

    ESP_ERROR_CHECK(adc1_config_width(ADC_WIDTH_BIT_DEFAULT));
    ESP_ERROR_CHECK(adc1_config_channel_atten(ADC1_EXAMPLE_CHAN0, ADC_EXAMPLE_ATTEN));

    cilindro_set_on(false);
    resfriador_set_on(false);
}

static uint32_t percentage_to_duty(int value) {
    const uint32_t in_min = 0, out_min = 0;
    const uint32_t in_max = 100, out_max = 8191;

    if (value < 0)
        value = 0;
    else if (value > 100)
        value = 100;

    uint32_t duty = (uint32_t)value;
    return (duty - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void cilindro_set_on(bool on) {
    if (on) {
        gpio_set_level(PIN_CILINDRO, 1);
        gpio_set_level(PIN_CILINDRO_EN, 1);
        is_cilindro_on = true;
    } else {
        gpio_set_level(PIN_CILINDRO, 0);
        gpio_set_level(PIN_CILINDRO_EN, 0);
        is_cilindro_on = false;
    }
}

bool get_resfriador_state() {
    return is_resfriador_on;
}

void resfriador_set_on(bool on) {
    if (on) {
        gpio_set_level(PIN_RESFRIADOR, 0);
        is_resfriador_on = true;
    } else {
        gpio_set_level(PIN_RESFRIADOR, 1);
        is_resfriador_on = false;
    }
}

void potencia_set_duty(int value) {
    ESP_LOGD(TAG, "[POTÊNCIA DUTY]: %d", value);
    uint32_t duty = percentage_to_duty(value);

    ledc_set_duty(LEDC_MODE, LEDC_POTENCIA_CHANNEL, duty);
    ledc_update_duty(LEDC_MODE, LEDC_POTENCIA_CHANNEL);
}

void cilindro_set_duty(int value) {
    ESP_LOGD(TAG, "[CILINDRO DUTY]: %d", value);
    uint32_t duty = percentage_to_duty(value);

    if (value > 0 && !is_cilindro_on) {
        cilindro_set_on(true);
        ESP_LOGD(TAG, "[CILINDRO]: ON");
    } else if (value == 0 && is_cilindro_on) {
        cilindro_set_on(false);
        ESP_LOGD(TAG, "[CILINDRO]: OFF");
    }

    ledc_set_duty(LEDC_MODE, LEDC_CILINDRO_CHANNEL, duty);
    ledc_update_duty(LEDC_MODE, LEDC_CILINDRO_CHANNEL);
}

void turbina_set_duty(int value) {
    ESP_LOGD(TAG, "[TURBINA DUTY]: %d", value);
    uint32_t duty = percentage_to_duty(value);

    ledc_set_duty(LEDC_MODE, LEDC_TURBINA_CHANNEL, duty);
    ledc_update_duty(LEDC_MODE, LEDC_TURBINA_CHANNEL);
}

float sample_sensor(spi_device_handle_t* dev) {
    uint16_t data;
    spi_transaction_t trans = {
        .tx_buffer = NULL,
        .rx_buffer = &data,
        .length = 16,
        .rxlength = 16,
    };

    esp_err_t ret = spi_device_polling_transmit(*dev, &trans);
    // ESP_ERROR_CHECK(ret);

    int16_t res = (int16_t)SPI_SWAP_DATA_RX(data, 16);

    if (res & (1 << 2)) {
        // ESP_LOGE("oi", "Sensor is not connected\n");
        return 0;
    } else {
        res >>= 3;
        // printf("SPI res = %d temp=%f\n", res, res * 0.25);
        return (res * 0.25);
    }

    return 0;
}

int sample_sensor_ar() {
    float temperature = 0;

    temperature = sample_sensor(&sensor_ar);
    // if (temperature == 0)
    //     ESP_LOGE(TAG, "Algo errado AR");
    // else
    //     ESP_LOGE(TAG, "Temp ar: %f", temperature);

    if (temperature < 0) temperature = 0;
    return temperature;
}

int sample_sensor_grao() {
    float temperature = 0;

    temperature = sample_sensor(&sensor_grao);
    if (temperature == 0)
        ESP_LOGE(TAG, "Algo errado GRAO");
    else
        ESP_LOGE(TAG, "Temp grao: %f", temperature);

    if (temperature < 0) temperature = 0;
    return temperature;
}

int sample_sensor_gas() {
    int adc_raw = 0;

    for (int i = 0; i < 24; i++) {
        adc_raw += adc1_get_raw(ADC1_EXAMPLE_CHAN0);
    }

    return adc_raw / 24;
}

