<?xml version="1.0" encoding="UTF-8"?>
<model version="5.2.2" links="0">
 <framework name="qpc"/>
 <package name="AOs" stereotype="0x02">
  <class name="Perif" superclass="qpc::QActive">
   <attribute name="sensorTimeEvt" type="QTimeEvt" visibility="0x00" properties="0x00"/>
   <attribute name="realCil" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="wantedCil" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="pwmTimeEvt" type="QTimeEvt" visibility="0x00" properties="0x00"/>
   <statechart properties="0x00">
    <initial target="../2">
     <action>me-&gt;realCil = 0;
cilindro_set_duty(0);</action>
     <initial_glyph conn="6,5,5,0,17,12">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="sensoring">
     <entry>ESP_LOGI(TAG, &quot;[SENSORING][ENTRY]&quot;);

QTimeEvt_armX(&amp;me-&gt;sensorTimeEvt, SENSOR_INTERVAL, 0U);</entry>
     <exit>ESP_LOGI(TAG, &quot;[SENSORING][EXIT]&quot;);</exit>
     <tran trig="SENSOR_TIMEOUT">
      <action>int temp_ar = sample_sensor_ar();
int gas = sample_sensor_gas();
int temp_grao = sample_sensor_grao();

//ESP_LOGE(TAG, &quot;gas here: %d&quot;, gas);

SensorUpdateEvt *sde_gr;
sde_gr = Q_NEW(SensorUpdateEvt, SENSOR_UPDATE_SIG);
sde_gr-&gt;type = SENSOR_GRAO;
sde_gr-&gt;value = temp_grao;
QACTIVE_POST(AO_DataBroker, &amp;sde_gr-&gt;super, me);

SensorUpdateEvt *sde_ar;
sde_ar = Q_NEW(SensorUpdateEvt, SENSOR_UPDATE_SIG);
sde_ar-&gt;type = SENSOR_AR;
sde_ar-&gt;value = temp_ar;
QACTIVE_POST(AO_DataBroker, &amp;sde_ar-&gt;super, me);

SensorUpdateEvt *sde_gas;
sde_gas = Q_NEW(SensorUpdateEvt, SENSOR_UPDATE_SIG);
sde_gas-&gt;type = SENSOR_GAS;
sde_gas-&gt;value = gas;
QACTIVE_POST(AO_DataBroker, &amp;sde_gas-&gt;super, me);

QTimeEvt_rearm(&amp;me-&gt;sensorTimeEvt, SENSOR_INTERVAL);</action>
      <tran_glyph conn="50,39,3,-1,17">
       <action box="0,-2,16,2"/>
      </tran_glyph>
     </tran>
     <tran trig="PWM_TIMEOUT">
      <action>if(abs(me-&gt;wantedCil - me-&gt;realCil) &gt; 5) {
    if(me-&gt;wantedCil &gt; me-&gt;realCil) {
        int newCil = me-&gt;realCil + 5;
        cilindro_set_duty(newCil);
        me-&gt;realCil = newCil;
        QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
    } else {
        int newCil = me-&gt;realCil - 5;
        cilindro_set_duty(newCil);
        me-&gt;realCil = newCil;
        QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
    }
} else if(me-&gt;realCil != me-&gt;wantedCil) {
    cilindro_set_duty(me-&gt;wantedCil);
    me-&gt;realCil = me-&gt;wantedCil;
}</action>
      <tran_glyph conn="50,42,3,-1,17">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <tran trig="CONTROL_UPDATE">
      <action>ControlUpdateEvt *evt = Q_EVT_CAST(ControlUpdateEvt);
ControlType type = evt-&gt;control;
int value = evt-&gt;value;

ESP_LOGD(TAG, &quot;Received command: %d - value: %d&quot;, type, value);

if(type == POTENCIA) {
    potencia_set_duty(value);
} else if(type == CILINDRO) {
    if(value &gt; 100) value = 100;
    else if(value &lt; 0) value = 0;

    me-&gt;wantedCil = value;
    QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
} else if(type == TURBINA) {
    turbina_set_duty(value);
} else if(type == RESFRIADOR) {
    resfriador_set_on(value);
}

ControlDataEvt *contEv;
contEv = Q_NEW(ControlDataEvt, CONTROL_DATA_SIG);
contEv-&gt;control = type;
contEv-&gt;value = value;
QACTIVE_POST(AO_DataBroker, &amp;contEv-&gt;super, me);
</action>
      <tran_glyph conn="50,36,3,-1,17">
       <action box="0,-2,18,2"/>
      </tran_glyph>
     </tran>
     <state name="pre_heating">
      <entry>ESP_LOGD(TAG, &quot;[SENSORING][PRE_HEAT][ENTRY]&quot;);</entry>
      <exit>ESP_LOGI(TAG, &quot;[SENSORING][PRE_HEAT][EXIT]&quot;);</exit>
      <tran trig="NOTIFY_NEXT_STAGE" target="../../4">
       <tran_glyph conn="70,30,1,3,3">
        <action box="-5,-6,20,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="57,27,13,6">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="roasting">
      <entry>ESP_LOGD(TAG, &quot;[SENSORING][ROASTING][ENTRY]&quot;);</entry>
      <exit>ESP_LOGD(TAG, &quot;[SENSORING][ROASTING][EXIT]&quot;);</exit>
      <tran trig="NOTIFY_NEXT_STAGE" target="../../../3">
       <tran_glyph conn="86,31,1,3,2,-3,19">
        <action box="0,-2,19,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="73,27,13,6">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="idle">
      <entry>ESP_LOGD(TAG, &quot;[SENSORING][IDLE][ENTRY]&quot;);</entry>
      <exit>ESP_LOGD(TAG, &quot;[SENSORING][IDLE][EXIT]&quot;);</exit>
      <tran trig="NOTIFY_NEXT_STAGE" target="../../3">
       <tran_glyph conn="62,25,2,0,2">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="57,19,13,6">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="50,15,37,30">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="off">
     <entry>ESP_LOGI(TAG, &quot;[OFF][ENTRY]&quot;);

const int newCil = 0;
const int newPot = 0;
const int newTurb = 0;

if(get_resfriador_state()) {
    resfriador_set_on(false);
}

potencia_set_duty(newPot);

ControlDataEvt *contEv = Q_NEW(ControlDataEvt, CONTROL_DATA_SIG);
contEv-&gt;control = POTENCIA;
contEv-&gt;value = newPot;
QACTIVE_POST(AO_DataBroker, &amp;contEv-&gt;super, me);

me-&gt;wantedCil = newCil;
ControlDataEvt *contEv2;
contEv = Q_NEW(ControlDataEvt, CONTROL_DATA_SIG);
contEv-&gt;control = CILINDRO;
contEv-&gt;value = newCil;
QACTIVE_POST(AO_DataBroker, &amp;contEv-&gt;super, me);

turbina_set_duty(newTurb);
ControlDataEvt *contEv3;
contEv = Q_NEW(ControlDataEvt, CONTROL_DATA_SIG);
contEv-&gt;control = TURBINA;
contEv-&gt;value = newTurb;
QACTIVE_POST(AO_DataBroker, &amp;contEv-&gt;super, me);

QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);</entry>
     <exit>ESP_LOGI(TAG, &quot;[OFF][EXIT]&quot;);</exit>
     <tran trig="PWM_TIMEOUT">
      <action>if(abs(me-&gt;wantedCil - me-&gt;realCil) &gt; 5) {
    if(me-&gt;wantedCil &gt; me-&gt;realCil) {
        int newCil = me-&gt;realCil + 5;
        cilindro_set_duty(newCil);
        me-&gt;realCil = newCil;
        QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
    } else {
        int newCil = me-&gt;realCil - 5;
        cilindro_set_duty(newCil);
        me-&gt;realCil = newCil;
        QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
    }
} else if(me-&gt;realCil != me-&gt;wantedCil) {
    cilindro_set_duty(me-&gt;wantedCil);
    me-&gt;realCil = me-&gt;wantedCil;
}</action>
      <tran_glyph conn="12,27,3,-1,16">
       <action box="0,-2,16,2"/>
      </tran_glyph>
     </tran>
     <tran trig="NOTIFY_MODE">
      <action>NotifyModeEvt *nme = Q_EVT_CAST(NotifyModeEvt); </action>
      <choice target="../../../1/3">
       <guard brief="MODE_ENTER">nme-&gt;mode == MODE_AUTO</guard>
       <choice_glyph conn="40,28,5,3,17">
        <action box="-5,1,16,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../1/5">
       <guard>nme-&gt;mode == MODE_MANUAL</guard>
       <choice_glyph conn="40,28,4,3,-6,17">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="31,28,1,-1,9">
       <action box="0,-4,16,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="12,17,19,27">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="cooling">
     <entry>ESP_LOGD(TAG, &quot;[COOLING][ENTRY]&quot;);

if(!get_resfriador_state()) {
    resfriador_set_on(true);
}</entry>
     <exit>ESP_LOGD(TAG, &quot;[COOLING][EXIT]&quot;);

QTimeEvt_disarm(&amp;me-&gt;sensorTimeEvt);</exit>
     <tran trig="NOTIFY_NEXT_STAGE" target="../../4">
      <tran_glyph conn="116,35,2,1,30,-37">
       <action box="-21,26,20,2"/>
      </tran_glyph>
     </tran>
     <tran trig="CONTROL_UPDATE">
      <action>ControlUpdateEvt *evt = Q_EVT_CAST(ControlUpdateEvt);
ControlType type = evt-&gt;control;
int value = evt-&gt;value;

ESP_LOGD(TAG, &quot;Received command: %d - value: %d&quot;, type, value);

if(type == POTENCIA) {
    potencia_set_duty(value);
} else if(type == CILINDRO) {
    if(value &gt; 100) value = 100;
    else if(value &lt; 0) value = 0;

    me-&gt;wantedCil = value;
    QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
} else if(type == TURBINA) {
    turbina_set_duty(value);
} else if(type == RESFRIADOR) {
    resfriador_set_on(value);
}

ControlDataEvt *contPot;
contPot = Q_NEW(ControlDataEvt, CONTROL_DATA_SIG);
contPot-&gt;control = type;
contPot-&gt;value = value;
QACTIVE_POST(AO_DataBroker, &amp;contPot-&gt;super, me);
</action>
      <tran_glyph conn="107,33,3,-1,16">
       <action box="1,-3,19,2"/>
      </tran_glyph>
     </tran>
     <tran trig="PWM_TIMEOUT">
      <action>if(abs(me-&gt;wantedCil - me-&gt;realCil) &gt; 5) {
    if(me-&gt;wantedCil &gt; me-&gt;realCil) {
        int newCil = me-&gt;realCil + 5;
        cilindro_set_duty(newCil);
        me-&gt;realCil = newCil;
        QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
    } else {
        int newCil = me-&gt;realCil - 5;
        cilindro_set_duty(newCil);
        me-&gt;realCil = newCil;
        QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
    }
} else if(me-&gt;realCil != me-&gt;wantedCil) {
    cilindro_set_duty(me-&gt;wantedCil);
    me-&gt;realCil = me-&gt;wantedCil;
}</action>
      <tran_glyph conn="107,29,3,-1,15">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="SENSOR_TIMEOUT">
      <action>int temp_ar = sample_sensor_ar();
int gas = sample_sensor_gas();
int temp_grao = sample_sensor_grao();

//ESP_LOGE(TAG, &quot;gas here: %d&quot;, gas);

SensorUpdateEvt *sde_gr;
sde_gr = Q_NEW(SensorUpdateEvt, SENSOR_UPDATE_SIG);
sde_gr-&gt;type = SENSOR_GRAO;
sde_gr-&gt;value = temp_grao;
QACTIVE_POST(AO_DataBroker, &amp;sde_gr-&gt;super, me);

SensorUpdateEvt *sde_ar;
sde_ar = Q_NEW(SensorUpdateEvt, SENSOR_UPDATE_SIG);
sde_ar-&gt;type = SENSOR_AR;
sde_ar-&gt;value = temp_ar;
QACTIVE_POST(AO_DataBroker, &amp;sde_ar-&gt;super, me);

SensorUpdateEvt *sde_gas;
sde_gas = Q_NEW(SensorUpdateEvt, SENSOR_UPDATE_SIG);
sde_gas-&gt;type = SENSOR_GAS;
sde_gas-&gt;value = temp_grao;
QACTIVE_POST(AO_DataBroker, &amp;sde_gas-&gt;super, me);

QTimeEvt_rearm(&amp;me-&gt;sensorTimeEvt, SENSOR_INTERVAL);</action>
      <tran_glyph conn="130,26,1,-1,-6">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="107,21,23,14">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="summary">
     <entry>ESP_LOGI(TAG, &quot;[SUMMARY][ENTRY]&quot;);</entry>
     <exit>ESP_LOGI(TAG, &quot;[SUMMARY][EXIT]&quot;);</exit>
     <tran trig="NOTIFY_NEXT_STAGE" target="../../1/3">
      <tran_glyph conn="70,59,0,2,-24,-2,-2">
       <action box="0,-8,21,2"/>
      </tran_glyph>
     </tran>
     <tran trig="NOTIFY_MODE">
      <action>NotifyModeEvt *nme = Q_EVT_CAST(NotifyModeEvt); </action>
      <choice target="../../../2">
       <guard brief="MODE_EXIT">nme-&gt;mode == MODE_NONE</guard>
       <choice_glyph conn="52,66,5,2,-32,-22">
        <action box="-16,-4,13,3"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="58,66,3,-1,-6">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <tran trig="PWM_TIMEOUT">
      <action>if(abs(me-&gt;wantedCil - me-&gt;realCil) &gt; 5) {
    if(me-&gt;wantedCil &gt; me-&gt;realCil) {
        int newCil = me-&gt;realCil + 5;
        cilindro_set_duty(newCil);
        me-&gt;realCil = newCil;
        QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
    } else {
        int newCil = me-&gt;realCil - 5;
        cilindro_set_duty(newCil);
        me-&gt;realCil = newCil;
        QTimeEvt_rearm(&amp;me-&gt;pwmTimeEvt, PWM_CHECK_INTERVAL);
    }
} else if(me-&gt;realCil != me-&gt;wantedCil) {
    cilindro_set_duty(me-&gt;wantedCil);
    me-&gt;realCil = me-&gt;wantedCil;
}
</action>
      <tran_glyph conn="58,68,3,-1,14">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="58,59,21,13">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="143,94"/>
   </statechart>
  </class>
  <class name="Ihm" superclass="qpc::QActive">
   <attribute name="state" type="IhmState" visibility="0x02" properties="0x00"/>
   <attribute name="stageTimerEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <attribute name="stage" type="IhmStage" visibility="0x02" properties="0x00"/>
   <attribute name="substage" type="IhmSubstage" visibility="0x02" properties="0x00"/>
   <attribute name="roasts_page" type="RoastsPageData" visibility="0x02" properties="0x00"/>
   <attribute name="roast_page" type="RoastPageData" visibility="0x02" properties="0x00"/>
   <attribute name="control_page" type="ControlPageData" visibility="0x02" properties="0x00"/>
   <operation name="resetData" type="void" visibility="0x02" properties="0x00">
    <code>Ihm_resetState(me);
Ihm_resetRoastsPageData(me);
Ihm_resetRoastPageData(me);</code>
   </operation>
   <operation name="resetState" type="void" visibility="0x02" properties="0x00">
    <code>me-&gt;state.control = (ControlState){
    .potencia = 0,
    .cilindro = 0,
    .turbina = TOGGLE_OFF,
    .resfriador = TOGGLE_OFF
};

/*
strcpy(me-&gt;next_command.command, &quot;&quot;);
me-&gt;next_command.time = 0;
*/</code>
   </operation>
   <operation name="resetRoastsPageData" type="void" visibility="0x02" properties="0x00">
    <code>me-&gt;roasts_page = (RoastsPageData){
    .page = 0,
    .roast1 = &quot;&quot;,
    .roast2 = &quot;&quot;,
    .roast3 = &quot;&quot;,
};</code>
   </operation>
   <operation name="resetRoastPageData" type="void" visibility="0x02" properties="0x00">
    <code>me-&gt;roast_page = (RoastPageData){
    .roast = &quot;&quot;
};</code>
   </operation>
   <operation name="resetChart" type="void" visibility="0x02" properties="0x00">
    <code>UartOutputChartEvt *chartEv = Q_NEW(UartOutputChartEvt, UART_OUTPUT_CHART_SIG);
chartEv-&gt;vp = VP_CHART_LINE_GRAO;
chartEv-&gt;sensor = SENSOR_GRAO;
chartEv-&gt;values = 0;
chartEv-&gt;count = 0;
chartEv-&gt;minX = 0;
chartEv-&gt;maxX = 0;
chartEv-&gt;minY = 0;
chartEv-&gt;maxY = 0;
chartEv-&gt;deltaBound = true;
chartEv-&gt;deltaBoundX = 0;
chartEv-&gt;maxTemp = 0;
chartEv-&gt;minTemp = 0;
chartEv-&gt;originY = 0;
chartEv-&gt;isDelta = true;
QACTIVE_POST(AO_Uart, &amp;chartEv-&gt;super, me);

UartOutputChartEvt *chartEv2 = Q_NEW(UartOutputChartEvt, UART_OUTPUT_CHART_SIG);
chartEv-&gt;vp = VP_CHART_LINE_AR;
chartEv-&gt;sensor = SENSOR_AR;
chartEv-&gt;values = 0;
chartEv-&gt;count = 0;
chartEv-&gt;minX = 0;
chartEv-&gt;maxX = 0;
chartEv-&gt;minY = 0;
chartEv-&gt;maxY = 0;
chartEv-&gt;deltaBound = true;
chartEv-&gt;deltaBoundX = 0;
chartEv-&gt;maxTemp = 0;
chartEv-&gt;minTemp = 0;
chartEv-&gt;originY = 0;
chartEv-&gt;isDelta = true;
QACTIVE_POST(AO_Uart, &amp;chartEv2-&gt;super, me);</code>
   </operation>
   <operation name="setupPageManualMode" type="void" visibility="0x02" properties="0x01">
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_MANUAL_MODE]&quot;);

postUart_setPage(MANUAL_MODE_PICID);
postUart_setString(NAVBAR_TEXT_VP, &quot;MODO MANUAL&quot;, true, NAVBAR_TEXT_LEN);

postUart_setString(SENSOR_AR_TEXT_VP, &quot;0\0&quot;, true, SENSOR_AR_TEXT_LEN);
postUart_setString(DELTA_AR_TEXT_VP, &quot;0\0&quot;, true, DELTA_AR_TEXT_LEN);

postUart_setString(SENSOR_GRAO_TEXT_VP, &quot;0\0&quot;, true, SENSOR_GRAO_TEXT_LEN);
postUart_setString(DELTA_GRAO_TEXT_VP, &quot;0\0&quot;, true, DELTA_GRAO_TEXT_LEN);</code>
   </operation>
   <operation name="setupPageMainMenu" type="void" visibility="0x02" properties="0x01">
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_MAIN_MENU]&quot;);

postUart_setPage(MAIN_MENU_PICID);

postUart_setString(NAVBAR_TEXT_VP, &quot;HOME&quot;, true, NAVBAR_TEXT_LEN);
postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);</code>
   </operation>
   <operation name="setupPageManualControls" type="void" visibility="0x02" properties="0x01">
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_MANUAL_CONTROLS]&quot;);

postUart_setPage(CONTROLS_PICID);

postUart_setIcon(NEXT_COMMAND_ICON_VP, 0);
postUart_setString(NEXT_COMMAND_TEXT_VP, &quot;\0&quot;, true, NEXT_COMMAND_TEXT_LEN);
postUart_setString(NEXT_COMMAND_TIMER_TEXT_VP, &quot;\0&quot;, true, NEXT_COMMAND_TIMER_TEXT_LEN);

postUart_setIcon(CONTROL_POTENCIA_ICON_VP, 0);
postUart_setString(CONTROL_POTENCIA_TEXT_VP, &quot;\0&quot;, true, CONTROL_POTENCIA_TEXT_LEN);

postUart_setIcon(CONTROL_CILINDRO_ICON_VP, 0);
postUart_setString(CONTROL_CILINDRO_TEXT_VP, &quot;\0&quot;, true, CONTROL_CILINDRO_TEXT_LEN);

postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, 0);
postUart_setIcon(CONTROL_TURBINA_ICON_VP, 0);</code>
   </operation>
   <operation name="setupPageSummary" type="void" visibility="0x02" properties="0x01">
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_MANUAL_MODE]&quot;);

postUart_setPage(SUMMARY_PICID);
postUart_setString(NAVBAR_TEXT_VP, &quot;RESUMO&quot;, true, NAVBAR_TEXT_LEN);

postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
postUart_setIcon(NAVBAR_ICON_GEAR_VP, 0);</code>
   </operation>
   <operation name="requestExitMode" type="void" visibility="0x02" properties="0x01">
    <code>RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
ram-&gt;mode = MODE_NONE;
strcpy(ram-&gt;roast, &quot;&quot;);

QACTIVE_POST(AO_DataBroker, &amp;ram-&gt;super, me);</code>
   </operation>
   <operation name="setupPageRoasts" type="void" visibility="0x02" properties="0x00">
    <parameter name="recipes" type="bool"/>
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_ROASTS]&quot;);

postUart_setPage(ROASTS_PICID);


postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);

if(me-&gt;roasts_page.prev)
    postUart_setIcon(ROASTS_ICON_LEFT_VP, 1);
else
    postUart_setIcon(ROASTS_ICON_LEFT_VP, 0);

if(me-&gt;roasts_page.next)
    postUart_setIcon(ROASTS_ICON_RIGHT_VP, 2);
else
    postUart_setIcon(ROASTS_ICON_RIGHT_VP, 0);

ESP_LOGE(TAG, &quot;%s-%s-%s&quot;, me-&gt;roasts_page.roast1, me-&gt;roasts_page.roast2,me-&gt;roasts_page.roast3);

if(strcmp(me-&gt;roasts_page.roast1, &quot;&quot;) == 0) {
    postUart_setIcon(ROASTS_ICON_ROAST1_VP, 0);
    postUart_setString(ROASTS_TEXT_ROAST1_VP, &quot;&quot;, true, ROASTS_TEXT_ROAST1_LEN);
} else {
    postUart_setIcon(ROASTS_ICON_ROAST1_VP, 1);
    postUart_setString(ROASTS_TEXT_ROAST1_VP, me-&gt;roasts_page.roast1, true, ROASTS_TEXT_ROAST1_LEN);
}

if(strcmp(me-&gt;roasts_page.roast2, &quot;&quot;) == 0) {
    postUart_setIcon(ROASTS_ICON_ROAST2_VP, 0);
    postUart_setString(ROASTS_TEXT_ROAST2_VP, &quot;&quot;, true, ROASTS_TEXT_ROAST2_LEN);
} else {
    postUart_setIcon(ROASTS_ICON_ROAST2_VP, 1);
    postUart_setString(ROASTS_TEXT_ROAST2_VP, me-&gt;roasts_page.roast2, true, ROASTS_TEXT_ROAST2_LEN);
}

if(strcmp(me-&gt;roasts_page.roast3, &quot;&quot;) == 0) {
    postUart_setIcon(ROASTS_ICON_ROAST3_VP, 0);
    postUart_setString(ROASTS_TEXT_ROAST3_VP, &quot;&quot;, true, ROASTS_TEXT_ROAST3_LEN);
} else {
    postUart_setIcon(ROASTS_ICON_ROAST3_VP, 1);
    postUart_setString(ROASTS_TEXT_ROAST3_VP, me-&gt;roasts_page.roast3, true, ROASTS_TEXT_ROAST3_LEN);
}

if(recipes) {
    postUart_setString(NAVBAR_TEXT_VP, &quot;RECEITAS&quot;, true, NAVBAR_TEXT_LEN);
} else {
    postUart_setString(NAVBAR_TEXT_VP, &quot;TORRAS&quot;, true, NAVBAR_TEXT_LEN);
}</code>
   </operation>
   <operation name="setupPageRoast" type="void" visibility="0x02" properties="0x00">
    <parameter name="recipe" type="bool"/>
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_ROAST]&quot;);

postUart_setPage(ROAST_PICID);

postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);

if(recipe) {
    postUart_setString(NAVBAR_TEXT_VP, &quot;RECEITA&quot;, true, NAVBAR_TEXT_LEN);
    postUart_setIcon(ROAST_BTN_ICON_VP, 1);
} else {
    postUart_setString(NAVBAR_TEXT_VP, &quot;TORRA&quot;, true, NAVBAR_TEXT_LEN);
    postUart_setIcon(ROAST_BTN_ICON_VP, 0);
}</code>
   </operation>
   <operation name="setupPageAutoMode" type="void" visibility="0x02" properties="0x01">
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_AUTO_MODE]&quot;);

postUart_setPage(MANUAL_MODE_PICID);
postUart_setString(NAVBAR_TEXT_VP, &quot;MODO AUTOMATICO&quot;, true, NAVBAR_TEXT_LEN);

postUart_setString(SENSOR_AR_TEXT_VP, &quot;0\0&quot;, true, SENSOR_AR_TEXT_LEN);
postUart_setString(DELTA_AR_TEXT_VP, &quot;0\0&quot;, true, DELTA_AR_TEXT_LEN);

postUart_setString(SENSOR_GRAO_TEXT_VP, &quot;0\0&quot;, true, SENSOR_GRAO_TEXT_LEN);
postUart_setString(DELTA_GRAO_TEXT_VP, &quot;0\0&quot;, true, DELTA_GRAO_TEXT_LEN);</code>
   </operation>
   <operation name="postTemperatures" type="void" visibility="0x02" properties="0x01">
    <parameter name="vp" type="unsigned short int"/>
    <parameter name="sensor" type="SensorType"/>
    <parameter name="values" type="int *"/>
    <parameter name="count" type="int"/>
    <parameter name="minX" type="int"/>
    <parameter name="maxX" type="int"/>
    <parameter name="minY" type="int"/>
    <parameter name="maxY" type="int"/>
    <parameter name="deltaBound" type="bool"/>
    <parameter name="deltaBoundX" type="int"/>
    <parameter name="maxTemp" type="int"/>
    <parameter name="minTemp" type="int"/>
    <parameter name="originY" type="int"/>
    <parameter name="isDelta" type="bool"/>
    <code>UartOutputChartEvt *chartEv = Q_NEW(UartOutputChartEvt, UART_OUTPUT_CHART_SIG);
chartEv-&gt;vp = vp;
chartEv-&gt;sensor = sensor;
chartEv-&gt;values = values;
chartEv-&gt;count = count;
chartEv-&gt;minX = minX;
chartEv-&gt;maxX = maxX;
chartEv-&gt;minY = minY;
chartEv-&gt;maxY = maxY;
chartEv-&gt;deltaBound = deltaBound;
chartEv-&gt;deltaBoundX = deltaBoundX;
chartEv-&gt;maxTemp = maxTemp;
chartEv-&gt;minTemp = minTemp;
chartEv-&gt;originY = originY;
chartEv-&gt;isDelta = isDelta;
/*
if(isDelta) {
    printf(&quot;\nDeltas:[&quot;);
    for(int i=0;i&lt;count;i++) {
        printf(&quot;%d, &quot;, values[i]);
    }
    printf(&quot;]\n&quot;);
} else {
    printf(&quot;\nTemperaturas:[&quot;);
    for(int i=0;i&lt;count;i++) {
        printf(&quot;%d, &quot;, values[i]);
    }
    printf(&quot;]\n&quot;);
}
*/
QACTIVE_POST(AO_Uart, &amp;chartEv-&gt;super, me);</code>
   </operation>
   <operation name="setupPageControls" type="void" visibility="0x02" properties="0x01">
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_CONTROLS]&quot;);

postUart_setPage(CONTROLS_PICID);
postUart_setString(NAVBAR_TEXT_VP, &quot;CONTROLES&quot;, true, NAVBAR_TEXT_LEN);

postUart_setString(SENSOR_AR_TEXT_VP, &quot;0\0&quot;, true, SENSOR_AR_TEXT_LEN);
postUart_setString(DELTA_AR_TEXT_VP, &quot;0\0&quot;, true, DELTA_AR_TEXT_LEN);

postUart_setString(SENSOR_GRAO_TEXT_VP, &quot;0\0&quot;, true, SENSOR_GRAO_TEXT_LEN);
postUart_setString(DELTA_GRAO_TEXT_VP, &quot;0\0&quot;, true, DELTA_GRAO_TEXT_LEN);

Ihm_updateComponentControl(POTENCIA, 0);
Ihm_updateComponentControl(CILINDRO, 0);
Ihm_updateComponentControl(TURBINA, 0);
Ihm_updateComponentControl(RESFRIADOR, 0);</code>
   </operation>
   <operation name="requestPageControls" type="void" visibility="0x02" properties="0x01">
    <parameter name="max_pre_heat" type="int"/>
    <parameter name="max_roast" type="int"/>
    <code>ESP_LOGV(TAG, &quot;[IHM_REQUEST_PAGE_CONTROLS]&quot;);

postData_requestData(
    DATA_PAGE,
    (Data){
        .page_data.type = PAGE_CONTROLS
    )
);</code>
   </operation>
   <operation name="hidratePageControls" type="void" visibility="0x02" properties="0x00">
    <parameter name="sensor_grao" type="uint16_t"/>
    <parameter name="sensor_ar" type="uint16_t"/>
    <parameter name="potencia" type="uint16_t"/>
    <parameter name="cilindro" type="uint16_t"/>
    <parameter name="turbina" type="uint16_t"/>
    <parameter name="resfriador" type="uint16_t"/>
    <code>ESP_LOGV(TAG, &quot;[HIDRATE_PAGE_CONTROLS]&quot;);

postUart_setNumberAsString(SENSOR_GRAO_TEXT_VP, sensor_grao, &quot; C&quot;, true, SENSOR_GRAO_TEXT_LEN);
postUart_setNumberAsString(SENSOR_AR_TEXT_VP, sensor_ar, &quot; C&quot;, true, SENSOR_AR_TEXT_LEN);

Ihm_updateComponentControl(POTENCIA, potencia);
Ihm_updateComponentControl(CILINDRO, cilindro);
Ihm_updateComponentControl(TURBINA, turbina);
Ihm_updateComponentControl(RESFRIADOR, resfriador);</code>
   </operation>
   <operation name="setupPageConfig" type="void" visibility="0x02" properties="0x01">
    <code>ESP_LOGD(TAG, &quot;[IHM_SETUP_PAGE_CONFIG]&quot;);

postUart_setPage(CONFIG_PICID);
postUart_setString(NAVBAR_TEXT_VP, &quot;CONFIGURACOES&quot;, true, NAVBAR_TEXT_LEN);
postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
postUart_setIcon(NAVBAR_ICON_GEAR_VP, 0);

postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, 0);
postUart_setNumber(CONFIG_ROAST_NUMBER_VP, 0);</code>
   </operation>
   <operation name="requestPageConfig" type="void" visibility="0x02" properties="0x01">
    <parameter name="max_pre_heat" type="int"/>
    <parameter name="max_roast" type="int"/>
    <code>ESP_LOGV(TAG, &quot;[IHM_REQUEST_PAGE_CONFIG]&quot;);

postData_requestData(
    DATA_PAGE,
    (Data){
        .page_data.type = PAGE_CONFIG
    )
);</code>
   </operation>
   <operation name="hidratePageConfig" type="void" visibility="0x02" properties="0x00">
    <parameter name="max_pre_heat" type="uint16_t"/>
    <parameter name="max_roast" type="uint16_t"/>
    <code>ESP_LOGD(TAG, &quot;[IHM_HIDRATE_PAGE_CONFIG]&quot;);

postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, max_pre_heat);
postUart_setNumber(CONFIG_ROAST_NUMBER_VP, max_roast);</code>
   </operation>
   <operation name="updateComponentControl" type="void" visibility="0x02" properties="0x01">
    <parameter name="type" type="ControlType"/>
    <parameter name="value" type="uint16_t"/>
    <code>ESP_LOGD(TAG, &quot;[UPDATE_COMPONENT_CONTROL]&quot;);

uint16_t new_value = ceil(value / 5) * 5;
uint8_t icon = ceil(new_value / 5);

char str[10];
memset(str, &quot;\0&quot;, sizeof(str));
itoa(new_value, str, 10);

switch(type) {
    case POTENCIA:
        postUart_setString(CONTROL_POTENCIA_TEXT_VP, str, true, CONTROL_POTENCIA_TEXT_LEN);
        postUart_setIcon(CONTROL_POTENCIA_ICON_VP, icon);
    break;

    case CILINDRO:
        postUart_setString(CONTROL_CILINDRO_TEXT_VP, str, true, CONTROL_CILINDRO_TEXT_LEN);
        postUart_setIcon(CONTROL_CILINDRO_ICON_VP, icon);
    break;

    case TURBINA:
        icon = 0;
        if(value == 0) {
            icon = 0;
        } else if(value == 70) {
            icon = 1;
        } else if(value == 80) {
            icon = 2;
        } else if(value == 90) {
            icon = 3;
        } else if(value == 100) {
            icon = 4;
        } else {
            ESP_LOGE(TAG, &quot;Turbina recebendo valor outro além dos possiveis: %d&quot;, value);
        }

        postUart_setIcon(CONTROL_TURBINA_ICON_VP, icon);
    break;

    case RESFRIADOR:
        icon = 0;
        if(value == 0) {
            icon = 0;
        } else if(value == 100) {
            icon = 4;
        } else {
            ESP_LOGE(TAG, &quot;Resfriador recebendo valor outro além dos possiveis: %d&quot;, value);
        }

        postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, icon);
    break;
}</code>
   </operation>
   <statechart properties="0x00">
    <initial target="../1">
     <action>/* (!) trigger the initial transition in the component */
QHSM_INIT((QHsm *)&amp;me-&gt;stage, (void *)0, me-&gt;super.prio);

/* (!) trigger the initial transition in the component */
QHSM_INIT((QHsm *)&amp;me-&gt;substage, (void *)0, me-&gt;super.prio);</action>
     <initial_glyph conn="147,3,4,0,17">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="main_menu">
     <entry>ESP_LOGD(TAG, &quot;[MAIN_MENU][ENTRY]&quot;);

Ihm_setupPageMainMenu();</entry>
     <exit>ESP_LOGD(TAG, &quot;[MAIN_MENU][EXIT]&quot;);</exit>
     <tran trig="IHM_INPUT_TOUCH">
      <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
      <choice target="../../../2">
       <guard>ihmEv-&gt;length == 3</guard>
       <choice_glyph conn="141,38,4,3,10,-84,63,20">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../3">
       <guard>ihmEv-&gt;length == 4</guard>
       <choice_glyph conn="141,38,4,3,12,-84,262,19">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../4">
       <guard>ihmEv-&gt;length == 5</guard>
       <choice_glyph conn="141,38,4,3,14,-84,341,22">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../5">
       <guard>ihmEv-&gt;length == 2</guard>
       <choice_glyph conn="141,38,5,3,72,-4,5">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="122,38,3,-1,19">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="122,20,39,25">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="manual_mode">
     <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ENTRY]&quot;);

Ihm_resetState(me);

RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
ram-&gt;mode = MODE_MANUAL;
strcpy(ram-&gt;roast, &quot;&quot;);
QACTIVE_POST(AO_DataBroker, &amp;ram-&gt;super, me);</entry>
     <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][EXIT]&quot;);
QTimeEvt_disarm(&amp;me-&gt;stageTimerEvt);</exit>
     <initial target="../3/2/3">
      <initial_glyph conn="80,124,5,3,8,4,8">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <tran trig="NOTIFY_MODE">
      <action>NotifyModeEvt *nme = Q_EVT_CAST(NotifyModeEvt); 
QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
      <choice target="../../../1">
       <guard>nme-&gt;mode == MODE_NONE</guard>
       <choice_glyph conn="146,51,4,2,-6">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="146,60,0,-1,-9">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="manual_config">
      <entry>ESP_LOGD(TAG, &quot;[CONFIG][ENTRY]&quot;);

Ihm_setupPageConfig();
Ihm_requestDataConfig();</entry>
      <exit>ESP_LOGD(TAG, &quot;[CONFIG][EXIT]&quot;);</exit>
      <tran trig="IHM_INPUT_TOUCH">
       <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
       <choice target="../../../3/2" cpref="../../../3/2/0">
        <guard>ihmEv-&gt;length == 3</guard>
        <choice_glyph conn="269,83,4,0,16,-97,5">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="254,83,3,-1,15">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="IHM_INPUT_CONFIG_SAVE" target="../../3/2" cpref="../../3/2/0">
       <action>IhmInputConfigSaveEvt *ev = Q_EVT_CAST(IhmInputConfigSaveEvt);

ConfigUpdateEvt *confEv = Q_NEW(ConfigUpdateEvt, CONFIG_UPDATE_SIG);
confEv-&gt;pre_heat = ev-&gt;pre;
confEv-&gt;roast = ev-&gt;roast;

QACTIVE_POST(AO_DataBroker, confEv, me);</action>
       <tran_glyph conn="264,97,2,0,7,-92,0">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DATA_RESPONSE">
       <action>DataResponseEvt *resEv = Q_EVT_CAST(DataResponseEvt);

DataType type = resEv-&gt;type;
Data data = resEv-&gt;data;</action>
       <choice>
        <guard>type == DATA_PAGE &amp;&amp; data.page_data.page == PAGE_CONFIG</guard>
        <action>ConfigPageData page_data = data.page_data.data;
uint16_t max_pre_heat = page_data-&gt;max_pre_heat;
uint16_t max_roast = page_data-&gt;max_roast;

hidratePageConfig(max_pre_heat, max_roast);</action>
        <choice_glyph conn="264,91,5,-1,11">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="254,91,3,-1,10">
        <action box="0,-2,17,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="254,71,36,26">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="manual_events">
      <tran trig="CONTROL_DATA">
       <action>ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

ControlType control = contEv-&gt;control;
int value = contEv-&gt;value;

if(contEv-&gt;control == POTENCIA) {
    me-&gt;state.control.potencia = value;
} else if(contEv-&gt;control == CILINDRO) {
    me-&gt;state.control.cilindro = value;
} else if(contEv-&gt;control == TURBINA) {
    if(value == 0)
        me-&gt;state.control.turbina = TOGGLE_OFF;
    else if(value == 70)
        me-&gt;state.control.turbina = TOGGLE_SEVENTY;
    else if(value == 80)
        me-&gt;state.control.turbina = TOGGLE_EIGHTY;
    else if(value == 90)
        me-&gt;state.control.turbina = TOGGLE_NINETY;
    else if(value == 100)
        me-&gt;state.control.turbina = TOGGLE_MAX;
} else if(contEv-&gt;control == RESFRIADOR) {
    if(value == 0)
        me-&gt;state.control.resfriador = TOGGLE_OFF;
    else
        me-&gt;state.control.resfriador = TOGGLE_MAX;
}</action>
       <tran_glyph conn="82,144,3,-1,10">
        <action box="0,-2,18,2"/>
       </tran_glyph>
      </tran>
      <tran trig="SENSOR_DATA">
       <action>SensorDataEvt *sensorEv = Q_EVT_CAST(SensorDataEvt);

SensorType type = sensorEv-&gt;type;
int value = sensorEv-&gt;value;
int delta = sensorEv-&gt;delta;

if(type == SENSOR_GRAO) {
    char graoStr[6] = {0};
    sprintf(graoStr, &quot;%d C&quot;, value);
    postUart_setString(SENSOR_GRAO_TEXT_VP, graoStr, true, SENSOR_GRAO_TEXT_LEN);

    char graoDeltaStr[6] = {0};
    sprintf(graoDeltaStr, &quot;%d&quot;, delta);
    postUart_setString(DELTA_GRAO_TEXT_VP, graoDeltaStr, true, DELTA_GRAO_TEXT_LEN);
} else if(sensorEv-&gt;type == SENSOR_AR) {
    char arStr[6] = {0};
    sprintf(arStr, &quot;%d C&quot;, value);
    postUart_setString(SENSOR_AR_TEXT_VP, arStr, true, SENSOR_AR_TEXT_LEN);

    char arDeltaStr[6] = {0};
    sprintf(arDeltaStr, &quot;%d&quot;, delta);
    postUart_setString(DELTA_AR_TEXT_VP, arDeltaStr, true, DELTA_AR_TEXT_LEN);
} else if(sensorEv-&gt;type == SENSOR_GAS) {
    char gasStr[6] = {0};
    sprintf(gasStr, &quot;%d&quot;, value);
    postUart_setString(SENSOR_GAS_TEXT_VP, gasStr, true, SENSOR_GAS_TEXT_LEN);
}</action>
       <tran_glyph conn="82,146,3,-1,10">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state name="manual_page">
       <entry>Ihm_setupPageManualMode();</entry>
       <history type="deep" target="../3">
        <history_glyph conn="172,105,0,0,3,-47,11"/>
       </history>
       <tran trig="CHART_DATA">
        <tran_glyph conn="94,149,5,-1,9">
         <action box="0,-2,16,2"/>
        </tran_glyph>
       </tran>
       <tran trig="IHM_INPUT_TOUCH">
        <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
        <choice target="../../../3">
         <guard>ihmEv-&gt;length == 4</guard>
         <choice_glyph conn="108,114,4,2,-17,-6,-1">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../2">
         <guard>ihmEv-&gt;length == 2</guard>
         <choice_glyph conn="108,114,4,3,-17,58,-9,88">
          <action box="1,1,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard>ihmEv-&gt;length == 3</guard>
         <action>RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</action>
         <choice_glyph conn="108,114,5,-1,9">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="94,114,3,-1,14">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state name="idle">
        <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][IDLE][ENTRY]&quot;);

postUart_setIcon(NAVBAR_ICON_HOME_VP, 1);
postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);</entry>
        <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][IDLE][EXIT]&quot;);</exit>
        <tran trig="IHM_INPUT_TOUCH">
         <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
         <choice target="../../../../../4">
          <guard>ihmEv-&gt;length == 3</guard>
          <choice_glyph conn="108,129,5,3,5,39,-4">
           <action box="1,0,10,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../../1">
          <guard>ihmEv-&gt;length == 1</guard>
          <action>RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
ram-&gt;mode = MODE_NONE;
strcpy(ram-&gt;roast, &quot;&quot;);
QACTIVE_POST(AO_DataBroker, &amp;ram-&gt;super, me);</action>
          <choice_glyph conn="108,129,4,3,-5,-40,-92,54">
           <action box="1,0,10,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="96,129,3,-1,12">
          <action box="0,-2,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="96,119,31,19">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="active">
        <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][ENTRY]&quot;);

postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);</entry>
        <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][EXIT]&quot;);</exit>
        <state name="pre_heating">
         <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][PRE_HEATING][ENTRY]&quot;);

</entry>
         <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][PRE_HEATING][EXIT]&quot;);</exit>
         <tran trig="NOTIFY_NEXT_STAGE" target="../../1/1">
          <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
          <tran_glyph conn="165,143,1,3,5,-1,2">
           <action box="0,-2,10,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="135,138,30,16">
          <entry box="1,2,6,2"/>
          <exit box="1,4,6,2"/>
         </state_glyph>
        </state>
        <state name="chart">
         <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][CHART][ENTRY]&quot;);

QTimeEvt_armX(&amp;me-&gt;stageTimerEvt, STAGE_TIMER_INTERVAL, 0U);</entry>
         <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][CHART][EXIT]&quot;);

QTimeEvt_disarm(&amp;me-&gt;stageTimerEvt);</exit>
         <tran trig="IHM_STAGE_TIMER_TIMEOUT">
          <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);

QTimeEvt_rearm(&amp;me-&gt;stageTimerEvt, STAGE_TIMER_INTERVAL);</action>
          <tran_glyph conn="168,126,3,-1,17">
           <action box="0,-2,10,2"/>
          </tran_glyph>
         </tran>
         <state name="roasting">
          <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][CHART][ROASTING][ENTRY]&quot;);

RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
stageEv-&gt;substage = F;
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</entry>
          <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][CHART][ROASTING][EXIT]&quot;);

NotifySubstageExitEvt *stageEv = Q_NEW(NotifySubstageExitEvt, NOTIFY_SUBSTAGE_EXIT_SIG);
QHSM_DISPATCH((QHsm *)&amp;me-&gt;substage, stageEv, me-&gt;super.prio);</exit>
          <tran trig="NOTIFY_NEXT_STAGE" target="../../2">
           <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
           <tran_glyph conn="202,141,1,3,6">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <tran trig="IHM_INPUT_TOUCH">
           <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
           <choice>
            <guard brief="SUBSTAGE">ihmEv-&gt;length == 5</guard>
            <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;substage, e, me-&gt;super.prio);</action>
            <choice_glyph conn="184,145,5,-1,8">
             <action box="1,0,10,2"/>
            </choice_glyph>
           </choice>
           <tran_glyph conn="172,145,3,-1,12">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <tran trig="NOTIFY_NEXT_SUBSTAGE">
           <action>NotifyNextSubstageEvt *subEv = Q_EVT_CAST(NotifyNextSubstageEvt);

QHSM_DISPATCH((QHsm *)&amp;me-&gt;substage, subEv, me-&gt;super.prio);</action>
           <tran_glyph conn="172,148,3,-1,11">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <state_glyph node="172,134,30,17">
           <entry box="1,2,6,2"/>
           <exit box="1,4,6,2"/>
          </state_glyph>
         </state>
         <state name="cooling">
          <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][CHART][COOLING][ENTRY]&quot;);</entry>
          <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][CHART][ROASTING][EXIT]&quot;);</exit>
          <tran trig="NOTIFY_NEXT_STAGE" target="../../../../../../5">
           <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
           <tran_glyph conn="241,142,1,2,15,6,16,-3">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <state_glyph node="208,134,33,17">
           <entry box="1,2,6,2"/>
           <exit box="1,4,6,2"/>
          </state_glyph>
         </state>
         <state_glyph node="168,117,74,36">
          <entry box="1,2,6,2"/>
          <exit box="1,4,6,2"/>
         </state_glyph>
        </state>
        <state_glyph node="131,111,116,45">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="94,105,155,55">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="manual_controls">
       <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][CONTROLS}[ENTRY]&quot;);

Ihm_setupPageControls();
Ihm_requestPageControls();</entry>
       <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][CONTROLS}[EXIT]&quot;);</exit>
       <tran trig="IHM_INPUT_TOUCH">
        <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
        <choice target="../../../2" cpref="../../../2/0">
         <guard>ihmEv-&gt;length == 2</guard>
         <choice_glyph conn="102,83,5,0,70,21">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="RESFRIADOR">ihmEv-&gt;length == 3</guard>
         <action>ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
contEv-&gt;control = RESFRIADOR;

if(me-&gt;state.control.resfriador == TOGGLE_OFF) {
    ESP_LOGE(TAG, &quot;Sending 1&quot;);
    contEv-&gt;value = 1;
} else {
    ESP_LOGE(TAG, &quot;Sending 0&quot;);
    contEv-&gt;value = 0;
}

QACTIVE_POST(AO_DataBroker, contEv, me);</action>
         <choice_glyph conn="102,83,4,-1,-7,-5">
          <action box="-13,-7,13,3"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="TURBINA">ihmEv-&gt;length == 4</guard>
         <action>ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
contEv-&gt;control = TURBINA;

if(me-&gt;state.control.turbina == TOGGLE_OFF) {
    contEv-&gt;value = 70;
} else if(me-&gt;state.control.turbina == TOGGLE_SEVENTY) {
    contEv-&gt;value = 80;
} else if(me-&gt;state.control.turbina == TOGGLE_EIGHTY) {
    contEv-&gt;value = 90;
} else if(me-&gt;state.control.turbina == TOGGLE_NINETY) {
    contEv-&gt;value = 100;
} else if(me-&gt;state.control.turbina == TOGGLE_MAX) {
    contEv-&gt;value = 0;
}

QACTIVE_POST(AO_DataBroker, contEv, me);</action>
         <choice_glyph conn="102,83,4,-1,-7,4">
          <action box="5,-6,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="88,83,3,-1,14">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="IHM_INPUT_SLIDER">
        <action>IhmInputSliderEvt *ihmEv = Q_EVT_CAST(IhmInputSliderEvt);
ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);

uint8_t value = ceil(ihmEv-&gt;value / 5) * 5;
uint8_t icon = ceil(value / 5);

ESP_LOGE(TAG, &quot;%d, %d, %d&quot;, ihmEv-&gt;control, value, icon);

if(ihmEv-&gt;control == POTENCIA) {
    contEv-&gt;control = POTENCIA;
    contEv-&gt;value = value;
} else if(ihmEv-&gt;control == CILINDRO) {
    contEv-&gt;control = CILINDRO;
    contEv-&gt;value = value;
}

QACTIVE_POST(AO_DataBroker, contEv, me);</action>
        <tran_glyph conn="88,87,3,-1,13">
         <action box="0,-2,18,2"/>
        </tran_glyph>
       </tran>
       <tran trig="CONTROL_DATA">
        <action>ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

ControlType control = contEv-&gt;control;
int value = contEv-&gt;value;
int icon = ceil(value / 5);

if(contEv-&gt;control == POTENCIA) {
    me-&gt;state.control.potencia = value;

    char potStr[100] = {0};
    strcpy(potStr, itoa(value, potStr, 10));

    postUart_setString(CONTROL_POTENCIA_TEXT_VP, potStr, true, CONTROL_POTENCIA_TEXT_LEN); 
    postUart_setIcon(CONTROL_POTENCIA_ICON_VP, icon);
} else if(contEv-&gt;control == CILINDRO) {
    me-&gt;state.control.cilindro = value;

    char cilStr[100] = {0};
    strcpy(cilStr, itoa(value, cilStr, 10));
    
    postUart_setString(CONTROL_CILINDRO_TEXT_VP, cilStr, true, CONTROL_POTENCIA_TEXT_LEN); 
    postUart_setIcon(CONTROL_CILINDRO_ICON_VP, icon);
} else if(contEv-&gt;control == TURBINA) {
    int icon = 0;

    if(value == 0) {
        me-&gt;state.control.turbina = TOGGLE_OFF;
        icon = 0;
    } else if(value == 70) {
        me-&gt;state.control.turbina = TOGGLE_SEVENTY;
        icon = 1;
    } else if(value == 80) {
        me-&gt;state.control.turbina = TOGGLE_EIGHTY;
        icon = 2;
    } else if(value == 90) {
        me-&gt;state.control.turbina = TOGGLE_NINETY;
        icon = 3;
    } else if(value == 100) {
        me-&gt;state.control.turbina = TOGGLE_MAX;
        icon = 4;
    }

     postUart_setIcon(CONTROL_TURBINA_ICON_VP, icon);
} else if(contEv-&gt;control == RESFRIADOR) {
    int icon = 0;

    if(value == 0) {
        icon = 0;
        me-&gt;state.control.resfriador = TOGGLE_OFF;
    } else {
        icon = 4;
        me-&gt;state.control.resfriador = TOGGLE_MAX;
    }
    postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, icon);
}

</action>
        <tran_glyph conn="88,91,3,-1,13">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="DATA_RESPONSE">
        <action>DataResponseEvt *resEv = Q_EVT_CAST(DataResponseEvt);

DataType type = resEv-&gt;type;
Data data = resEv-&gt;data;</action>
        <choice>
         <guard>type == DATA_PAGE &amp;&amp; data.page_data.page == PAGE_CONTROLS</guard>
         <action>ControlPageData page_data = data.page_data.data;
uint16_t sensor_grao = page_data-&gt;sensor_grao;
uint16_t sensor_ar = page_data-&gt;sensor_ar;
uint16_t potencia = page_data-&gt;potencia;
uint16_t cilindro = page_data-&gt;cilindro;
uint16_t turbina = page_data-&gt;turbina;
uint16_t resfriador = page_data-&gt;resfriador;

hidratePageConfig(max_pre_heat, max_roast);</action>
         <choice_glyph conn="138,86,5,-1,-8,3">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="148,86,1,-1,-10">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="88,72,60,24">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="82,67,169,96"/>
     </state>
     <state name="warn_new">
      <entry>postUart_setPage(WARN_NEW_ROAST_PICID);</entry>
      <tran trig="IHM_INPUT_TOUCH">
       <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
       <choice>
        <guard>ihmEv-&gt;length == 4</guard>
        <action>RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</action>
        <choice_glyph conn="115,171,4,-1,3">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../3/2/3">
        <guard>ihmEv-&gt;length == 3</guard>
        <action>Ihm_setupPageManualMode();</action>
        <choice_glyph conn="115,171,4,2,-31,6,-2">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="109,171,3,-1,6">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="NOTIFY_NEXT_STAGE" target="../../3/2/4/0">
       <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
       <tran_glyph conn="120,169,1,3,7,-22,8">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="109,164,11,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="summary">
      <entry>ESP_LOGD(TAG, &quot;[SUMMARY][ENTRY]&quot;);

Ihm_setupPageSummary();

RequestSummaryEvt *reqEv = Q_NEW(RequestSummaryEvt, REQUEST_SUMMARY_SIG);
QACTIVE_POST(AO_DataBroker, reqEv, me);</entry>
      <exit>ESP_LOGD(TAG, &quot;[SUMMARY][EXIT]&quot;);</exit>
      <tran trig="IHM_INPUT_TOUCH">
       <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
       <choice>
        <guard>ihmEv-&gt;length == 1 || ihmEv-&gt;length == 4</guard>
        <action>RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
ram-&gt;mode = MODE_NONE;
strcpy(ram-&gt;roast, &quot;&quot;);
QACTIVE_POST(AO_DataBroker, &amp;ram-&gt;super, me);</action>
        <choice_glyph conn="270,138,5,-1,14">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <choice>
        <guard>ihmEv-&gt;length == 3</guard>
        <action>RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</action>
        <choice_glyph conn="270,138,4,-1,4">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="258,138,3,-1,12">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="NOTIFY_NEXT_STAGE" target="../../3/2/4/0">
       <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
       <tran_glyph conn="280,145,2,2,10,-127,-1">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="RESPONSE_SUMMARY">
       <action>ResponseSummaryEvt *resEv = Q_EVT_CAST(ResponseSummaryEvt);

char fullStr[SUMMARY_TITLE_TEXT_LEN] = &quot;\0&quot;;
sprintf(fullStr, &quot;Torra salva: Torra %s&quot;, resEv-&gt;name);

postUart_setString(SUMMARY_TITLE_TEXT_VP, fullStr, true, SUMMARY_TITLE_TEXT_LEN);</action>
       <tran_glyph conn="258,141,3,-1,9">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="258,127,31,18">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="77,60,216,118">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="recipes">
     <entry>ESP_LOGD(TAG, &quot;[RECIPES][ENTRY]&quot;);

Ihm_resetRoastsPageData(me);
Ihm_setupPageRoasts(me, true);

RequestRecipesEvt *reqEv = Q_NEW(RequestRecipesEvt, REQUEST_RECIPES_SIG);
reqEv-&gt;pageNum = 0;
QACTIVE_POST(AO_DataBroker, &amp;reqEv-&gt;super, me);</entry>
     <exit>ESP_LOGD(TAG, &quot;[RECIPES][EXIT]&quot;);</exit>
     <tran trig="RESPONSE_RECIPES">
      <action>ResponseRecipesEvt *rre = Q_EVT_CAST(ResponseRecipesEvt);

me-&gt;roasts_page.page = rre-&gt;pageNum;
strcpy(&amp;me-&gt;roasts_page.roast1, rre-&gt;roast1);
strcpy(&amp;me-&gt;roasts_page.roast2, rre-&gt;roast2);
strcpy(&amp;me-&gt;roasts_page.roast3, rre-&gt;roast3);
me-&gt;roasts_page.prev = rre-&gt;prevPage;
me-&gt;roasts_page.next = rre-&gt;nextPage;

Ihm_setupPageRoasts(me, true);</action>
      <tran_glyph conn="76,307,3,-1,7,-1,7,1,7">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="IHM_INPUT_TOUCH">
      <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
      <choice>
       <guard>ihmEv-&gt;length == 5</guard>
       <action>RequestRecipesEvt *reqEv = Q_NEW(RequestRecipesEvt, REQUEST_RECIPES_SIG);
reqEv-&gt;pageNum = me-&gt;roasts_page.page + 1;
QACTIVE_POST(AO_DataBroker, &amp;reqEv-&gt;super, me);</action>
       <choice_glyph conn="218,307,4,-1,8">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice>
       <guard>ihmEv-&gt;length == 5</guard>
       <action>RequestRecipesEvt *reqEv = Q_NEW(RequestRecipesEvt, REQUEST_RECIPES_SIG);
reqEv-&gt;pageNum = me-&gt;roasts_page.page -1;
QACTIVE_POST(AO_DataBroker, &amp;reqEv-&gt;super, me);</action>
       <choice_glyph conn="218,307,5,-1,-8,9">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../6">
       <guard>ihmEv-&gt;length == 8 &amp;&amp; strcmp(me-&gt;roasts_page.roast3, &quot;&quot;) != 0</guard>
       <action>strcpy(me-&gt;roast_page.roast, me-&gt;roasts_page.roast3);</action>
       <choice_glyph conn="218,307,5,0,-26,31">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../6">
       <guard>ihmEv-&gt;length == 7 &amp;&amp; strcmp(me-&gt;roasts_page.roast2, &quot;&quot;) != 0</guard>
       <action>strcpy(me-&gt;roast_page.roast, me-&gt;roasts_page.roast2);</action>
       <choice_glyph conn="218,307,5,0,-32,31">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../6">
       <guard>ihmEv-&gt;length == 6 &amp;&amp; strcmp(me-&gt;roasts_page.roast1, &quot;&quot;) != 0</guard>
       <action>strcpy(me-&gt;roast_page.roast, me-&gt;roasts_page.roast1);</action>
       <choice_glyph conn="218,307,5,0,-38,31">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../1">
       <guard>ihmEv-&gt;length == 1 || ihmEv-&gt;length == 3</guard>
       <choice_glyph conn="218,307,4,3,-8,-181,-269,85">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="234,307,1,-1,-16">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="76,291,158,38">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="roasts">
     <entry>ESP_LOGE(TAG, &quot;[ROASTS][ENTRY]&quot;);

Ihm_resetRoastsPageData(me);
Ihm_setupPageRoasts(me, false);

RequestRoastsEvt *reqEv = Q_NEW(RequestRoastsEvt, REQUEST_ROASTS_SIG);
reqEv-&gt;pageNum = 0;
QACTIVE_POST(AO_DataBroker, &amp;reqEv-&gt;super, me);</entry>
     <exit>ESP_LOGE(TAG, &quot;[ROASTS][EXIT]&quot;);</exit>
     <tran trig="RESPONSE_ROASTS">
      <action>ResponseRoastsEvt *rre = Q_EVT_CAST(ResponseRoastsEvt);

me-&gt;roasts_page.page = rre-&gt;pageNum;
strcpy(&amp;me-&gt;roasts_page.roast1, rre-&gt;roast1);
strcpy(&amp;me-&gt;roasts_page.roast2, rre-&gt;roast2);
strcpy(&amp;me-&gt;roasts_page.roast3, rre-&gt;roast3);
me-&gt;roasts_page.prev = rre-&gt;prevPage;
me-&gt;roasts_page.next = rre-&gt;nextPage;

Ihm_setupPageRoasts(me, false);</action>
      <tran_glyph conn="79,387,3,-1,19">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="IHM_INPUT_TOUCH">
      <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
      <choice>
       <guard>ihmEv-&gt;length == 5</guard>
       <action>RequestRoastsEvt *reqEv = Q_NEW(RequestRoastsEvt, REQUEST_ROASTS_SIG);
reqEv-&gt;pageNum = me-&gt;roasts_page.page + 1;
QACTIVE_POST(AO_DataBroker, &amp;reqEv-&gt;super, me);</action>
       <choice_glyph conn="219,385,4,-1,8">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice>
       <guard>ihmEv-&gt;length == 5</guard>
       <action>RequestRoastsEvt *reqEv = Q_NEW(RequestRoastsEvt, REQUEST_ROASTS_SIG);
reqEv-&gt;pageNum = me-&gt;roasts_page.page - 1;
QACTIVE_POST(AO_DataBroker, &amp;reqEv-&gt;super, me);</action>
       <choice_glyph conn="219,385,5,-1,-8,9">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../7">
       <guard>ihmEv-&gt;length == 8 &amp;&amp; strcmp(me-&gt;roasts_page.roast3, &quot;&quot;) != 0</guard>
       <action>strcpy(me-&gt;roast_page.roast, me-&gt;roasts_page.roast3);</action>
       <choice_glyph conn="219,385,5,0,-26,38">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../7">
       <guard>ihmEv-&gt;length == 7 &amp;&amp; strcmp(me-&gt;roasts_page.roast2, &quot;&quot;) != 0</guard>
       <action>strcpy(me-&gt;roast_page.roast, me-&gt;roasts_page.roast2);</action>
       <choice_glyph conn="219,385,5,0,-32,38">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../7">
       <guard>ihmEv-&gt;length == 6 &amp;&amp; strcmp(me-&gt;roasts_page.roast1, &quot;&quot;) != 0</guard>
       <action>strcpy(me-&gt;roast_page.roast, me-&gt;roasts_page.roast1);</action>
       <choice_glyph conn="219,385,5,0,-38,38">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../1">
       <guard>ihmEv-&gt;length == 1 || ihmEv-&gt;length == 3</guard>
       <choice_glyph conn="219,385,4,3,-8,-181,-350,84">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="236,385,1,-1,-17">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="79,372,157,39">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="config">
     <entry>ESP_LOGD(TAG, &quot;[CONFIG][ENTRY]&quot;);

Ihm_setupPageConfig();

RequestConfigEvt *reqEv = Q_NEW(RequestConfigEvt, REQUEST_CONFIG_SIG);
QACTIVE_POST(AO_DataBroker, reqEv, me);</entry>
     <exit>ESP_LOGD(TAG, &quot;[CONFIG][EXIT]&quot;);</exit>
     <tran trig="IHM_INPUT_TOUCH">
      <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
      <choice target="../../../1">
       <guard>ihmEv-&gt;length == 3</guard>
       <choice_glyph conn="233,27,5,1,-67,0,-5">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="218,27,3,-1,15">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RESPONSE_CONFIG">
      <action>ResponseConfigEvt *respEv = Q_EVT_CAST(ResponseConfigEvt);

//POST to uart
postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, respEv-&gt;pre_heat);
postUart_setNumber(CONFIG_ROAST_NUMBER_VP, respEv-&gt;roast);</action>
      <tran_glyph conn="218,30,3,-1,20">
       <action box="0,-2,19,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="218,15,36,26">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="recipe">
     <entry>ESP_LOGE(TAG, &quot;[RECIPE][ENTRY]&quot;);

Ihm_setupPageRoast(me, true);</entry>
     <exit>ESP_LOGE(TAG, &quot;[RECIPE][EXIT]&quot;);</exit>
     <tran trig="IHM_INPUT_TOUCH">
      <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
      <choice target="../../../8">
       <guard>ihmEv-&gt;length == 4</guard>
       <choice_glyph conn="215,351,5,3,42,-125,63">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice target="../../../3">
       <guard>ihmEv-&gt;length == 3</guard>
       <choice_glyph conn="215,351,4,2,-22">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="225,350,1,-1,-10,1">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="92,338,133,23">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="roast">
     <entry>ESP_LOGE(TAG, &quot;[ROAST][ENTRY]&quot;);
Ihm_setupPageRoast(me, false);</entry>
     <exit>ESP_LOGE(TAG, &quot;[ROAST][EXIT]&quot;);</exit>
     <tran trig="IHM_INPUT_TOUCH">
      <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
      <choice target="../../../4">
       <guard>ihmEv-&gt;length == 4</guard>
       <choice_glyph conn="198,442,5,2,-1,-31">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <choice>
       <guard>ihmEv-&gt;length == 4</guard>
       <action>RequestTransformRoastEvt *rtr = Q_NEW(RequestTransformRoastEvt, REQUEST_TRANSFORM_ROAST_SIG);
strcpy(rtr-&gt;roast, me-&gt;roast_page.roast);

QACTIVE_POST(AO_DataBroker, &amp;rtr-&gt;super, me);</action>
       <choice_glyph conn="198,442,5,-1,5,-14">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="209,441,1,-1,-11,1">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="102,423,107,35">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="auto_mode">
     <entry>ESP_LOGD(TAG, &quot;[AUTO_MODE][ENTRY]&quot;);

Ihm_resetState(me);
RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
ram-&gt;mode = MODE_AUTO;
ESP_LOGE(TAG, &quot;NAME: %s&quot;, me-&gt;roast_page.roast);
strcpy(ram-&gt;roast, me-&gt;roast_page.roast);
QACTIVE_POST(AO_DataBroker, &amp;ram-&gt;super, me);</entry>
     <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][EXIT]&quot;);
Ihm_resetState(me);
QTimeEvt_disarm(&amp;me-&gt;stageTimerEvt);</exit>
     <initial target="../3/3/3/0">
      <action>NotifyNextStageEvt *notEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, notEv, me-&gt;super.prio);</action>
      <initial_glyph conn="323,217,5,0,42,18">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <tran trig="NOTIFY_MODE">
      <action>NotifyModeEvt *nme = Q_EVT_CAST(NotifyModeEvt); 
QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
      <choice target="../../../1">
       <guard>nme-&gt;mode == MODE_NONE</guard>
       <choice_glyph conn="389,137,4,1,-91,-113,3,-57,1,-28,-17,-30">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="389,146,0,-1,-9">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="auto_summary">
      <entry>ESP_LOGD(TAG, &quot;[SUMMARY][ENTRY]&quot;);

Ihm_setupPageSummary();
RequestSummaryEvt *reqEv = Q_NEW(RequestSummaryEvt, REQUEST_SUMMARY_SIG);
QACTIVE_POST(AO_DataBroker, reqEv, me);</entry>
      <exit>ESP_LOGD(TAG, &quot;[SUMMARY][EXIT]&quot;);</exit>
      <tran trig="IHM_INPUT_TOUCH">
       <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
       <choice>
        <guard>ihmEv-&gt;length == 1 || ihmEv-&gt;length == 4</guard>
        <action>RequestModeEvt *ram = Q_NEW(RequestModeEvt, REQUEST_MODE_SIG);
ram-&gt;mode = MODE_NONE;
strcpy(ram-&gt;roast, &quot;&quot;);
QACTIVE_POST(AO_DataBroker, &amp;ram-&gt;super, me);</action>
        <choice_glyph conn="530,255,5,-1,14">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <choice>
        <guard>ihmEv-&gt;length == 3</guard>
        <action>RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</action>
        <choice_glyph conn="530,255,4,-1,4">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="518,255,3,-1,12">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="NOTIFY_NEXT_STAGE" target="../../3/3/3/0">
       <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);

NotifyNextStageEvt *notEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, notEv, me-&gt;super.prio);</action>
       <tran_glyph conn="540,262,2,2,10,-166,-21">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="RESPONSE_SUMMARY">
       <action>ResponseSummaryEvt *resEv = Q_EVT_CAST(ResponseSummaryEvt);

char fullStr[SUMMARY_TITLE_TEXT_LEN] = &quot;\0&quot;;
sprintf(fullStr, &quot;Torra salva: Torra %s&quot;, resEv-&gt;name);

postUart_setString(SUMMARY_TITLE_TEXT_VP, fullStr, true, SUMMARY_TITLE_TEXT_LEN);</action>
       <tran_glyph conn="518,258,3,-1,9">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="518,244,31,18">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="auto_events">
      <tran trig="CONTROL_DATA">
       <action>ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

ControlType control = contEv-&gt;control;
int value = contEv-&gt;value;

if(contEv-&gt;control == POTENCIA) {
    me-&gt;state.control.potencia = value;
} else if(contEv-&gt;control == CILINDRO) {
    me-&gt;state.control.cilindro = value;
} else if(contEv-&gt;control == TURBINA) {
    if(value == 0)
        me-&gt;state.control.turbina = TOGGLE_OFF;
    else if(value == 70)
        me-&gt;state.control.turbina = TOGGLE_SEVENTY;
    else if(value == 80)
        me-&gt;state.control.turbina = TOGGLE_EIGHTY;
    else if(value == 90)
        me-&gt;state.control.turbina = TOGGLE_NINETY;
    else if(value == 100)
        me-&gt;state.control.turbina = TOGGLE_MAX;
} else if(contEv-&gt;control == RESFRIADOR) {
    if(value == 0)
        me-&gt;state.control.resfriador = TOGGLE_OFF;
    else
        me-&gt;state.control.resfriador = TOGGLE_MAX;
}</action>
       <tran_glyph conn="325,233,3,-1,10">
        <action box="0,-2,18,2"/>
       </tran_glyph>
      </tran>
      <tran trig="SENSOR_DATA">
       <action>SensorDataEvt *sensorEv = Q_EVT_CAST(SensorDataEvt);

SensorType type = sensorEv-&gt;type;
int value = sensorEv-&gt;value;
int delta = sensorEv-&gt;delta;

if(type == SENSOR_GRAO) {
    char graoStr[6] = {0};
    sprintf(graoStr, &quot;%d C&quot;, value);
    postUart_setString(SENSOR_GRAO_TEXT_VP, graoStr, true, SENSOR_GRAO_TEXT_LEN);

    char graoDeltaStr[6] = {0};
    sprintf(graoDeltaStr, &quot;%d&quot;, delta);
    postUart_setString(DELTA_GRAO_TEXT_VP, graoDeltaStr, true, DELTA_GRAO_TEXT_LEN);
} else if(sensorEv-&gt;type == SENSOR_AR) {
    char arStr[6] = {0};
    sprintf(arStr, &quot;%d C&quot;, value);
    postUart_setString(SENSOR_AR_TEXT_VP, arStr, true, SENSOR_AR_TEXT_LEN);

    char arDeltaStr[6] = {0};
    sprintf(arDeltaStr, &quot;%d&quot;, delta);
    postUart_setString(DELTA_AR_TEXT_VP, arDeltaStr, true, DELTA_AR_TEXT_LEN);
} else if(sensorEv-&gt;type == SENSOR_GAS) {
    char gasStr[6] = {0};
    sprintf(gasStr, &quot;%d&quot;, value);
    postUart_setString(SENSOR_GAS_TEXT_VP, gasStr, true, SENSOR_GAS_TEXT_LEN);
}</action>
       <tran_glyph conn="325,235,3,-1,10">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state name="auto_controls">
       <entry>ESP_LOGD(TAG, &quot;[AUTO_MODE][CONTROLS}[ENTRY]&quot;);
Ihm_setupPageControls(me);</entry>
       <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][CONTROLS}[EXIT]&quot;);</exit>
       <tran trig="IHM_INPUT_TOUCH">
        <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
        <choice target="../../../3" cpref="../../../3/0">
         <guard>ihmEv-&gt;length == 2</guard>
         <choice_glyph conn="346,174,5,0,69,21">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="RESFRIADOR">ihmEv-&gt;length == 3</guard>
         <action>ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
contEv-&gt;control = RESFRIADOR;

if(me-&gt;state.control.resfriador == TOGGLE_OFF) {
    ESP_LOGE(TAG, &quot;Sending 1&quot;);
    contEv-&gt;value = 1;
} else {
    ESP_LOGE(TAG, &quot;Sending 0&quot;);
    contEv-&gt;value = 0;
}

QACTIVE_POST(AO_DataBroker, contEv, me);</action>
         <choice_glyph conn="346,174,4,-1,-7,-5">
          <action box="-13,-7,13,3"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="TURBINA">ihmEv-&gt;length == 4</guard>
         <action>ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
contEv-&gt;control = TURBINA;

if(me-&gt;state.control.turbina == TOGGLE_OFF) {
    contEv-&gt;value = 70;
} else if(me-&gt;state.control.turbina == TOGGLE_SEVENTY) {
    contEv-&gt;value = 80;
} else if(me-&gt;state.control.turbina == TOGGLE_EIGHTY) {
    contEv-&gt;value = 90;
} else if(me-&gt;state.control.turbina == TOGGLE_NINETY) {
    contEv-&gt;value = 100;
} else if(me-&gt;state.control.turbina == TOGGLE_MAX) {
    contEv-&gt;value = 0;
}

QACTIVE_POST(AO_DataBroker, contEv, me);</action>
         <choice_glyph conn="346,174,4,-1,-7,4">
          <action box="5,-6,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="332,174,3,-1,14">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="IHM_INPUT_SLIDER">
        <action>IhmInputSliderEvt *ihmEv = Q_EVT_CAST(IhmInputSliderEvt);
ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);

uint8_t value = ceil(ihmEv-&gt;value / 5) * 5;
uint8_t icon = ceil(value / 5);

ESP_LOGE(TAG, &quot;%d, %d, %d&quot;, ihmEv-&gt;control, value, icon);

if(ihmEv-&gt;control == POTENCIA) {
    contEv-&gt;control = POTENCIA;
    contEv-&gt;value = value;
} else if(ihmEv-&gt;control == CILINDRO) {
    contEv-&gt;control = CILINDRO;
    contEv-&gt;value = value;
}

QACTIVE_POST(AO_DataBroker, contEv, me);</action>
        <tran_glyph conn="332,178,3,-1,13">
         <action box="0,-2,18,2"/>
        </tran_glyph>
       </tran>
       <tran trig="CONTROL_DATA">
        <action>ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);

ControlType control = contEv-&gt;control;
int value = contEv-&gt;value;
int icon = ceil(value / 5);

if(contEv-&gt;control == POTENCIA) {
    me-&gt;state.control.potencia = value;

    char potStr[100] = {0};
    strcpy(potStr, itoa(value, potStr, 10));

    postUart_setString(CONTROL_POTENCIA_TEXT_VP, potStr, true, CONTROL_POTENCIA_TEXT_LEN); 
    postUart_setIcon(CONTROL_POTENCIA_ICON_VP, icon);
} else if(contEv-&gt;control == CILINDRO) {
    me-&gt;state.control.cilindro = value;

    char cilStr[100] = {0};
    strcpy(cilStr, itoa(value, cilStr, 10));
    
    postUart_setString(CONTROL_CILINDRO_TEXT_VP, cilStr, true, CONTROL_POTENCIA_TEXT_LEN); 
    postUart_setIcon(CONTROL_CILINDRO_ICON_VP, icon);
} else if(contEv-&gt;control == TURBINA) {
    int icon = 0;

    if(value == 0) {
        me-&gt;state.control.turbina = TOGGLE_OFF;
        icon = 0;
    } else if(value == 70) {
        me-&gt;state.control.turbina = TOGGLE_SEVENTY;
        icon = 1;
    } else if(value == 80) {
        me-&gt;state.control.turbina = TOGGLE_EIGHTY;
        icon = 2;
    } else if(value == 90) {
        me-&gt;state.control.turbina = TOGGLE_NINETY;
        icon = 3;
    } else if(value == 100) {
        me-&gt;state.control.turbina = TOGGLE_MAX;
        icon = 4;
    }

     postUart_setIcon(CONTROL_TURBINA_ICON_VP, icon);
} else if(contEv-&gt;control == RESFRIADOR) {
    int icon = 0;

    if(value == 0) {
        icon = 0;
        me-&gt;state.control.resfriador = TOGGLE_OFF;
    } else {
        icon = 4;
        me-&gt;state.control.resfriador = TOGGLE_MAX;
    }
    postUart_setIcon(CONTROL_RESFRIADOR_ICON_VP, icon);
}

</action>
        <tran_glyph conn="332,182,3,-1,13">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="332,163,60,24">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="auto_page">
       <entry>Ihm_setupPageAutoMode();</entry>
       <history type="deep" target="../3">
        <history_glyph conn="415,196,0,0,3,-43,13"/>
       </history>
       <tran trig="CHART_DATA">
        <action>ChartDataEvt *chartEv = Q_EVT_CAST(ChartDataEvt);
SensorType type = chartEv-&gt;type;
TempData *tempData = chartEv-&gt;temp_data;
int max = chartEv-&gt;max;
int min = chartEv-&gt;min;

if(type == SENSOR_GRAO) {
    Ihm_postTemperatures(VP_CHART_LINE_GRAO, SENSOR_GRAO, tempData-&gt;temps, tempData-&gt;count, 0, 390, 272, 93, true, 320, max, min, 204, false);
    //Ihm_postTemperatures(VP_CHART_CIRCLE_GRAO, GRAO, deltas_grao, temps_grao_count, 0, 390, 272, 173, true, 320, sensorEv-&gt;sensorData-&gt;max_temp_delta, sensorEv-&gt;sensorData-&gt;min_temp_delta, 204, true);
} else if(type == SENSOR_AR) {    
    Ihm_postTemperatures(VP_CHART_LINE_AR, SENSOR_AR, tempData-&gt;temps, tempData-&gt;count, 0, 390, 272, 93, true, 320, max, min, 204, false);
    //Ihm_postTemperatures(VP_CHART_CIRCLE_AR, AR, deltas_ar, temps_ar_count, 0, 390, 272, 173, true, 320, sensorEv-&gt;sensorData-&gt;max_temp_delta, sensorEv-&gt;sensorData-&gt;min_temp_delta, 204, true);
}</action>
        <tran_glyph conn="337,240,5,-1,9">
         <action box="0,-2,16,2"/>
        </tran_glyph>
       </tran>
       <tran trig="IHM_INPUT_TOUCH">
        <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
        <choice target="../../../2">
         <guard>ihmEv-&gt;length == 4</guard>
         <choice_glyph conn="351,205,4,2,-10,-4,-8">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../4">
         <guard>ihmEv-&gt;length == 2</guard>
         <choice_glyph conn="351,205,4,3,-10,58,-26,46">
          <action box="1,1,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard>ihmEv-&gt;length == 3</guard>
         <action>RequestNextStageEvt *stageEv = Q_NEW(RequestNextStageEvt, REQUEST_NEXT_STAGE_SIG);
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</action>
         <choice_glyph conn="351,205,5,-1,9">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="337,205,3,-1,14">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state name="auto_active">
        <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][ENTRY]&quot;);

postUart_setIcon(NAVBAR_ICON_HOME_VP, 0);
postUart_setIcon(NAVBAR_ICON_GEAR_VP, 1);

Ihm_resetChart(me);</entry>
        <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][EXIT]&quot;);</exit>
        <state name="auto_pre_heating">
         <entry>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][PRE_HEATING][ENTRY]&quot;);

</entry>
         <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][PRE_HEATING][EXIT]&quot;);</exit>
         <tran trig="NOTIFY_NEXT_STAGE" target="../../1/2">
          <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
          <tran_glyph conn="386,240,1,3,10">
           <action box="0,-2,10,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="356,235,30,16">
          <entry box="1,2,6,2"/>
          <exit box="1,4,6,2"/>
         </state_glyph>
        </state>
        <state name="auto_chart">
         <entry>ESP_LOGD(TAG, &quot;[AUTO_MODE][ACTIVE][CHART][ENTRY]&quot;);


QTimeEvt_armX(&amp;me-&gt;stageTimerEvt, STAGE_TIMER_INTERVAL, 0U);</entry>
         <exit>ESP_LOGD(TAG, &quot;[MANUAL_MODE][ACTIVE][CHART][EXIT]&quot;);

QTimeEvt_disarm(&amp;me-&gt;stageTimerEvt);
Ihm_resetChart(me);</exit>
         <tran trig="IHM_STAGE_TIMER_TIMEOUT">
          <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);

QTimeEvt_rearm(&amp;me-&gt;stageTimerEvt, STAGE_TIMER_INTERVAL);</action>
          <tran_glyph conn="390,226,3,-1,17">
           <action box="0,-2,10,2"/>
          </tran_glyph>
         </tran>
         <state name="auto_cooling">
          <entry>ESP_LOGD(TAG, &quot;[AUTO_MODE][ACTIVE][CHART][COOLING][ENTRY]&quot;);</entry>
          <exit>ESP_LOGD(TAG, &quot;[AUTO_MODE][ACTIVE][CHART][ROASTING][EXIT]&quot;);</exit>
          <tran trig="NOTIFY_NEXT_STAGE" target="../../../../../../2">
           <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
           <tran_glyph conn="462,240,1,3,15,6,40,4,1">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <state_glyph node="429,232,33,17">
           <entry box="1,2,6,2"/>
           <exit box="1,4,6,2"/>
          </state_glyph>
         </state>
         <state name="auto_roasting">
          <entry>ESP_LOGD(TAG, &quot;[AUTO_MODE][ACTIVE][CHART][ROASTING][ENTRY]&quot;);

RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
stageEv-&gt;substage = F;
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</entry>
          <exit>ESP_LOGD(TAG, &quot;[AUTO_MODE][ACTIVE][CHART][ROASTING][EXIT]&quot;);

NotifySubstageExitEvt *stageEv = Q_NEW(NotifySubstageExitEvt, NOTIFY_SUBSTAGE_EXIT_SIG);
QHSM_DISPATCH((QHsm *)&amp;me-&gt;substage, stageEv, me-&gt;super.prio);</exit>
          <tran trig="NOTIFY_NEXT_STAGE" target="../../1">
           <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;stage, e, me-&gt;super.prio);</action>
           <tran_glyph conn="426,239,1,3,3">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <tran trig="IHM_INPUT_TOUCH">
           <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
           <choice>
            <guard brief="SUBSTAGE">ihmEv-&gt;length == 5</guard>
            <action>QHSM_DISPATCH((QHsm *)&amp;me-&gt;substage, e, me-&gt;super.prio);</action>
            <choice_glyph conn="408,243,5,-1,8">
             <action box="1,0,10,2"/>
            </choice_glyph>
           </choice>
           <tran_glyph conn="396,243,3,-1,12">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <tran trig="NOTIFY_NEXT_SUBSTAGE">
           <action>NotifyNextSubstageEvt *subEv = Q_EVT_CAST(NotifyNextSubstageEvt);

QHSM_DISPATCH((QHsm *)&amp;me-&gt;substage, subEv, me-&gt;super.prio);</action>
           <tran_glyph conn="396,246,3,-1,11">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <state_glyph node="396,232,30,17">
           <entry box="1,2,6,2"/>
           <exit box="1,4,6,2"/>
          </state_glyph>
         </state>
         <state_glyph node="390,217,74,36">
          <entry box="1,2,6,2"/>
          <exit box="1,4,6,2"/>
         </state_glyph>
        </state>
        <state_glyph node="352,212,116,45">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="337,196,155,67">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="auto_config">
       <entry>ESP_LOGD(TAG, &quot;[CONFIG][ENTRY]&quot;);

ESP_LOGE(TAG, &quot;size: %d&quot;, sizeof(unsigned short));

Ihm_setupPageConfig();
RequestConfigEvt *confEv = Q_NEW(RequestConfigEvt, REQUEST_CONFIG_SIG);
QACTIVE_POST(AO_DataBroker, confEv, me);</entry>
       <exit>ESP_LOGD(TAG, &quot;[CONFIG][EXIT]&quot;);</exit>
       <tran trig="IHM_INPUT_TOUCH">
        <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
        <choice target="../../../3" cpref="../../../3/0">
         <guard>ihmEv-&gt;length == 3</guard>
         <choice_glyph conn="470,172,4,0,16,-55,7">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="455,172,3,-1,15">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="IHM_INPUT_CONFIG_SAVE" target="../../3" cpref="../../3/0">
        <action>IhmInputConfigSaveEvt *ev = Q_EVT_CAST(IhmInputConfigSaveEvt);

ConfigUpdateEvt *confEv = Q_NEW(ConfigUpdateEvt, CONFIG_UPDATE_SIG);
confEv-&gt;pre_heat = ev-&gt;pre;
confEv-&gt;roast = ev-&gt;roast;

QACTIVE_POST(AO_DataBroker, confEv, me);</action>
        <tran_glyph conn="465,186,2,0,7,-50,2">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="RESPONSE_CONFIG">
        <action>ResponseConfigEvt *respEv = Q_EVT_CAST(ResponseConfigEvt);

//POST to uart
postUart_setNumber(CONFIG_PRE_HEAT_NUMBER_VP, respEv-&gt;pre_heat);
postUart_setNumber(CONFIG_ROAST_NUMBER_VP, respEv-&gt;roast);</action>
        <tran_glyph conn="455,180,3,-1,10">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="455,160,36,26">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="325,156,169,117"/>
     </state>
     <state_glyph node="320,146,232,137">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="600,469"/>
   </statechart>
  </class>
  <class name="DataBroker" superclass="qpc::QActive">
   <attribute name="config" type="Config" visibility="0x02" properties="0x00"/>
   <attribute name="curr_roast" type="RoastData" visibility="0x02" properties="0x00"/>
   <attribute name="curr_recipe" type="RecipeData" visibility="0x02" properties="0x00"/>
   <attribute name="recipeTimerEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <attribute name="timer_start" type="time_t" visibility="0x02" properties="0x00"/>
   <attribute name="next_command" type="CommandData" visibility="0x02" properties="0x00"/>
   <operation name="updateSensorData" type="void" visibility="0x02" properties="0x00">
    <parameter name="type" type="SensorType"/>
    <parameter name="value" type="int"/>
    <parameter name="enqueue" type="bool"/>
    <code>SensorData *data = &amp;(me-&gt;curr_roast.sensor_data);
TempData *arData = &amp;data-&gt;ar;
TempData *graoData = &amp;data-&gt;grao;
int *max = &amp;data-&gt;max;
int *min = &amp;data-&gt;min;
int *max_delta = &amp;data-&gt;max_delta;
int *min_delta = &amp;data-&gt;min_delta;
int *grao_aux = &amp;data-&gt;grao_aux;
int *ar_aux = &amp;data-&gt;ar_aux;

if(enqueue) {
    if(value &gt; *max) {
       *max = value;
    } else if(value &lt; *min) {
       *min = value;
    }

    if(type == SENSOR_GRAO &amp;&amp; graoData-&gt;count &gt; 0) {
        int value_cmp = (value - graoData-&gt;deltas[graoData-&gt;count-1])*10;

        if(value_cmp &gt; *max_delta) {
           *max_delta = value_cmp;
        } else if(value_cmp &lt; *min_delta) {
            *min_delta = value_cmp;
        }
    } else if(type == SENSOR_AR &amp;&amp; graoData-&gt;count &gt; 0) {
        int value_cmp = (value - graoData-&gt;deltas[graoData-&gt;count-1])*10;

        if(value_cmp &gt; *max_delta) {
            *max_delta = value_cmp;
        } else if(value_cmp &lt; *min_delta) {
            *min_delta = value_cmp;
        }
    }

/*
    if(type == SENSOR_GRAO) {
        printf(&quot;Grao temps: &quot;);
        for(int i=0; i&lt;graoData-&gt;count; i++) {
            printf(&quot;%d, &quot;, graoData-&gt;temps[i]);
        }
        printf(&quot;\n&quot;);

        printf(&quot;Grao deltas: &quot;);
        for(int i=0; i&lt;graoData-&gt;count; i++) {
            printf(&quot;%d, &quot;, graoData-&gt;deltas[i]);
        }
        printf(&quot;\n&quot;);
    } else if(type == SENSOR_AR) {
        printf(&quot;Ar temps: &quot;);
        for(int i=0; i&lt;arData-&gt;count; i++) {
            printf(&quot;%d, &quot;, arData-&gt;temps[i]);
        }
        printf(&quot;\n&quot;);

        printf(&quot;Ar deltas: &quot;);
        for(int i=0; i&lt;arData-&gt;count; i++) {
            printf(&quot;%d, &quot;, arData-&gt;deltas[i]);
        }
        printf(&quot;\n&quot;);
    }
*/

    if(type == SENSOR_GRAO) {
        if(graoData-&gt;count &lt; 31) {
            int new_count = graoData-&gt;count+1;
            graoData-&gt;count = new_count;
            graoData-&gt;temps[new_count-1] = value;
            
            if(graoData-&gt;count &gt; 1) {
                graoData-&gt;deltas[new_count-1] = value - graoData-&gt;temps[new_count-2];
            } else if(graoData-&gt;count == 1) {
                graoData-&gt;deltas[0] = 0;
            }
        } else {
            graoData-&gt;temps[*grao_aux] = (graoData-&gt;temps[*grao_aux] + graoData-&gt;temps[*grao_aux+1]) / 2;
            graoData-&gt;deltas[*grao_aux] = (graoData-&gt;deltas[*grao_aux] + graoData-&gt;deltas[(*grao_aux)+1]) / 2;
            for(int i=(*grao_aux)+1; i &lt; 30; i++) {
                graoData-&gt;temps[i] = graoData-&gt;temps[i+1];
                graoData-&gt;deltas[i] = graoData-&gt;deltas[i+1];
            }
            graoData-&gt;temps[30] = value;
            graoData-&gt;deltas[30] = value - graoData-&gt;temps[29];

            (*grao_aux)++;
            *grao_aux = (*grao_aux) % 25;
        }
    } else if(type == SENSOR_AR) {
        if(arData-&gt;count &lt; 31) {
            int new_count = arData-&gt;count + 1;
            arData-&gt;count = new_count;
            arData-&gt;temps[new_count-1] = value;
            
            if(arData-&gt;count &gt; 1) {
                arData-&gt;deltas[new_count-1] = value - arData-&gt;temps[new_count-2];
            } else if(arData-&gt;count == 1) {
                arData-&gt;deltas[0] = 0;
            }
        } else {
            arData-&gt;temps[*ar_aux] = (arData-&gt;temps[*ar_aux] + arData-&gt;temps[(*ar_aux)+1]) / 2;
            arData-&gt;deltas[*ar_aux] = (arData-&gt;deltas[*ar_aux] + arData-&gt;deltas[(*ar_aux)+1]) / 2;
            for(int i=(*ar_aux)+1; i &lt; 30; i++) {
                arData-&gt;temps[i] = arData-&gt;temps[i+1];
                arData-&gt;deltas[i] = arData-&gt;deltas[i+1];
            }
            arData-&gt;temps[30] = value;
            arData-&gt;deltas[30] = value - arData-&gt;temps[29];
            
            (*ar_aux)++;
            *ar_aux = (*ar_aux) % 25;
        }
    }
} 

if(type == SENSOR_GRAO) {
    graoData-&gt;temp = value;
    if(graoData-&gt;count &gt; 5)
        graoData-&gt;delta = value - graoData-&gt;temps[graoData-&gt;count - 6];
} else if(type == SENSOR_AR) {
    arData-&gt;temp = value;
    if(arData-&gt;count &gt; 5)
        arData-&gt;delta = value - arData-&gt;temps[arData-&gt;count - 6];
}


</code>
   </operation>
   <operation name="setupRecipe" type="void" visibility="0x02" properties="0x00">
    <code>me-&gt;curr_recipe.count = 0;
me-&gt;curr_recipe.curr_command = 0;

storage_get_recipe_data(me-&gt;curr_recipe.name, &amp;me-&gt;curr_recipe);</code>
   </operation>
   <operation name="resetData" type="void" visibility="0x02" properties="0x00">
    <code>DataBroker_resetConfig(me);
DataBroker_resetRoast(me);
DataBroker_resetRecipe(me);

me-&gt;timer_start = 0;</code>
   </operation>
   <operation name="resetConfig" type="void" visibility="0x02" properties="0x00">
    <code>uint16_t pre_heat = 0;
uint16_t roast = 0;
storage_get_global_config(&amp;pre_heat, &amp;roast);

me-&gt;config.max_pre_heat = pre_heat;
me-&gt;config.max_roast = roast;</code>
   </operation>
   <operation name="resetRoast" type="void" visibility="0x02" properties="0x00">
    <code>me-&gt;curr_roast.time_start = 0;
me-&gt;curr_roast.time_end = 0;

me-&gt;curr_roast.sensor_data.ar.count = 0;
me-&gt;curr_roast.sensor_data.ar.temp = 0;
me-&gt;curr_roast.sensor_data.ar.delta = 0;
/*
me-&gt;sensor_data.ar.temps = {0};
me-&gt;sensor_data.ar.deltas = {0};
*/

me-&gt;curr_roast.sensor_data.grao.count = 0;
me-&gt;curr_roast.sensor_data.grao.temp = 0;
me-&gt;curr_roast.sensor_data.grao.delta = 0;
/*
me-&gt;sensor_data.grao.temps = {0};
me-&gt;sensor_data.grao.deltas = {0};
*/

me-&gt;curr_roast.sensor_data.max = 0;
me-&gt;curr_roast.sensor_data.min = 0;
me-&gt;curr_roast.sensor_data.max_delta = 0;
me-&gt;curr_roast.sensor_data.min_delta = 0;

strcpy(me-&gt;curr_roast.name, &quot;&quot;);</code>
   </operation>
   <operation name="resetRecipe" type="void" visibility="0x02" properties="0x00">
    <code>/*
me-&gt;curr_recipe.intervals = {0};
me-&gt;curr_recipe.controls = {0};
me-&gt;curr_recipe.values = {0};
*/
me-&gt;curr_recipe.count = 0;
strcpy(me-&gt;curr_recipe.name, &quot;&quot;);</code>
   </operation>
   <operation name="loadDataConfig" type="void" visibility="0x02" properties="0x00">
    <code>ESP_LOGV(TAG, &quot;[DATA_BROKER][LOAD_DATA_CONFIG]&quot;);


storage_get_global_config(&amp;me-&gt;config.max_pre_heat, &amp;me-&gt;config.max_roast);</code>
   </operation>
   <statechart properties="0x00">
    <initial target="../1/2">
     <initial_glyph conn="69,8,5,0,-12,7">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="state1">
     <tran trig="CONFIG_UPDATE">
      <action>ConfigUpdateEvt *confEv = Q_EVT_CAST(ConfigUpdateEvt);

storage_set_global_config(confEv-&gt;pre_heat, confEv-&gt;roast);

ESP_LOGV(TAG, &quot;Setting new Config: %d - %d&quot;, confEv-&gt;pre_heat, confEv-&gt;roast);</action>
      <tran_glyph conn="12,143,3,-1,23">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <tran trig="REQUEST_DATA">
      <action>RequestDataEvt *reqEv = Q_EVT_CAST(RequestDataEvt);
DataType type = reqEv-&gt;type;
Data data = reqEv-&gt;data;</action>
      <choice>
       <guard brief="PAGE_CONFIG">type == DATA_PAGE &amp;&amp; data.page_data.page == PAGE_CONFIG</guard>
       <action>postIhm_respondData(DATA_PAGE, (Data) {
    .page_data.type = PAGE_CONFIG,
    .page_data.config_data.max_pre_heat = me-&gt;config.max_pre_heat;
    .page_data.config_data.max_roast = me-&gt;config.max_roast;
});</action>
       <choice_glyph conn="35,156,5,-1,6,9">
        <action box="-5,12,16,2"/>
       </choice_glyph>
      </choice>
      <choice>
       <guard brief="PAGE_CONTROLS">type == DATA_PAGE &amp;&amp; data.page_data.page == PAGE_CONTROLS</guard>
       <action>postIhm_respondData(DATA_PAGE, (Data) {
    .page_data.type = PAGE_CONTROLS,
    .page_data.config_data.sensor_grao = me-&gt;curr_roast.sensor_data.grao.temp;
    .page_data.config_data.sensor_ar = me-&gt;curr_roast.sensor_data.ar.temp;
    .page_data.config_data.potencia = me-&gt;curr_roast.control_data.potencia;
    .page_data.config_data.cilindro = me-&gt;curr_roast.control_data.cilindro;
    .page_data.config_data.turbina = me-&gt;curr_roast.control_data.turbina;
    .page_data.config_data.resfriador = me-&gt;curr_roast.control_data.resfriador;
});</action>
       <choice_glyph conn="35,156,5,-1,20,9">
        <action box="12,12,17,3"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="12,156,3,-1,23">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <state name="idle">
      <entry>ESP_LOGI(TAG, &quot;[IDLE][ENTRY]&quot;);

memset(&amp;me-&gt;config, 0, sizeof(Config));
DataBroker_loadDataConfig();</entry>
      <exit>ESP_LOGI(TAG, &quot;[IDLE][EXIT]&quot;);</exit>
      <tran trig="REQUEST_RECIPES">
       <action>RequestRecipesEvt *recipesEvt = Q_EVT_CAST(RequestRecipesEvt);
uint8_t pageNum = recipesEvt-&gt;pageNum;

RecipesResponse res = {0};
int ret = storage_get_recipes_page(pageNum, &amp;res);

if(ret != -1) {
    uint8_t resPageNum = res.pageNum;
    char roast1[25];
    strcpy(roast1, res.roast1);
    char roast2[25];
    strcpy(roast2, res.roast2);
    char roast3[25];
    strcpy(roast3, res.roast3);

    bool prevPage = res.prevPage;
    bool nextPage = res.nextPage;
    
    ResponseRecipesEvt *rre = Q_NEW(ResponseRecipesEvt, RESPONSE_RECIPES_SIG);
    rre-&gt;pageNum = res.pageNum;
    strcpy(rre-&gt;roast1, res.roast1);
    strcpy(rre-&gt;roast2, res.roast2);
    strcpy(rre-&gt;roast3, res.roast3);
    rre-&gt;prevPage = res.prevPage;
    rre-&gt;nextPage = res.nextPage;
    
    QACTIVE_POST(AO_Ihm, &amp;rre-&gt;super, me);
} else {
    ESP_LOGE(TAG, &quot;Algo deu errado ao buscar as receitas&quot;);
}</action>
       <tran_glyph conn="18,30,3,-1,28">
        <action box="0,-2,18,2"/>
       </tran_glyph>
      </tran>
      <tran trig="REQUEST_RECIPE">
       <action>RequestRecipeEvt *reqEvt = Q_EVT_CAST(RequestRecipeEvt);
char *roast = reqEvt-&gt;roast;

SensorData sensorData = {0};
RoastResponse res = {0};
res.sensorData = &amp;sensorData;

int ret = storage_get_roast(roast, &amp;res);

if(ret != -1) {
    ResponseRecipeEvt *rre = Q_NEW(ResponseRecipeEvt, RESPONSE_RECIPE_SIG);
    strcpy(rre-&gt;roast, res.roast);    
    rre-&gt;sensorData = res.sensorData;
    
    QACTIVE_POST(AO_Ihm, &amp;rre-&gt;super, me);
} else {
    ESP_LOGE(TAG, &quot;Algo deu errado ao buscar a receita %s&quot;, roast);
}</action>
       <tran_glyph conn="18,39,3,-1,28">
        <action box="0,-2,21,2"/>
       </tran_glyph>
      </tran>
      <tran trig="REQUEST_MODE">
       <action>RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);</action>
       <choice target="../../../4">
        <guard brief="MODE_MANUAL">rme-&gt;mode == MODE_MANUAL</guard>
        <action>NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
nme-&gt;mode = MODE_MANUAL;
strcpy(nme-&gt;roast,&quot;&quot;);
QACTIVE_POST(AO_Perif, &amp;nme-&gt;super, me);

NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
nme2-&gt;mode = MODE_MANUAL;
strcpy(nme2-&gt;roast,&quot;&quot;);
QACTIVE_POST(AO_Ihm, &amp;nme2-&gt;super, me);

/*
me-&gt;curr_mode.mode = MODE_MANUAL;
strcpy(me-&gt;curr_mode.roast, rme-&gt;roast);
*/</action>
        <choice_glyph conn="108,32,4,3,-11,17">
         <action box="1,-11,17,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../3/2/2">
        <guard brief="MODE_AUTO">rme-&gt;mode == MODE_AUTO</guard>
        <action>NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
nme-&gt;mode = MODE_AUTO;
strcpy(nme-&gt;roast, rme-&gt;roast);
QACTIVE_POST(AO_Perif, &amp;nme-&gt;super, me);

NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
nme2-&gt;mode = MODE_AUTO;
strcpy(nme2-&gt;roast,rme-&gt;roast);
QACTIVE_POST(AO_Ihm, &amp;nme2-&gt;super, me);

DataBroker_resetData(me);

strcpy(me-&gt;curr_recipe.name, rme-&gt;roast);</action>
        <choice_glyph conn="108,32,4,3,66,2">
         <action box="0,6,16,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="88,32,1,-1,20">
        <action box="0,-2,24,3"/>
       </tran_glyph>
      </tran>
      <tran trig="REQUEST_ROASTS">
       <action>RequestRoastsEvt *roastsEvt = Q_EVT_CAST(RequestRoastsEvt);
uint8_t pageNum = roastsEvt-&gt;pageNum;

RoastsResponse res = {0};
int ret = storage_get_roasts_page(pageNum, &amp;res);

if(ret != -1) {
    uint8_t resPageNum = res.pageNum;
    char roast1[25];
    strcpy(roast1, res.roast1);
    char roast2[25];
    strcpy(roast2, res.roast2);
    char roast3[25];
    strcpy(roast3, res.roast3);

    bool prevPage = res.prevPage;
    bool nextPage = res.nextPage;
    
    ResponseRoastsEvt *rre = Q_NEW(ResponseRoastsEvt, RESPONSE_ROASTS_SIG);
    rre-&gt;pageNum = res.pageNum;
    strcpy(rre-&gt;roast1, res.roast1);
    strcpy(rre-&gt;roast2, res.roast2);
    strcpy(rre-&gt;roast3, res.roast3);
    rre-&gt;prevPage = res.prevPage;
    rre-&gt;nextPage = res.nextPage;
    
    QACTIVE_POST(AO_Ihm, &amp;rre-&gt;super, me);
} else {
    ESP_LOGE(TAG, &quot;Algo deu errado ao buscar as torras&quot;);
}</action>
       <tran_glyph conn="18,48,3,-1,28">
        <action box="0,-2,18,2"/>
       </tran_glyph>
      </tran>
      <tran trig="REQUEST_ROAST">
       <action>RequestRoastEvt *reqEvt = Q_EVT_CAST(RequestRoastEvt);
char *roast = reqEvt-&gt;roast;

SensorData sensorData = {0};
RoastResponse res = {0};
res.sensorData = &amp;sensorData;

int ret = storage_get_roast(roast, &amp;res);

if(ret != -1) {
    ResponseRoastEvt *rre = Q_NEW(ResponseRoastEvt, RESPONSE_ROAST_SIG);
    strcpy(rre-&gt;roast, res.roast);    
    rre-&gt;sensorData = res.sensorData;
    
    QACTIVE_POST(AO_Ihm, &amp;rre-&gt;super, me);
} else {
    ESP_LOGE(TAG, &quot;Algo deu errado ao buscar a torra %s&quot;, roast);
}</action>
       <tran_glyph conn="18,53,3,-1,29">
        <action box="0,-2,19,2"/>
       </tran_glyph>
      </tran>
      <tran trig="REQUEST_TRANSFORM_ROAST">
       <action>ESP_LOGE(TAG, &quot;transinawoe&quot;);
RequestTransformRoastEvt *rtr = Q_EVT_CAST(RequestTransformRoastEvt);

char roast[25];
strcpy(roast, rtr-&gt;roast);

storage_transform_roast(roast);</action>
       <tran_glyph conn="18,61,3,-1,29">
        <action box="0,-2,32,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="18,15,70,100">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="active_mode">
      <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][ENTRY]&quot;);

//me-&gt;pre_heat_value = 0;
//me-&gt;cooler_value = 0;


</entry>
      <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][ENTRY]&quot;);


</exit>
      <tran trig="CONTROL_UPDATE">
       <action>ControlUpdateEvt *contEv = Q_EVT_CAST(ControlUpdateEvt);
QACTIVE_POST(AO_Perif, contEv, me);</action>
       <tran_glyph conn="99,148,3,-1,23">
        <action box="0,-2,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="REQUEST_MODE">
       <action>RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);</action>
       <choice target="../../../2">
        <guard>rme-&gt;mode == MODE_NONE</guard>
        <action>NotifyModeEvt *nme = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
nme-&gt;mode = MODE_NONE;
strcpy(nme-&gt;roast,&quot;&quot;);
QACTIVE_POST(AO_Perif, &amp;nme-&gt;super, me);

NotifyModeEvt *nme2 = Q_NEW(NotifyModeEvt, NOTIFY_MODE_SIG);
nme2-&gt;mode = MODE_NONE;
strcpy(nme2-&gt;roast,&quot;&quot;);
QACTIVE_POST(AO_Ihm, &amp;nme2-&gt;super, me);

/*
me-&gt;curr_mode.mode = MODE_NONE;
strcpy(me-&gt;curr_mode.roast, rme-&gt;roast);
*/</action>
        <choice_glyph conn="109,68,4,1,-12,-21">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="109,76,0,-1,-8">
        <action box="2,-13,21,2"/>
       </tran_glyph>
      </tran>
      <state name="pre_heating">
       <entry>storage_create_new_roast(&amp;me-&gt;curr_roast.name);</entry>
       <tran trig="SENSOR_UPDATE">
        <action>SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);
SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
sensorDataEv-&gt;type = sensorEv-&gt;type;
sensorDataEv-&gt;value = sensorEv-&gt;value;
sensorDataEv-&gt;delta = 0;
QACTIVE_POST(AO_Ihm, sensorDataEv, me);

DataBroker_updateSensorData(me, sensorEv-&gt;type, sensorEv-&gt;value, false);</action>
        <tran_glyph conn="104,108,3,-1,17">
         <action box="0,-2,16,2"/>
        </tran_glyph>
       </tran>
       <tran trig="CONTROL_DATA">
        <action>ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
QACTIVE_POST(AO_Ihm, contEv, me);

storage_add_roast_control_record(0, contEv-&gt;control, contEv-&gt;value);</action>
        <tran_glyph conn="104,110,3,-1,17">
         <action box="0,-2,17,2"/>
        </tran_glyph>
       </tran>
       <state name="auto_pre_heating">
        <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][AUTO_PRE_HEATING][ENTRY]&quot;);

ESP_LOGE(TAG, &quot;recipe: %s&quot;, me-&gt;curr_recipe.name);
DataBroker_setupRecipe(me);</entry>
        <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][AUTO_PRE_HEATING][EXIT]&quot;);</exit>
        <tran trig="REQUEST_NEXT_STAGE" target="../../../3/3">
         <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = true;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = true;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);</action>
         <tran_glyph conn="146,94,1,3,16,2,15">
          <action box="0,-2,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="110,86,36,20">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="manual_pre_heating">
        <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][MANUAL_PRE_HEATING][ENTRY]&quot;);

ControlUpdateEvt *potEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
potEv-&gt;control = POTENCIA;
potEv-&gt;value = 100;
QACTIVE_POST(AO_Perif, potEv, me);

ControlUpdateEvt *cilEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
potEv-&gt;control = CILINDRO;
potEv-&gt;value = 100;
QACTIVE_POST(AO_Perif, cilEv, me);

ControlUpdateEvt *turbEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
potEv-&gt;control = TURBINA;
potEv-&gt;value = 70;
QACTIVE_POST(AO_Perif, turbEv, me);</entry>
        <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][MANUAL_PRE_HEATING][EXIT]&quot;);</exit>
        <tran trig="REQUEST_NEXT_STAGE" target="../../../3/4">
         <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);</action>
         <tran_glyph conn="147,120,1,3,14,2,14">
          <action box="0,-2,16,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="111,111,36,20">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="104,82,49,51">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="roasting">
       <entry>time_t time_now;
time(&amp;time_now);

me-&gt;curr_roast.time_start = time_now;
me-&gt;timer_start = time_now;

int count = me-&gt;curr_roast.sensor_data.grao.count;

if(count &gt; 0)
    storage_add_roast_pre_heat_record(0, me-&gt;curr_roast.sensor_data.grao.temps[count-1]);
else
    storage_add_roast_pre_heat_record(0, 0);</entry>
       <tran trig="SENSOR_UPDATE">
        <action>SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);
SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
sensorDataEv-&gt;type = sensorEv-&gt;type;
sensorDataEv-&gt;value = sensorEv-&gt;value;


time_t time_now;
time(&amp;time_now);
time_t time_elapsed = time_now - me-&gt;curr_roast.time_start;

if(time_elapsed % 5 == 0) {
    storage_add_roast_sensor_record(time_elapsed, sensorEv-&gt;type, sensorEv-&gt;value);
    DataBroker_updateSensorData(me, sensorEv-&gt;type, sensorEv-&gt;value, true);

    ChartDataEvt *chartEv = Q_NEW(ChartDataEvt, CHART_DATA_SIG);
    chartEv-&gt;type = sensorEv-&gt;type;

    if(sensorEv-&gt;type == SENSOR_GRAO)
        chartEv-&gt;temp_data = &amp;me-&gt;curr_roast.sensor_data.grao;
    else if(sensorEv-&gt;type == SENSOR_AR)
        chartEv-&gt;temp_data = &amp;me-&gt;curr_roast.sensor_data.ar;

    chartEv-&gt;max = me-&gt;curr_roast.sensor_data.max;
    chartEv-&gt;min = me-&gt;curr_roast.sensor_data.min;

    QACTIVE_POST(AO_Ihm, chartEv, me);
} else {
    DataBroker_updateSensorData(me, sensorEv-&gt;type, sensorEv-&gt;value, false);
}



if(sensorDataEv-&gt;type == SENSOR_GRAO)
    sensorDataEv-&gt;delta = me-&gt;curr_roast.sensor_data.grao.delta;
else if(sensorDataEv-&gt;type == SENSOR_AR)
    sensorDataEv-&gt;delta = me-&gt;curr_roast.sensor_data.ar.delta;


QACTIVE_POST(AO_Ihm, sensorDataEv, me);</action>
        <tran_glyph conn="170,109,3,-1,14">
         <action box="0,-2,16,2"/>
        </tran_glyph>
       </tran>
       <tran trig="CONTROL_DATA">
        <action>ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
QACTIVE_POST(AO_Ihm, contEv, me);

time_t time_now;
time(&amp;time_now);

time_t time_elapsed = time_now - me-&gt;curr_roast.time_start;

storage_add_roast_control_record(time_elapsed, contEv-&gt;control, contEv-&gt;value);</action>
        <tran_glyph conn="170,111,3,-1,14">
         <action box="0,-2,17,2"/>
        </tran_glyph>
       </tran>
       <tran trig="REQUEST_NEXT_SUBSTAGE">
        <action>RequestNextSubstageEvt *subEv = Q_EVT_CAST(RequestNextSubstageEvt);
time_t time_now;
time(&amp;time_now);

time_t time_elapsed = time_now - me-&gt;curr_roast.time_start;


if(subEv-&gt;substage == Q1)
    storage_add_roast_q1_record(time_elapsed);

if(subEv-&gt;substage == Q2)
    storage_add_roast_q2_record(time_elapsed);


NotifyNextSubstageEvt *stageEv = Q_NEW(NotifyNextSubstageEvt, NOTIFY_NEXT_SUBSTAGE_SIG);
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);</action>
        <tran_glyph conn="218,110,1,-1,-9">
         <action box="-14,-3,10,2"/>
        </tran_glyph>
       </tran>
       <state name="auto_roasting">
        <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][AUTO_ROASTING][ENTRY]&quot;);

time_t time_now;
time(&amp;time_now);

time_t time_elapsed = time_now - me-&gt;curr_roast.time_start;
time_t time_command = (me-&gt;curr_recipe.intervals[me-&gt;curr_recipe.curr_command] - time_elapsed);

if(time_command &lt;= 0)
    time_command = 1;

if(me-&gt;curr_recipe.curr_command &lt; me-&gt;curr_recipe.count) {
    ESP_LOGD(TAG, &quot;Scheduled command %d for %lds - value: %d&quot;, me-&gt;curr_recipe.controls[me-&gt;curr_recipe.curr_command], time_command, me-&gt;curr_recipe.values[me-&gt;curr_recipe.curr_command]);
    
/*
    if(me-&gt;curr_recipe.controls[me-&gt;curr_recipe.curr_command] == POTENCIA) {
        sprintf(me-&gt;next_command.command, &quot;POTENCIA: %d&quot;, me-&gt;curr_recipe.values[me-&gt;curr_recipe.curr_command]);
        me-&gt;next_command.time = time_command;
    } else if(me-&gt;curr_recipe.controls[me-&gt;curr_recipe.curr_command] == CILINDRO) {
        sprintf(me-&gt;next_command.command, &quot;CILINDRO: %d&quot;, me-&gt;curr_recipe.values[me-&gt;curr_recipe.curr_command]);
        me-&gt;next_command.time = time_command;    
    } else if(me-&gt;curr_recipe.controls[me-&gt;curr_recipe.curr_command] == TURBINA) {
        sprintf(me-&gt;next_command.command, &quot;TURBINA: %d&quot;, me-&gt;curr_recipe.values[me-&gt;curr_recipe.curr_command]);
        me-&gt;next_command.time = time_command;
    }

    */
    QTimeEvt_armX(&amp;me-&gt;recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
}</entry>
        <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][AUTO_ROASTING][EXIT]&quot;);</exit>
        <tran trig="REQUEST_NEXT_STAGE" target="../../../4/2">
         <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = true;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = true;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);</action>
         <tran_glyph conn="210,95,1,3,16,1,2">
          <action box="0,-2,10,2"/>
         </tran_glyph>
        </tran>
        <tran trig="DATA_RECIPE_TIMEOUT">
         <action>QTimeEvt_disarm(&amp;me-&gt;recipeTimerEvt);

ControlType control = me-&gt;curr_recipe.controls[me-&gt;curr_recipe.curr_command];
int value = me-&gt;curr_recipe.values[me-&gt;curr_recipe.curr_command];

ControlUpdateEvt *contEv = Q_NEW(ControlUpdateEvt, CONTROL_UPDATE_SIG);
contEv-&gt;control = control;
contEv-&gt;value = value;
QACTIVE_POST(AO_Perif, contEv, me);

me-&gt;curr_recipe.curr_command += 1;

time_t time_now;
time(&amp;time_now);

time_t time_elapsed = time_now - me-&gt;curr_roast.time_start;
time_t time_command = (me-&gt;curr_recipe.intervals[me-&gt;curr_recipe.curr_command] - time_elapsed);

if(time_command &lt;= 0)
    time_command = 1;

if(me-&gt;curr_recipe.curr_command &lt; me-&gt;curr_recipe.count) {
    ESP_LOGD(TAG, &quot;Scheduled command %d for %lds - value: %d&quot;, me-&gt;curr_recipe.controls[me-&gt;curr_recipe.curr_command], time_command, me-&gt;curr_recipe.values[me-&gt;curr_recipe.curr_command]);
    QTimeEvt_armX(&amp;me-&gt;recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
}
</action>
         <tran_glyph conn="177,99,3,-1,28">
          <action box="0,-2,27,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="177,87,33,20">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="manual_roasting">
        <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][MANUAL_ROASTING][ENTRY]&quot;);</entry>
        <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][MANUAL_ROASTING][EXIT]&quot;);</exit>
        <tran trig="REQUEST_NEXT_STAGE" target="../../../4/3">
         <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);</action>
         <tran_glyph conn="211,122,1,0,14,-1">
          <action box="0,-2,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="175,113,36,20">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="170,83,48,53">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="cooling">
       <entry>time_t time_now;
time(&amp;time_now);

time_t time_elapsed = time_now - me-&gt;curr_roast.time_start;

int count = me-&gt;curr_roast.sensor_data.grao.count;

if(count &gt; 0)
    storage_add_roast_cooler_record(time_elapsed, me-&gt;curr_roast.sensor_data.grao.temps[count-1]);
else
    storage_add_roast_cooler_record(time_elapsed, 0);</entry>
       <tran trig="SENSOR_UPDATE">
        <action>SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);
SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
sensorDataEv-&gt;type = sensorEv-&gt;type;
sensorDataEv-&gt;value = sensorEv-&gt;value;
sensorDataEv-&gt;delta = 0;
QACTIVE_POST(AO_Ihm, sensorDataEv, me);</action>
        <tran_glyph conn="221,108,3,-1,4,-1,4,1,4">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="CONTROL_DATA">
        <action>ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
QACTIVE_POST(AO_Ihm, contEv, me);

time_t time_now;
time(&amp;time_now);

time_t time_elapsed = time_now - me-&gt;curr_roast.time_start;
storage_add_roast_control_record(time_elapsed, contEv-&gt;control, contEv-&gt;value);</action>
        <tran_glyph conn="221,110,3,-1,13">
         <action box="0,-2,16,3"/>
        </tran_glyph>
       </tran>
       <state name="auto_cooling">
        <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][AUTO_COOLING][ENTRY]&quot;);</entry>
        <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][AUTO_COOLING][EXIT]&quot;);

QTimeEvt_disarm(&amp;me-&gt;recipeTimerEvt);</exit>
        <tran trig="REQUEST_NEXT_STAGE" target="../../../5/2">
         <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = true;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = true;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);</action>
         <tran_glyph conn="257,94,1,3,25">
          <action box="0,-2,10,2"/>
         </tran_glyph>
        </tran>
        <tran trig="DATA_RECIPE_TIMEOUT">
         <action>QTimeEvt_disarm(&amp;me-&gt;recipeTimerEvt);
/*
ControlType control = me-&gt;recipe_commands.controls[me-&gt;curr_command];
int value = me-&gt;recipe_commands.values[me-&gt;curr_command];

UpdateControlEvt *contEv = Q_NEW(UpdateControlEvt, UPDATE_CONTROL_SIG);
contEv-&gt;control = control;
contEv-&gt;value = value;
QACTIVE_POST(AO_Perif, contEv, me);

me-&gt;curr_command += 1;

time_t time_now;
time(&amp;time_now);

time_t time_elapsed = time_now - me-&gt;time_start;
time_t time_command = (me-&gt;recipe_commands.intervals[me-&gt;curr_command] - time_elapsed);

if(time_command &lt;= 0)
    time_command = 1;

if(me-&gt;curr_command &lt; me-&gt;recipe_commands.count) {
    ESP_LOGD(TAG, &quot;Scheduled command %d for %lds - value: %d&quot;, me-&gt;recipe_commands.controls[me-&gt;curr_command], time_command, me-&gt;recipe_commands.values[me-&gt;curr_command]);
    QTimeEvt_armX(&amp;me-&gt;recipeTimerEvt, time_command * CONFIG_FREERTOS_HZ, 0U);
}
*/</action>
         <tran_glyph conn="228,99,3,-1,23">
          <action box="0,-2,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="228,87,29,20">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="manual_cooling">
        <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][MANUAL_COOLING][ENTRY]&quot;);</entry>
        <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][MANUAL_COOLING][EXIT]&quot;);</exit>
        <tran trig="REQUEST_NEXT_STAGE" target="../../../5/1">
         <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);</action>
         <tran_glyph conn="261,122,1,3,17">
          <action box="0,-2,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="225,111,36,20">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="221,82,43,54">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="summary">
       <entry>//storage_get_current_roast_summary(&amp;me-&gt;temps_ar, &amp;me-&gt;temps_grao, &amp;me-&gt;temps_count_ar, &amp;me-&gt;temps_count_grao);</entry>
       <exit>DataBroker_resetData(me);</exit>
       <tran trig="REQUEST_SUMMARY">
        <action>RequestSummaryEvt *reqEv = Q_EVT_CAST(RequestSummaryEvt);

ResponseSummaryEvt *resEv = Q_NEW(ResponseSummaryEvt, RESPONSE_SUMMARY_SIG);
strcpy(resEv-&gt;name, me-&gt;curr_roast.name);

QACTIVE_POST(AO_Ihm, resEv, me);</action>
        <tran_glyph conn="271,108,3,-1,11">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state name="manual_summary">
        <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][MANUAL_SUMMARY][ENTRY]&quot;);

</entry>
        <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][MANUAL_SUMMARY][EXIT]&quot;);</exit>
        <tran trig="REQUEST_NEXT_STAGE" target="../../../2/3">
         <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);</action>
         <tran_glyph conn="292,132,2,2,13,-150,-14">
          <action box="0,-2,22,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="278,112,36,20">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="auto_summary">
        <entry>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][AUTO_COOLING][ENTRY]&quot;);</entry>
        <exit>ESP_LOGI(TAG, &quot;[ACTIVE_MODE][AUTO_COOLING][EXIT]&quot;);</exit>
        <tran trig="REQUEST_NEXT_STAGE" target="../../../2/2">
         <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = true;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = true;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);</action>
         <tran_glyph conn="291,87,0,0,-19,-166,18">
          <action box="0,-2,23,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="282,87,29,20">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="271,82,44,54">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="99,76,221,88">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="sensoring">
      <entry>ESP_LOGI(TAG, &quot;[MANUAL_MODE][MANUAL_IDLE][ENTRY]&quot;);
</entry>
      <exit>ESP_LOGI(TAG, &quot;[MANUAL_MODE][MANUAL_IDLE][EXIT]&quot;);

/*
DataBroker_sensorData.temps_grao_count = 0;
DataBroker_sensorData.temps_ar_count = 0;
DataBroker_sensorData.deltas_ar[0] = 0;
DataBroker_sensorData.deltas_grao[0] = 0;
*/</exit>
      <tran trig="SENSOR_UPDATE">
       <action>SensorUpdateEvt *sensorEv = Q_EVT_CAST(SensorUpdateEvt);

SensorDataEvt *sensorDataEv = Q_NEW(SensorDataEvt, SENSOR_DATA_SIG);
sensorDataEv-&gt;type = sensorEv-&gt;type;
sensorDataEv-&gt;value = sensorEv-&gt;value;
sensorDataEv-&gt;delta = 0;
QACTIVE_POST(AO_Ihm, sensorDataEv, me);

DataBroker_updateSensorData(me, sensorEv-&gt;type, sensorEv-&gt;value, false);</action>
       <tran_glyph conn="125,30,3,-1,19">
        <action box="0,-2,19,2"/>
       </tran_glyph>
      </tran>
      <tran trig="REQUEST_MODE">
       <action>RequestModeEvt *rme = Q_EVT_CAST(RequestModeEvt);</action>
       <choice target="../../../2">
        <guard brief="EXIT_MODE">rme-&gt;mode == MODE_NONE</guard>
        <choice_glyph conn="138,6,5,0,-61,9">
         <action box="-20,2,11,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="142,15,0,-1,-9,-4">
        <action box="3,-6,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="REQUEST_NEXT_STAGE" target="../../3/2/3">
       <action>NotifyNextStageEvt *stageEv = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Ihm, &amp;stageEv-&gt;super, me);

NotifyNextStageEvt *stageEv2 = Q_NEW(NotifyNextStageEvt, NOTIFY_NEXT_STAGE_SIG);
stageEv-&gt;auto_mode = false;
QACTIVE_POST(AO_Perif, &amp;stageEv2-&gt;super, me);

DataBroker_resetData(me);</action>
       <tran_glyph conn="136,35,2,3,22,-30,66,5">
        <action box="-16,23,23,2"/>
       </tran_glyph>
      </tran>
      <tran trig="CONTROL_UPDATE">
       <action>ControlUpdateEvt *contEv = Q_EVT_CAST(ControlUpdateEvt);
QACTIVE_POST(AO_Perif, contEv, me);</action>
       <tran_glyph conn="125,26,3,-1,21">
        <action box="0,-2,21,2"/>
       </tran_glyph>
      </tran>
      <tran trig="CONTROL_DATA">
       <action>ControlDataEvt *contEv = Q_EVT_CAST(ControlDataEvt);
QACTIVE_POST(AO_Ihm, contEv, me);</action>
       <tran_glyph conn="160,25,1,-1,-10">
        <action box="-17,-4,19,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="125,15,35,20">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="12,10,330,171"/>
    </state>
    <state_diagram size="535,271"/>
   </statechart>
  </class>
  <class name="Uart" superclass="qpc::QActive">
   <attribute name="uartQueue" type="QueueHandle_t" visibility="0x00" properties="0x00"/>
   <operation name="uartTask" type="void" visibility="0x02" properties="0x01">
    <parameter name="pvParameters" type="void *"/>
    <code>Uart *me = &amp;l_uart;    
uart_event_t uart_event;

ESP_LOGI(TAG, &quot;Getting system time&quot;);
//Uart_requestSetRTCTime();
Uart_requestGetRTCTime();

    for (;;) {
        if (xQueueReceive(me-&gt;uartQueue, (void *)&amp;uart_event, portMAX_DELAY)) {
            size_t buffer_size = uart_event.size;
            uint8_t data[128];

            /* Checa se o tipo de evento é do tipo 0 (DATA), se não for, analisar pq pode ser fonte de bugs */
            if (uart_event.type == 0) {
                uart_read_bytes(UART_NUM, data, buffer_size, portMAX_DELAY);

                Uart_processEvent(data, 0, buffer_size);
            } else {
                ESP_LOGE(TAG, &quot;[UNKNOWN UART EVENT]: %d&quot;, uart_event.type);
            }
        }
    }</code>
   </operation>
   <operation name="processEvent" type="void" visibility="0x02" properties="0x01">
    <parameter name="data" type="uint8_t *"/>
    <parameter name="start" type="int"/>
    <parameter name="end" type="int"/>
    <code>/*
Se não conter um header, é um touch release.
Se conter, é um input no slider
*/

/*
for(int i=start; i&lt;end; i++)
    printf(&quot;%d |&quot;, data[i]);
printf(&quot;\n&quot;);
*/

if(data[start] != '\x5A') {
    if (end - start &gt;= 24) {
        unsigned short pre = 0, cool = 0;
        memcpy(&amp;pre, &amp;data[start], sizeof(unsigned short));
        swapbytes(&amp;pre, sizeof(unsigned short));

        memcpy(&amp;cool, &amp;data[start] + 4 + sizeof(unsigned short), sizeof(unsigned short));
        swapbytes(&amp;cool, sizeof(unsigned short));

        UartInputConfigSaveEvt *uic = Q_NEW(UartInputConfigSaveEvt, UART_INPUT_CONFIG_SAVE_SIG);
        uic-&gt;pre = pre;
        uic-&gt;cool = cool;

        QACTIVE_POST(AO_Uart, &amp;uic-&gt;super, me);
    } else {
        UartInputTouchEvt *ure = Q_NEW(UartInputTouchEvt, UART_INPUT_TOUCH_SIG);
        ure-&gt;length = end-start;

        ESP_LOGE(TAG, &quot;[TOUCH], Length: %d&quot;, (end-start));
        QACTIVE_POST(AO_Uart, &amp;ure-&gt;super, me);
    }
} else {
    if(data[3] == 129) {
/*
    time_t timestamp = 0;
    
    memcpy(&amp;timestamp, &amp;data[start+6], sizeof(time_t));
    swapbytes(&amp;timestamp, sizeof(time_t));
    ESP_LOGE(TAG, &quot;timestamp: %ld&quot;, timestamp);

    Uart_setRTCTime(timestamp);

    time_t time_now;
    time(&amp;time_now);

    ESP_LOGE(TAG, &quot;Time now: %ld&quot;, time_now);
*/
    } else {
        UartInputSliderEvt *ure = Q_NEW(UartInputSliderEvt, UART_INPUT_SLIDER_SIG);

        unsigned short int vp = 0;
        unsigned short int value = 0;
        ControlType controlType = CONTROL_NONE;

        memcpy(&amp;vp, data+4, sizeof(unsigned short int));
        memcpy(&amp;value, data+7, sizeof(unsigned short int));
        swapbytes(&amp;vp, sizeof(unsigned short int));
        swapbytes(&amp;value, sizeof(unsigned short int));
        
        if(vp == 80) {
            controlType = POTENCIA;
        } else if(vp == 82) {
            controlType = CILINDRO;
        } else {
            ESP_LOGE(TAG, &quot;Unknown slider event&quot;);
        }

        ure-&gt;control = controlType;
        ure-&gt;value = value;

        ESP_LOGI(TAG, &quot;[SLIDER]: Type: %d, value %d&quot;, controlType, value);
        QACTIVE_POST(AO_Uart, &amp;ure-&gt;super, me);
    }
}</code>
   </operation>
   <operation name="changePage" type="void" visibility="0x00" properties="0x01">
    <parameter name="picid" type="unsigned short int"/>
    <code>unsigned char container[MAX_CONTAINER_SIZE];

ESP_LOGI(TAG, &quot;[CHANGE PAGE]: %u&quot;, picid);
swapbytes(&amp;picid, sizeof(unsigned short int));

int length = packet_picid(&amp;picid, container);

ESP_LOGD(TAG, &quot;[UART CONTAINER]: [&quot;);
for (int i = 0; i &lt; length; i++) {
    ESP_LOGD(TAG, &quot;%2.2X &quot;, container[i]);
}
ESP_LOGD(TAG, &quot;]\n&quot;);

uart_write_bytes(UART_NUM, container, length);</code>
   </operation>
   <operation name="changeIcon" type="void" visibility="0x00" properties="0x01">
    <parameter name="vp" type="unsigned short int"/>
    <parameter name="icon" type="unsigned short int"/>
    <code>unsigned char container[MAX_CONTAINER_SIZE];

swapbytes(&amp;vp, sizeof(vp));
swapbytes(&amp;icon, sizeof(icon));
int length = packet_write_vp(vp, &amp;icon, sizeof(unsigned short int), container);

//print_container(container, length);
uart_write_bytes(UART_NUM, container, length);</code>
   </operation>
   <operation name="changeText" type="void" visibility="0x00" properties="0x01">
    <parameter name="vp" type="unsigned short int"/>
    <parameter name="text" type="const char *"/>
    <code>unsigned char container[MAX_CONTAINER_SIZE];

swapbytes(&amp;vp, sizeof(vp));
int length = packet_write_vp(vp, text, strlen(text), container);

uart_write_bytes(UART_NUM, container, length);</code>
   </operation>
   <operation name="changeGraphicsCircle" type="void" visibility="0x00" properties="0x01">
    <parameter name="vp" type="unsigned short int"/>
    <parameter name="temperatures" type="int *"/>
    <parameter name="count" type="unsigned short int"/>
    <parameter name="sensor" type="SensorType"/>
    <parameter name="minX" type="int"/>
    <parameter name="maxX" type="int"/>
    <parameter name="minY" type="int"/>
    <parameter name="maxY" type="int"/>
    <parameter name="delta" type="bool"/>
    <parameter name="deltaX" type="int"/>
    <parameter name="maxTemp" type="int"/>
    <code>unsigned char container[MAX_CONTAINER_SIZE];
unsigned char payload_container[MAX_PAYLOAD_SIZE];

unsigned short int color = 0;
if(sensor == SENSOR_GRAO) {
    color = COLOR_GRAO;
} else {
    color = COLOR_AR;
}

swapbytes(&amp;vp, sizeof(vp));
int payload_length = packet_graphics_circles(temperatures, count, color, minX, maxX, minY, maxY, delta, deltaX, maxTemp, payload_container);
int length = packet_write_vp(vp, payload_container, payload_length, container);

uart_write_bytes(UART_NUM, container, length);</code>
   </operation>
   <operation name="changeGraphicsLine" type="void" visibility="0x00" properties="0x01">
    <parameter name="vp" type="unsigned short int"/>
    <parameter name="values" type="int *"/>
    <parameter name="count" type="unsigned short int"/>
    <parameter name="sensor" type="SensorType"/>
    <parameter name="minX" type="int"/>
    <parameter name="maxX" type="int"/>
    <parameter name="minY" type="int"/>
    <parameter name="maxY" type="int"/>
    <parameter name="deltaBound" type="bool"/>
    <parameter name="deltaBoundX" type="int"/>
    <parameter name="maxTemp" type="int"/>
    <parameter name="minTemp" type="int"/>
    <parameter name="originY" type="int"/>
    <parameter name="isDelta" type="bool"/>
    <code>unsigned char container[MAX_CONTAINER_SIZE];
unsigned char payload_container[MAX_PAYLOAD_SIZE];

unsigned short int color = 0;
if(sensor == SENSOR_GRAO) {
    color = COLOR_GRAO;
} else {
    color = COLOR_AR;
}

swapbytes(&amp;vp, sizeof(vp));
int payload_length = packet_graphics_lines(values, count, color, minX, maxX, minY, maxY, deltaBound, deltaBoundX, minTemp, maxTemp, originY, isDelta, payload_container);
int length = packet_write_vp(vp, payload_container, payload_length, container);

uart_write_bytes(UART_NUM, container, length);</code>
   </operation>
   <operation name="changeChart" type="void" visibility="0x00" properties="0x01">
    <parameter name="vp" type="unsigned short int"/>
    <parameter name="sensor" type="SensorType"/>
    <parameter name="values" type="int *"/>
    <parameter name="count" type="unsigned short int"/>
    <parameter name="minX" type="int"/>
    <parameter name="maxX" type="int"/>
    <parameter name="minY" type="int"/>
    <parameter name="maxY" type="int"/>
    <parameter name="deltaBound" type="bool"/>
    <parameter name="deltaBoundX" type="int"/>
    <parameter name="minTemp" type="int"/>
    <parameter name="maxTemp" type="int"/>
    <parameter name="originY" type="int"/>
    <parameter name="isDelta" type="bool"/>
    <code>if(sensor == SENSOR_AR) {
    Uart_changeGraphicsLine(vp, values, count, sensor, minX, maxX, minY, maxY, deltaBound, deltaBoundX, maxTemp, minTemp, originY, isDelta);
} else {
    Uart_changeGraphicsLine(vp, values, count, sensor, minX, maxX, minY, maxY, deltaBound, deltaBoundX, maxTemp, minTemp, originY, isDelta);
}</code>
   </operation>
   <operation name="changeNumber" type="void" visibility="0x00" properties="0x01">
    <parameter name="vp" type="unsigned short int"/>
    <parameter name="value" type="unsigned short"/>
    <code>unsigned char container[MAX_CONTAINER_SIZE];

swapbytes(&amp;vp, sizeof(vp));
swapbytes(&amp;value, sizeof(unsigned short));
int length = packet_write_vp(vp, &amp;value, sizeof(unsigned short), container);

uart_write_bytes(UART_NUM, container, length);</code>
   </operation>
   <operation name="requestGetRTCTime" type="void" visibility="0x00" properties="0x01">
    <code>unsigned char container[MAX_CONTAINER_SIZE];
unsigned char reg = 0x20;
unsigned char payload = 7;

int length = packet_read_register(&amp;reg, &amp;payload, sizeof(unsigned char), container);

ESP_LOGE(TAG, &quot;Sending: &quot;);
for(int i=0; i&lt;length; i++)
        printf(&quot;%x |&quot;, container[i]);
    printf(&quot;\n&quot;);

uart_write_bytes(UART_NUM, container, length);</code>
   </operation>
   <operation name="requestSetRTCTime" type="void" visibility="0x00" properties="0x01">
    <code>unsigned char container[MAX_CONTAINER_SIZE];
unsigned char reg = 0x1F;
time_t payload = 1670445;

ESP_LOGE(TAG, &quot;STILL SETTING&quot;);

swapbytes(&amp;payload, sizeof(time_t));
int length = packet_write_register(&amp;reg, &amp;payload, sizeof(time_t), container);

uart_write_bytes(UART_NUM, container, length);</code>
   </operation>
   <operation name="setRTCTime" type="void" visibility="0x00" properties="0x01">
    <parameter name="sec" type="time_t"/>
    <code>struct timeval tm_vl;
    int sreturn;

    tm_vl.tv_sec= sec;
    tm_vl.tv_usec= 0;

    sreturn=settimeofday(&amp;tm_vl, NULL);

    if (sreturn== 0)
    {
        printf(&quot;settimeofday is executed without any error\n&quot;);
    }
    else {
        printf(&quot;settimeofday is unsuccessful &quot;);
    }</code>
   </operation>
   <statechart properties="0x00">
    <initial target="../1">
     <initial_glyph conn="6,2,4,0,2,17,5">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="state1">
     <tran trig="UART_INPUT_TOUCH">
      <action>UartInputTouchEvt *uev = Q_EVT_CAST(UartInputTouchEvt);

IhmInputTouchEvt *iev = Q_NEW(IhmInputTouchEvt, IHM_INPUT_TOUCH_SIG);
iev-&gt;length = uev-&gt;length;

QACTIVE_POST(AO_Ihm, &amp;iev-&gt;super, me);</action>
      <tran_glyph conn="10,20,3,-1,26">
       <action box="0,-2,20,2"/>
      </tran_glyph>
     </tran>
     <tran trig="UART_INPUT_SLIDER">
      <action>UartInputSliderEvt *uev = Q_EVT_CAST(UartInputSliderEvt);
ControlType control = uev-&gt;control;
int value = uev-&gt;value;

IhmInputSliderEvt *iev = Q_NEW(IhmInputSliderEvt, IHM_INPUT_SLIDER_SIG);
iev-&gt;control = control;
iev-&gt;value = value;

QACTIVE_POST(AO_Ihm, &amp;iev-&gt;super, me);</action>
      <tran_glyph conn="10,23,3,-1,26">
       <action box="0,-2,21,2"/>
      </tran_glyph>
     </tran>
     <tran trig="UART_OUTPUT_PAGE">
      <action>UartOutputPageEvt *uev = Q_EVT_CAST(UartOutputPageEvt);

Uart_changePage(uev-&gt;picid);</action>
      <tran_glyph conn="10,26,3,-1,26">
       <action box="0,-2,22,2"/>
      </tran_glyph>
     </tran>
     <tran trig="UART_OUTPUT_ICON">
      <action>UartOutputIconEvt *uev = Q_EVT_CAST(UartOutputIconEvt);

Uart_changeIcon(uev-&gt;vp, uev-&gt;icon);</action>
      <tran_glyph conn="10,29,3,-1,26">
       <action box="0,-2,22,2"/>
      </tran_glyph>
     </tran>
     <tran trig="UART_OUTPUT_TEXT">
      <action>UartOutputTextEvt *uev = Q_EVT_CAST(UartOutputTextEvt);

Uart_changeText(uev-&gt;vp, uev-&gt;text);</action>
      <tran_glyph conn="10,32,3,-1,26">
       <action box="0,-2,21,2"/>
      </tran_glyph>
     </tran>
     <tran trig="UART_OUTPUT_CHART">
      <action>UartOutputChartEvt *uev = Q_EVT_CAST(UartOutputChartEvt);

Uart_changeChart(uev-&gt;vp, uev-&gt;sensor, uev-&gt;values, uev-&gt;count, 
uev-&gt;minX, uev-&gt;maxX, uev-&gt;minY, uev-&gt;maxY, uev-&gt;deltaBound, uev-&gt;deltaBoundX, uev-&gt;minTemp, uev-&gt;maxTemp, uev-&gt;originY, uev-&gt;isDelta);</action>
      <tran_glyph conn="10,35,3,-1,26">
       <action box="0,-2,21,2"/>
      </tran_glyph>
     </tran>
     <tran trig="UART_INPUT_CONFIG_SAVE">
      <action>UartInputConfigSaveEvt *uic = Q_EVT_CAST(UartInputConfigSaveEvt);

IhmInputConfigSaveEvt *hic = Q_NEW(IhmInputConfigSaveEvt, IHM_INPUT_CONFIG_SAVE_SIG);
hic-&gt;pre = uic-&gt;pre;
hic-&gt;roast = uic-&gt;cool;

QACTIVE_POST(AO_Ihm, &amp;hic-&gt;super, me);</action>
      <tran_glyph conn="10,16,3,-1,26">
       <action box="0,-2,25,2"/>
      </tran_glyph>
     </tran>
     <tran trig="UART_OUTPUT_NUMBER">
      <action>UartOutputNumberEvt *uev = Q_EVT_CAST(UartOutputNumberEvt);

Uart_changeNumber(uev-&gt;vp, uev-&gt;value);</action>
      <tran_glyph conn="10,38,3,-1,26">
       <action box="0,-2,21,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="10,9,51,33"/>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <attribute name="AO_Server" type="QActive * const" visibility="0x00" properties="0x00"/>
  <attribute name="AO_Perif" type="QActive * const" visibility="0x00" properties="0x00"/>
  <attribute name="AO_Ihm" type="QActive * const" visibility="0x00" properties="0x00"/>
  <attribute name="AO_DataBroker" type="QActive * const" visibility="0x00" properties="0x00"/>
  <attribute name="AO_Uart" type="QActive * const" visibility="0x00" properties="0x00"/>
  <operation name="Uart_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Uart *me = &amp;l_uart;

uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
    };

ESP_ERROR_CHECK(uart_driver_install(UART_NUM, BUF_SIZE * 2, BUF_SIZE * 2, 30, &amp;me-&gt;uartQueue, 0));
ESP_ERROR_CHECK(uart_param_config(UART_NUM, &amp;uart_config));
ESP_ERROR_CHECK(uart_set_pin(UART_NUM, TXD_PIN, RXD_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));

xTaskCreate(Uart_uartTask, &quot;UART_TASK&quot;, 8192, NULL, 2, NULL);

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Uart_initial));</code>
  </operation>
  <operation name="Ihm_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Ihm *me = &amp;l_ihm;
IhmStage *stage = &amp;l_ihmStage;
IhmSubstage *substage = &amp;l_ihmSubstage;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Ihm_initial));
me-&gt;state.control = (ControlState){
    .potencia = 0,
    .cilindro = 0,
    .turbina = TOGGLE_OFF,
    .resfriador = TOGGLE_OFF
};

QHsm_ctor(&amp;me-&gt;stage, Q_STATE_CAST(&amp;IhmStage_initial));
QHsm_ctor(&amp;me-&gt;substage, Q_STATE_CAST(&amp;IhmSubstage_initial));

QTimeEvt_ctorX(&amp;me-&gt;stageTimerEvt, &amp;me-&gt;super, IHM_STAGE_TIMER_TIMEOUT_SIG, 0U);</code>
  </operation>
  <operation name="Perif_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Perif *me = &amp;l_perif;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Perif_initial));
QTimeEvt_ctorX(&amp;me-&gt;sensorTimeEvt, &amp;me-&gt;super, SENSOR_TIMEOUT_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;pwmTimeEvt, &amp;me-&gt;super, PWM_TIMEOUT_SIG, 0U);</code>
  </operation>
  <operation name="DataBroker_ctor" type="void" visibility="0x00" properties="0x00">
   <code>DataBroker *me = &amp;l_dataBroker;

QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;DataBroker_initial));
QTimeEvt_ctorX(&amp;me-&gt;recipeTimerEvt, &amp;me-&gt;super, DATA_RECIPE_TIMEOUT_SIG, 0U);</code>
  </operation>
 </package>
 <package name="Events" stereotype="0x01">
  <class name="UartInputTouchEvt" superclass="qpc::QEvt">
   <attribute name="length" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="IhmInputTouchEvt" superclass="qpc::QEvt">
   <attribute name="length" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="IhmInputSliderEvt" superclass="qpc::QEvt">
   <attribute name="control" type="ControlType" visibility="0x00" properties="0x00"/>
   <attribute name="value" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="NotifyNextStageEvt" superclass="qpc::QEvt">
   <attribute name="auto_mode" type="bool" visibility="0x00" properties="0x00"/>
  </class>
  <class name="RequestNextStageEvt" superclass="qpc::QEvt"/>
  <class name="UartInputSliderEvt" superclass="qpc::QEvt">
   <attribute name="control" type="ControlType" visibility="0x00" properties="0x00"/>
   <attribute name="value" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="UartOutputPageEvt" superclass="qpc::QEvt">
   <attribute name="picid" type="unsigned short int" visibility="0x00" properties="0x00"/>
  </class>
  <class name="UartOutputIconEvt" superclass="qpc::QEvt">
   <attribute name="vp" type="unsigned short int" visibility="0x00" properties="0x00"/>
   <attribute name="icon" type="unsigned short int" visibility="0x00" properties="0x00"/>
  </class>
  <class name="UartOutputTextEvt" superclass="qpc::QEvt">
   <attribute name="vp" type="unsigned short int" visibility="0x00" properties="0x00"/>
   <attribute name="text" type="const char *" visibility="0x00" properties="0x00"/>
  </class>
  <class name="UartOutputChartEvt" superclass="qpc::QEvt">
   <attribute name="vp" type="unsigned short int" visibility="0x00" properties="0x00"/>
   <attribute name="values" type="int *" visibility="0x00" properties="0x00"/>
   <attribute name="sensor" type="SensorType" visibility="0x00" properties="0x00"/>
   <attribute name="count" type="unsigned short int" visibility="0x00" properties="0x00"/>
   <attribute name="minX" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="maxX" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="minY" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="maxY" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="deltaBound" type="bool" visibility="0x00" properties="0x00"/>
   <attribute name="deltaBoundX" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="maxTemp" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="minTemp" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="originY" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="isDelta" type="bool" visibility="0x00" properties="0x00"/>
  </class>
  <class name="RequestModeEvt" superclass="qpc::QEvt">
   <attribute name="mode" type="ModeType" visibility="0x00" properties="0x00"/>
   <attribute name="roast[25]" type="char" visibility="0x00" properties="0x00"/>
  </class>
  <class name="SensorUpdateEvt" superclass="qpc::QEvt">
   <attribute name="type" type="SensorType" visibility="0x00" properties="0x00"/>
   <attribute name="value" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="PerifStartEvt" superclass="qpc::QEvt"/>
  <class name="PerifStopEvt" superclass="qpc::QEvt"/>
  <class name="ControlUpdateEvt" superclass="qpc::QEvt">
   <attribute name="control" type="ControlType" visibility="0x00" properties="0x00"/>
   <attribute name="value" type="int" visibility="0x00" properties="0x00"/>
  </class>
  <class name="ControlDataEvt" superclass="qpc::QEvt">
   <attribute name="control" type="ControlType" visibility="0x00" properties="0x00"/>
   <attribute name="value" type="int" visibility="0x00" properties="0x00"/>
  </class>
  <class name="SensorDataEvt" superclass="qpc::QEvt">
   <attribute name="type" type="SensorType" visibility="0x00" properties="0x00"/>
   <attribute name="value" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="delta" type="int" visibility="0x00" properties="0x00"/>
  </class>
  <class name="RequestTransformRoastEvt" superclass="qpc::QEvt">
   <attribute name="roast[25]" type="char" visibility="0x00" properties="0x00"/>
  </class>
  <class name="NotifyModeEvt" superclass="qpc::QEvt">
   <attribute name="mode" type="ModeType" visibility="0x00" properties="0x00"/>
   <attribute name="roast[25]" type="char" visibility="0x00" properties="0x00"/>
  </class>
  <class name="NotifyNextSubstageEvt" superclass="qpc::QEvt"/>
  <class name="RequestNextSubstageEvt" superclass="qpc::QEvt">
   <attribute name="substage" type="SubstageType" visibility="0x00" properties="0x00"/>
  </class>
  <class name="UartInputConfigSaveEvt" superclass="qpc::QEvt">
   <attribute name="pre" type="unsigned short" visibility="0x00" properties="0x00"/>
   <attribute name="cool" type="unsigned short" visibility="0x00" properties="0x00"/>
  </class>
  <class name="IhmInputConfigSaveEvt" superclass="qpc::QEvt">
   <attribute name="pre" type="unsigned short" visibility="0x00" properties="0x00"/>
   <attribute name="roast" type="unsigned short" visibility="0x00" properties="0x00"/>
  </class>
  <class name="ConfigUpdateEvt" superclass="qpc::QEvt">
   <attribute name="pre_heat" type="uint16_t" visibility="0x00" properties="0x00"/>
   <attribute name="roast" type="uint16_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="UartOutputNumberEvt" superclass="qpc::QEvt">
   <attribute name="vp" type="unsigned short int" visibility="0x00" properties="0x00"/>
   <attribute name="value" type="unsigned short" visibility="0x00" properties="0x00"/>
  </class>
  <class name="NotifySubstageExitEvt" superclass="qpc::QEvt"/>
  <class name="ChartDataEvt" superclass="qpc::QEvt">
   <attribute name="type" type="SensorType" visibility="0x00" properties="0x00"/>
   <attribute name="temp_data" type="TempData *" visibility="0x00" properties="0x00"/>
   <attribute name="max" type="int" visibility="0x00" properties="0x00"/>
   <attribute name="min" type="int" visibility="0x00" properties="0x00"/>
  </class>
  <class name="DataRequestEvt" superclass="qpc::QEvt">
   <attribute name="page" type="PageType" visibility="0x00" properties="0x00"/>
  </class>
  <class name="DataResponseEvt" superclass="qpc::QEvt">
   <attribute name="type" type="DataType" visibility="0x00" properties="0x00"/>
   <attribute name="data" type="Data" visibility="0x00" properties="0x00"/>
  </class>
 </package>
 <package name="Components" stereotype="0x02">
  <class name="IhmStage" superclass="qpc::QHsm">
   <attribute name="timer_start" type="time_t" visibility="0x00" properties="0x00"/>
   <operation name="setTimer" type="void" visibility="0x00" properties="0x00">
    <parameter name="reset" type="bool"/>
    <parameter name="visible" type="bool"/>
    <code>time_t rawtime;
struct tm *info;
char buffer[8];

time( &amp;rawtime );

if(reset) {
    me-&gt;timer_start = rawtime;
}

if(visible) {
    time_t elapsed = rawtime-me-&gt;timer_start;

    info = localtime( &amp;elapsed );
    strftime(buffer,80,&quot;%H:%M:%S&quot;, info);

    postUart_setString(STAGE_TIMER_TEXT_VP, buffer, false, STAGE_TIMER_TEXT_LEN);
} else {
    postUart_setString(STAGE_TIMER_TEXT_VP, &quot;\0&quot;, true, STAGE_TIMER_TEXT_LEN);
}

</code>
   </operation>
   <statechart properties="0x00">
    <initial target="../1">
     <initial_glyph conn="11,5,5,3,1,5,2">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="idle">
     <entry>ESP_LOGE(TAG, &quot;[STAGE][IDLE][ENTRY]&quot;);

postUart_setIcon(STAGE_STATUS_ICON_VP, 0);
postUart_setIcon(STAGE_BTN_ICON_VP, 0);</entry>
     <exit>ESP_LOGE(TAG, &quot;[STAGE][IDLE][EXIT]&quot;);</exit>
     <tran trig="NOTIFY_NEXT_STAGE" target="../../2">
      <tran_glyph conn="38,13,1,3,31,-2,2">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="14,5,24,13">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="pre_heating">
     <entry>ESP_LOGE(TAG, &quot;[STAGE][PRE_HEATING][ENTRY]&quot;);

postUart_setIcon(STAGE_STATUS_ICON_VP, 1);
postUart_setIcon(STAGE_BTN_ICON_VP, 1);</entry>
     <exit>ESP_LOGE(TAG, &quot;[STAGE][PRE_HEATING][EXIT]&quot;);</exit>
     <tran trig="NOTIFY_NEXT_STAGE" target="../../3/1">
      <tran_glyph conn="80,16,2,0,14,1,2">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="71,3,23,13">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="timing">
     <exit>IhmStage_setTimer(me, true, false);</exit>
     <tran trig="IHM_STAGE_TIMER_TIMEOUT">
      <action>IhmStage_setTimer(me, false, true);</action>
      <tran_glyph conn="37,29,3,-1,11">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="roasting">
      <entry>ESP_LOGE(TAG, &quot;[STAGE][ROASTING][ENTRY]&quot;);

postUart_setIcon(STAGE_STATUS_ICON_VP, 2);
postUart_setIcon(STAGE_BTN_ICON_VP, 2);

IhmStage_setTimer(me, true, true);</entry>
      <exit>ESP_LOGE(TAG, &quot;[STAGE][ROASTING][EXIT]&quot;);

IhmStage_setTimer(me, true, false);</exit>
      <tran trig="NOTIFY_NEXT_STAGE" target="../../2">
       <tran_glyph conn="70,39,3,2,-7">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="70,32,22,13">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="cooling">
      <entry>ESP_LOGE(TAG, &quot;[STAGE][COOLING][ENTRY]&quot;);

postUart_setIcon(STAGE_STATUS_ICON_VP, 3);
postUart_setIcon(STAGE_BTN_ICON_VP, 3);

IhmStage_setTimer(me, true, true);</entry>
      <exit>ESP_LOGE(TAG, &quot;[STAGE][COOLING][EXIT]&quot;);

IhmStage_setTimer(me, true, false);</exit>
      <tran trig="NOTIFY_NEXT_STAGE" target="../../../4">
       <tran_glyph conn="39,38,3,1,-13">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="39,32,24,13">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="37,23,58,23">
      <exit box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state name="summary">
     <entry>ESP_LOGE(TAG, &quot;[STAGE][SUMMARy][ENTRY]&quot;);</entry>
     <exit>ESP_LOGE(TAG, &quot;[STAGE][SUMMARy][EXIT]&quot;);</exit>
     <tran trig="NOTIFY_NEXT_STAGE" target="../../2">
      <tran_glyph conn="18,32,0,3,-11,27,-6,26">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="NOTIFY_MODE">
      <action>NotifyModeEvt *rme = Q_EVT_CAST(NotifyModeEvt);</action>
      <choice target="../../../1">
       <guard>rme-&gt;mode == MODE_NONE</guard>
       <choice_glyph conn="16,25,4,2,-7">
        <action box="1,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="16,32,0,-1,-7">
       <action box="-11,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="12,32,14,14">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="100,48"/>
   </statechart>
  </class>
  <class name="IhmSubstage" superclass="qpc::QHsm">
   <statechart properties="0x00">
    <initial target="../1">
     <initial_glyph conn="11,5,4,3,5,2">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="idle">
     <entry>ESP_LOGD(TAG, &quot;[SUBSTAGE][IDLE][ENTRY]&quot;);

postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 0);</entry>
     <exit>ESP_LOGD(TAG, &quot;[SUBSTAGE][IDLE][EXIT]&quot;);</exit>
     <tran trig="NOTIFY_NEXT_SUBSTAGE" target="../../2">
      <tran_glyph conn="37,11,1,0,42,22">
       <action box="0,-2,23,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="13,3,24,11">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="state1">
     <initial target="../3">
      <initial_glyph conn="79,37,5,0,-7,4">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <tran trig="NOTIFY_SUBSTAGE_EXIT" target="../../1">
      <tran_glyph conn="22,33,0,2,-19">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="q1">
      <entry>ESP_LOGD(TAG, &quot;[SUBSTAGE][Q1][ENTRY]&quot;);

postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 2);</entry>
      <exit>ESP_LOGD(TAG, &quot;[SUBSTAGE][PRE_HEATING][EXIT]&quot;);</exit>
      <tran trig="NOTIFY_NEXT_SUBSTAGE" target="../../4">
       <tran_glyph conn="35,48,3,1,-4">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="IHM_INPUT_TOUCH">
       <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
       <choice>
        <guard>ihmEv-&gt;length == 5</guard>
        <action>RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
stageEv-&gt;substage = Q2;
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</action>
        <choice_glyph conn="46,52,5,-1,3">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="35,52,3,-1,11">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="35,41,23,13">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="f">
      <entry>ESP_LOGD(TAG, &quot;[SUBSTAGE][F][ENTRY]&quot;);

postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 1);</entry>
      <exit>ESP_LOGD(TAG, &quot;[SUBSTAGE][F][EXIT]&quot;);</exit>
      <tran trig="NOTIFY_NEXT_SUBSTAGE" target="../../2">
       <tran_glyph conn="62,46,3,1,-4">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="IHM_INPUT_TOUCH">
       <action>IhmInputTouchEvt *ihmEv = Q_EVT_CAST(IhmInputTouchEvt);</action>
       <choice>
        <guard>ihmEv-&gt;length == 5</guard>
        <action>RequestNextSubstageEvt *stageEv = Q_NEW(RequestNextSubstageEvt, REQUEST_NEXT_SUBSTAGE_SIG);
stageEv-&gt;substage = Q1;
QACTIVE_POST(AO_DataBroker, &amp;stageEv-&gt;super, me);</action>
        <choice_glyph conn="73,50,5,-1,3">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="62,50,3,-1,11">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="62,41,22,13">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="q2">
      <entry>ESP_LOGD(TAG, &quot;[SUBSTAGE][Q2][ENTRY]&quot;);

postUart_setIcon(SUBSTAGE_BTN_ICON_VP, 0);</entry>
      <exit>ESP_LOGD(TAG, &quot;[SUBSTAGE][COOLING][EXIT]&quot;);</exit>
      <state_glyph node="7,41,24,13">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,33,87,28"/>
    </state>
    <state_diagram size="99,71"/>
   </statechart>
  </class>
 </package>
 <package name="Common" stereotype="0x05">
  <operation name="postUart_setPage" type="void" visibility="0x01" properties="0x00">
   <parameter name="picid" type="unsigned short int"/>
   <code>ESP_LOGV(TAG, &quot;[IHM_UART_SET_PAGE]&quot;);

UartOutputPageEvt *pageEv = Q_NEW(UartOutputPageEvt, UART_OUTPUT_PAGE_SIG);
pageEv-&gt;picid = picid;
QACTIVE_POST(AO_Uart, &amp;pageEv-&gt;super, me);</code>
  </operation>
  <operation name="postUart_setString" type="void" visibility="0x01" properties="0x01">
   <parameter name="vp" type="unsigned short int"/>
   <parameter name="text" type="char *"/>
   <parameter name="reset" type="bool"/>
   <parameter name="reset_len" type="size_t"/>
   <code>ESP_LOGV(TAG, &quot;[IHM_UART_SET_STRING]&quot;);

if(reset) {
    char resetStr[100] = {0};
    int i;

    for(i=0; i&lt;reset_len; i++)
        strcpy(&amp;resetStr[i], &quot; &quot;);

    i++;
    strcpy(&amp;resetStr[i], &quot;\0&quot;);
    //ESP_LOGE(TAG, &quot;Reseting to: %s - len: %d&quot;, resetStr, strlen(resetStr));

    UartOutputTextEvt *resetEv = Q_NEW(UartOutputTextEvt, UART_OUTPUT_TEXT_SIG);
    resetEv-&gt;vp = vp;
    resetEv-&gt;text = resetStr;
    QACTIVE_POST(AO_Uart, &amp;resetEv-&gt;super, me);
}

if(strlen(text) &gt; reset_len) {
    strcpy(&amp;text[reset_len-1], &quot;\0&quot;);
}

UartOutputTextEvt *textEv = Q_NEW(UartOutputTextEvt, UART_OUTPUT_TEXT_SIG);
textEv-&gt;vp = vp;
textEv-&gt;text = text;
QACTIVE_POST(AO_Uart, &amp;textEv-&gt;super, me);

</code>
  </operation>
  <operation name="postUart_setIcon" type="void" visibility="0x01" properties="0x01">
   <parameter name="vp" type="unsigned short int"/>
   <parameter name="icon" type="unsigned short int"/>
   <code>ESP_LOGV(TAG, &quot;[IHM_UART_SET_ICON]&quot;);

UartOutputIconEvt *iconEv = Q_NEW(UartOutputIconEvt, UART_OUTPUT_ICON_SIG);
iconEv-&gt;vp = vp;
iconEv-&gt;icon = icon;
QACTIVE_POST(AO_Uart, &amp;iconEv-&gt;super, me);</code>
  </operation>
  <operation name="postUart_setNumber" type="void" visibility="0x01" properties="0x01">
   <parameter name="vp" type="unsigned short int"/>
   <parameter name="value" type="unsigned short"/>
   <code>ESP_LOGV(TAG, &quot;[IHM_UART_SET_NUMBER]&quot;);

UartOutputNumberEvt *numberEv = Q_NEW(UartOutputNumberEvt, UART_OUTPUT_NUMBER_SIG);
numberEv-&gt;vp = vp;
numberEv-&gt;value = value;
QACTIVE_POST(AO_Uart, &amp;numberEv-&gt;super, me);

</code>
  </operation>
  <operation name="postData_requestData" type="void" visibility="0x01" properties="0x00">
   <parameter name="type" type="DataType"/>
   <parameter name="data" type="Data"/>
   <code>ESP_LOGV(TAG, &quot;[IHM_DATA_REQUEST_DATA]&quot;);

DataRequestEvt *reqEv = Q_NEW(DataRequestEvt, DATA_REQUEST_SIG);
reqEv-&gt;type = type;
reqEv-&gt;data = data;
QACTIVE_POST(AO_DataBroker, reqEv, me);</code>
  </operation>
  <operation name="postIhm_respondData" type="void" visibility="0x01" properties="0x00">
   <parameter name="type" type="DataType"/>
   <parameter name="data" type="Data"/>
   <code>ESP_LOGV(TAG, &quot;[DATA_IHM_RESPOND_DATA]&quot;);

DataResponseEvt *resEv = Q_NEW(DataResponseEvt, DATA_RESPONSE_SIG);
resEv-&gt;type = type;
resEv-&gt;data = data;
QACTIVE_POST(AO_Ihm, resEv, me);</code>
  </operation>
  <operation name="postUart_setNumberAsString" type="void" visibility="0x01" properties="0x01">
   <parameter name="vp" type="unsigned short int"/>
   <parameter name="text" type="char *"/>
   <parameter name="ext" type="char *"/>
   <parameter name="reset" type="bool"/>
   <parameter name="reset_len" type="size_t"/>
   <code>ESP_LOGV(TAG, &quot;[IHM_UART_SET_NUMBER_AS_STRING]&quot;);

if(reset) {
    char resetStr[100] = {0};
    int i;

    for(i=0; i&lt;reset_len; i++)
        strcpy(&amp;resetStr[i], &quot; &quot;);

    i++;
    strcpy(&amp;resetStr[i], &quot;\0&quot;);
    //ESP_LOGE(TAG, &quot;Reseting to: %s - len: %d&quot;, resetStr, strlen(resetStr));

    UartOutputTextEvt *resetEv = Q_NEW(UartOutputTextEvt, UART_OUTPUT_TEXT_SIG);
    resetEv-&gt;vp = vp;
    resetEv-&gt;text = resetStr;
    QACTIVE_POST(AO_Uart, &amp;resetEv-&gt;super, me);
}

if(strlen(text) &gt; reset_len) {
    strcpy(&amp;text[reset_len-1], &quot;\0&quot;);
}

char str[6] = {0};
sprintf(str, &quot;%d%s&quot;, value, ext);

UartOutputTextEvt *textEv = Q_NEW(UartOutputTextEvt, UART_OUTPUT_TEXT_SIG);
textEv-&gt;vp = vp;
textEv-&gt;text = str;
QACTIVE_POST(AO_Uart, &amp;textEv-&gt;super, me);

</code>
  </operation>
 </package>
 <directory name=".">
  <file name="main.c">
   <text>#include &quot;qpc.h&quot;
#include &quot;freertos/FreeRTOS.h&quot;
#include &quot;esp_log.h&quot;
#include &quot;nvs.h&quot;
#include &quot;nvs_flash.h&quot;
#include &quot;server_controller.h&quot;
#include &quot;common.h&quot;

Q_DEFINE_THIS_FILE

static const char *TAG = &quot;main&quot;;

/*
 * small event memory pool
 */
static QF_MPOOL_EL(QEvt) smallPoolSto[CONFIG_QPC_SMALL_POOL_SIZE];

/*
 * medium size event memory pool
 * size: QEvt + CONFIG_QPC_MEDIUM_POOL_ENTRY_SIZE words
 */
typedef struct {
    QEvt super;
    uint32_t data[CONFIG_QPC_MEDIUM_POOL_ENTRY_SIZE];
} mediumPool;
static QF_MPOOL_EL(mediumPool) mediumPoolSto[CONFIG_QPC_MEDIUM_POOL_SIZE];

/*
 * large size event memory pool
 * size: QEvt + CONFIG_QPC_LARGE_POOL_ENTRY_SIZE words
 */
typedef struct {
    QEvt super;
    uint32_t data[CONFIG_QPC_LARGE_POOL_ENTRY_SIZE];
} largePool;
static QF_MPOOL_EL(largePool) largePoolSto[CONFIG_QPC_LARGE_POOL_SIZE];

static QEvt const *ihmQueueSto[30];
static QEvt const *perifQueueSto[20];
static QEvt const *dataBrokerQueueSto[20];
static QEvt const *uartQueueSto[30];

static QSubscrList subscrSto[25];
static StackType_t ihmStack[10000];
static StackType_t perifStack[4096];
static StackType_t dataBrokerStack[24000];
static StackType_t uartStack[8192];

void setup_peripherals();
void storage_init();
void server_controller_init();

void app_main() {
    ESP_LOGI(TAG, &quot;Iniciando NVS&quot;);
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        // NVS partition was truncated and needs to be erased
        // Retry nvs_flash_init
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    ESP_ERROR_CHECK(err);
    ESP_LOGI(TAG, &quot;NVS Ok!&quot;);

    Uart_ctor();
    Ihm_ctor();
    Perif_ctor();
    DataBroker_ctor();
    setup_peripherals();
    storage_init();
    server_controller_init();

    QF_init();

    /* initialize publish-subscribe... */
    QF_psInit(subscrSto, Q_DIM(subscrSto));

    /* Initialize Event Memory Pool */
    QF_poolInit(smallPoolSto, sizeof(smallPoolSto), sizeof(smallPoolSto[0]));
    QF_poolInit(mediumPoolSto, sizeof(mediumPoolSto), sizeof(mediumPoolSto[0]));
    QF_poolInit(largePoolSto, sizeof(largePoolSto), sizeof(largePoolSto[0]));

    QActive_setAttr(AO_Uart, TASK_NAME_ATTR, &quot;UART&quot;);
    QACTIVE_START(AO_Uart,             /* AO to start */
                  (uint_fast8_t)(5),  /* QP priority of the AO */
                  uartQueueSto,        /* event queue storage */
                  Q_DIM(uartQueueSto), /* queue length [events] */
                  uartStack,           /* stack storage */
                  sizeof(uartStack),   /* stack size [bytes] */
                  (QEvt *)0);         /* initialization event (not used) */
    
    QActive_setAttr(AO_Ihm, TASK_NAME_ATTR, &quot;IHM&quot;);
    QACTIVE_START(AO_Ihm,             /* AO to start */
                  (uint_fast8_t)(4),  /* QP priority of the AO */
                  ihmQueueSto,        /* event queue storage */
                  Q_DIM(ihmQueueSto), /* queue length [events] */
                  ihmStack,           /* stack storage */
                  sizeof(ihmStack),   /* stack size [bytes] */
                  (QEvt *)0);         /* initialization event (not used) */
   
    QActive_setAttr(AO_Perif, TASK_NAME_ATTR, &quot;PERIF&quot;);
    QACTIVE_START(AO_Perif,             /* AO to start */
                  (uint_fast8_t)(3),    /* QP priority of the AO */
                  perifQueueSto,        /* event queue storage */
                  Q_DIM(perifQueueSto), /* queue length [events] */
                  perifStack,           /* stack storage */
                  sizeof(perifStack),   /* stack size [bytes] */
                  (QEvt *)0);           /* initialization event (not used) */

 QActive_setAttr(AO_DataBroker, TASK_NAME_ATTR, &quot;DATA_BROKER&quot;);
    QACTIVE_START(AO_DataBroker,             /* AO to start */
                  (uint_fast8_t)(2),   /* QP priority of the AO */
                  dataBrokerQueueSto,        /* event queue storage */
                  Q_DIM(dataBrokerQueueSto), /* queue length [events] */
                  dataBrokerStack,           /* stack storage */
                  sizeof(dataBrokerStack),   /* stack size [bytes] */
                  (QEvt *)0);          /* initialization event (not used) */

    /* start the active objects... */
    QF_run();

    ESP_LOGI(TAG, &quot;Goodbye app_main()&quot;);
}</text>
  </file>
  <file name="uart.c">
   <text>#include &quot;qpc.h&quot;
#include &lt;string.h&gt;
#include &quot;driver/uart.h&quot;
#include &quot;freertos/FreeRTOS.h&quot;
#include &quot;freertos/queue.h&quot;
#include &quot;esp_log.h&quot;
#include &quot;common.h&quot;
#include &quot;esp_unicviewad.h&quot;
#include &lt;sys/time.h&gt;

#define TXD_PIN 17
#define RXD_PIN 16
#define UART_NUM UART_NUM_2

#define BUF_SIZE (1024)
#define RD_BUF_SIZE (BUF_SIZE)

#define COLOR_GRAO 54468
#define COLOR_AR 30000

static const char * TAG = &quot;UART&quot;;

Q_DEFINE_THIS_FILE

$declare(AOs::Uart)

static Uart l_uart; /* a única instância do AO IHM */

QActive * const AO_Uart = &amp;l_uart.super;

$define(AOs::Uart)
$define(AOs::Uart_ctor)</text>
  </file>
  <file name="ihm.c">
   <text>#include &quot;qpc.h&quot;
#include &lt;math.h&gt;
#include &quot;common.h&quot;
#include &quot;esp_log.h&quot;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &quot;esp_unicviewad.h&quot;

Q_DEFINE_THIS_FILE

#define VP_CHART_LINE_GRAO 3827
#define VP_CHART_CIRCLE_GRAO 3572
#define VP_CHART_LINE_AR 3317
#define VP_CHART_CIRCLE_AR 3062

#define MAIN_MENU_PICID 0
#define MANUAL_MODE_PICID 1
#define CONFIG_PICID 2
#define CONTROLS_PICID 3 
#define SUMMARY_PICID 4
#define ROASTS_PICID 5
#define ROAST_PICID 6
#define WARN_NEW_ROAST_PICID 7
#define WARN_REPEAT_RECIPE_PICID 8
#define WARN_REPLAY_RECIPE_PICID 9
#define WARN_SAVE_RECIPE_PICID 10
#define WARN_TEMP_PRE_PICID 11
#define WARN_TEMP_COOL_PICID 12

#define STAGE_STATUS_ICON_VP 38
#define STAGE_BTN_ICON_VP 48
#define SUBSTAGE_BTN_ICON_VP 436 
#define NAVBAR_ICON_HOME_VP 36 
#define NAVBAR_ICON_GEAR_VP 37 
#define NEXT_COMMAND_ICON_VP 85 
#define CONTROL_POTENCIA_ICON_VP 79
#define CONTROL_CILINDRO_ICON_VP 81 
#define CONTROL_RESFRIADOR_ICON_VP 83 
#define CONTROL_TURBINA_ICON_VP 84
#define ROASTS_ICON_LEFT_VP 185
#define ROASTS_ICON_RIGHT_VP 186
#define ROASTS_ICON_ROAST1_VP 187
#define ROASTS_ICON_ROAST2_VP 188
#define ROASTS_ICON_ROAST3_VP 189
#define ROAST_BTN_ICON_VP 185

#define SENSOR_GAS_TEXT_VP 4082
#define SENSOR_AR_TEXT_VP 61
#define DELTA_AR_TEXT_VP 67 
#define SENSOR_GRAO_TEXT_VP 49
#define DELTA_GRAO_TEXT_VP 67
#define NAVBAR_TEXT_VP 1 
#define STAGE_TIMER_TEXT_VP 39
#define NEXT_COMMAND_TEXT_VP 95 
#define NEXT_COMMAND_TIMER_TEXT_VP 86 
#define CONTROL_POTENCIA_TEXT_VP 426 
#define CONTROL_CILINDRO_TEXT_VP 431 
#define SUMMARY_TITLE_TEXT_VP 111
#define SUMMARY_SUBTITLE_TEXT_VP 147
#define SUMMARY_SUBTITLE2_TEXT_VP 162
#define ROASTS_TEXT_ROAST1_VP 437
#define ROASTS_TEXT_ROAST2_VP 462
#define ROASTS_TEXT_ROAST3_VP 487

#define SENSOR_GAS_TEXT_LEN 4
#define SENSOR_AR_TEXT_LEN 6
#define DELTA_AR_TEXT_LEN 6 
#define SENSOR_GRAO_TEXT_LEN 6 
#define DELTA_GRAO_TEXT_LEN 6 
#define NAVBAR_TEXT_LEN 35
#define STAGE_TIMER_TEXT_LEN 9
#define NEXT_COMMAND_TEXT_LEN 15 
#define NEXT_COMMAND_TIMER_TEXT_LEN 9 
#define CONTROL_POTENCIA_TEXT_LEN 4 
#define CONTROL_CILINDRO_TEXT_LEN 4 
#define SUMMARY_TITLE_TEXT_LEN 35
#define SUMMARY_SUBTITLE_TEXT_LEN 16
#define SUMMARY_SUBTITLE2_TEXT_LEN 23
#define ROASTS_TEXT_ROAST1_LEN 25
#define ROASTS_TEXT_ROAST2_LEN 25
#define ROASTS_TEXT_ROAST3_LEN 25


#define CONFIG_PRE_HEAT_NUMBER_VP 73
#define CONFIG_ROAST_NUMBER_VP 76

#define CONTROL_POTENCIA_SLIDER_VP 80
#define CONTROL_CILINDRO_SLIDER_VP 82 

static const char * TAG = &quot;IHM&quot;;

$declare(Components::IhmStage)
$declare(Components::IhmSubstage)
$declare(AOs::Ihm)


static Ihm l_ihm; /* a única instância do AO IHM */
static IhmStage l_ihmStage; /* a única instância do AO IHM */
static IhmSubstage l_ihmSubstage; /* a única instância do AO IHM */

#define STAGE_TIMER_INTERVAL  \
    (QTimeEvtCtr)((1 * CONFIG_FREERTOS_HZ))

QActive * const AO_Ihm = &amp;l_ihm.super;

$define(Components::IhmStage)
$define(Components::IhmSubstage)
$define(AOs::Ihm)
$define(AOs::Ihm_ctor)</text>
  </file>
  <file name="perif.c">
   <text>#include &quot;qpc.h&quot;
#include &quot;common.h&quot;
#include &quot;esp_log.h&quot;

Q_DEFINE_THIS_FILE

static const char * TAG = &quot;PERIF&quot;;



void cilindro_set_on(bool on);
bool get_resfriador_state();
void resfriador_set_on(bool on);
void potencia_set_duty(int value);
void cilindro_set_duty(int value);
void turbina_set_duty(int value);
int sample_sensor_ar();
int sample_sensor_grao();
int sample_sensor_gas();

$declare(AOs::Perif)

static Perif l_perif; /* a única instância do AO IHM */

#define SENSOR_INTERVAL  \
    (QTimeEvtCtr)((1 * CONFIG_FREERTOS_HZ))

#define PWM_CHECK_INTERVAL  \
    (QTimeEvtCtr)((1 * CONFIG_FREERTOS_HZ))

QActive * const AO_Perif = &amp;l_perif.super;

$define(AOs::Perif)
$define(AOs::Perif_ctor)</text>
  </file>
  <file name="data_broker.c">
   <text>#include &quot;qpc.h&quot;
#include &quot;common.h&quot;
#include &quot;esp_log.h&quot;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &quot;storage.h&quot;

Q_DEFINE_THIS_FILE

static const char * TAG = &quot;DATA_BROKER&quot;;

$declare(AOs::DataBroker)

static DataBroker l_dataBroker; /* a única instância do AO IHM */

QActive * const AO_DataBroker = &amp;l_dataBroker.super;

$define(AOs::DataBroker)
$define(AOs::DataBroker_ctor)</text>
  </file>
  <file name="utils.c"/>
  <file name="bsp.c">
   <text>/*$file${.::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
 * Model: fmw-torrador-v2.qm
 * File:  ${.::bsp.c}
 *
 * This code has been generated by QM 5.2.2 &lt;www.state-machine.com/qm&gt;.
 * DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * This generated code is open source software: you can redistribute it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * NOTE:
 * Alternatively, this generated code may be distributed under the terms
 * of Quantum Leaps commercial licenses, which expressly supersede the GNU
 * General Public License and are specifically designed for licensees
 * interested in retaining the proprietary status of their code.
 *
 * Contact information:
 * &lt;www.state-machine.com/licensing&gt;
 * &lt;info@state-machine.com&gt;
 */
/*$endhead${.::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$file${.::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
 * Model: fmw-torrador-v2.qm
 * File:  ${.::bsp.c}
 *
 * This code has been generated by QM 5.2.2 &lt;www.state-machine.com/qm&gt;.
 * DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * This generated code is open source software: you can redistribute it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * NOTE:
 * Alternatively, this generated code may be distributed under the terms
 * of Quantum Leaps commercial licenses, which expressly supersede the GNU
 * General Public License and are specifically designed for licensees
 * interested in retaining the proprietary status of their code.
 *
 * Contact information:
 * &lt;www.state-machine.com/licensing&gt;
 * &lt;info@state-machine.com&gt;
 */
/*$endhead${.::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include &lt;string.h&gt;

#include &quot;driver/adc.h&quot;
#include &quot;driver/ledc.h&quot;
#include &quot;driver/spi_master.h&quot;
#include &quot;esp_adc_cal.h&quot;
#include &quot;esp_freertos_hooks.h&quot;
#include &quot;esp_log.h&quot;
#include &quot;qf_port.h&quot;
#include &quot;qpc.h&quot;

#define ADC1_EXAMPLE_CHAN0 ADC1_CHANNEL_6  // GPIO 25!!!!
#define ADC_EXAMPLE_ATTEN ADC_ATTEN_DB_11
#define ADC_EXAMPLE_CALI_SCHEME ESP_ADC_CAL_VAL_EFUSE_VREF

#define PIN_PWM_POTENCIA 33
#define PIN_PWM_CILINDRO 32
#define PIN_PWM_TURBINA 25

#define PIN_CILINDRO 4
#define PIN_CILINDRO_EN 21
#define PIN_RESFRIADOR 27

#define HOST VSPI_HOST

#define PIN_NUM_MISO 18
#define PIN_NUM_CLK 19
#define PIN_CS_AR 15
#define PIN_CS_GRAO 5

#define LEDC_MODE LEDC_HIGH_SPEED_MODE
#define LEDC_TIMER LEDC_TIMER_0

#define LEDC_POTENCIA_GPIO (PIN_PWM_POTENCIA)
#define LEDC_POTENCIA_CHANNEL LEDC_CHANNEL_0

#define LEDC_CILINDRO_GPIO (PIN_PWM_CILINDRO)
#define LEDC_CILINDRO_CHANNEL LEDC_CHANNEL_1

#define LEDC_TURBINA_GPIO (PIN_PWM_TURBINA)
#define LEDC_TURBINA_CHANNEL LEDC_CHANNEL_2

#define GPIO_OUTPUT_SEL ((1ULL &lt;&lt; PIN_CILINDRO) | (1ULL &lt;&lt; PIN_RESFRIADOR) | (1ULL &lt;&lt; PIN_CILINDRO_EN))

Q_DEFINE_THIS_FILE

static const char* TAG = &quot;bsp&quot;;

static bool is_cilindro_on = false;
static bool is_resfriador_on = false;

static esp_adc_cal_characteristics_t adc1_chars;
static spi_device_handle_t sensor_ar;
static spi_device_handle_t sensor_grao;

void cilindro_set_on(bool on);
void resfriador_set_on(bool on);

int_t qf_run_active = 0;

static IRAM_ATTR void freertos_tick_hook(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    if (qf_run_active != 0) {
        /* process time events for rate 0 */
        QTIMEEVT_TICK_FROM_ISR(0U, &amp;xHigherPriorityTaskWoken, &amp;freertos_tick_hook);
        /* notify FreeRTOS to perform context switch from ISR, if needed */
        if (xHigherPriorityTaskWoken) {
            portYIELD_FROM_ISR();
        }
    }
}

void QF_onStartup(void) {
    esp_register_freertos_tick_hook_for_cpu(freertos_tick_hook, QPC_CPU_NUM);

    /* enable QF ticks from tick hook */
    qf_run_active = 100;

    ESP_LOGI(TAG, &quot;QF started.&quot;);

    /* Note: Additional hook stuff can be placed here */
}

IRAM_ATTR void Q_onAssert(char_t const* const module, int_t location) {
    // ESP_LOGE(TAG, &quot;Q_onAssert: module:%s loc:%d\n&quot;, module, location);
}

static bool adc_calibration_init(void) {
    esp_err_t ret;
    bool cali_enable = false;

    ret = esp_adc_cal_check_efuse(ADC_EXAMPLE_CALI_SCHEME);
    if (ret == ESP_ERR_NOT_SUPPORTED) {
        ESP_LOGW(TAG, &quot;Calibration scheme not supported, skip software calibration&quot;);
    } else if (ret == ESP_ERR_INVALID_VERSION) {
        ESP_LOGW(TAG, &quot;eFuse not burnt, skip software calibration&quot;);
    } else if (ret == ESP_OK) {
        cali_enable = true;
        esp_adc_cal_characterize(ADC_UNIT_1, ADC_EXAMPLE_ATTEN, ADC_WIDTH_BIT_DEFAULT, 0, &amp;adc1_chars);
    } else {
        ESP_LOGE(TAG, &quot;Invalid arg&quot;);
    }

    return cali_enable;
}

void setup_peripherals() {
    ledc_timer_config_t ledc_timer = {
        .duty_resolution = LEDC_TIMER_13_BIT,  // resolution of PWM duty
        .freq_hz = 5000,                       // frequency of PWM signal
        .speed_mode = LEDC_MODE,               // timer mode
        .timer_num = LEDC_TIMER,               // timer index
        .clk_cfg = LEDC_AUTO_CLK,              // Auto select the source clock
    };

    ledc_timer_config(&amp;ledc_timer);

    /*
     * Prepare individual configuration
     * for each channel of LED Controller
     * by selecting:
     * - controller's channel number
     * - output duty cycle, set initially to 0
     * - GPIO number where LED is connected to
     * - speed mode, either high or low
     * - timer servicing selected channel
     *   Note: if different channels use one timer,
     *         then frequency and bit_num of these channels
     *         will be the same
     */

    ledc_channel_config_t ledc_channel[3] = {
        {.gpio_num = LEDC_POTENCIA_GPIO,
         .speed_mode = LEDC_MODE,
         .channel = LEDC_POTENCIA_CHANNEL,
         .timer_sel = LEDC_TIMER,
         .duty = 0,
         .hpoint = 0,
         .flags.output_invert = 0},
        {.gpio_num = LEDC_CILINDRO_GPIO,
         .speed_mode = LEDC_MODE,
         .channel = LEDC_CILINDRO_CHANNEL,
         .timer_sel = LEDC_TIMER,
         .duty = 0,
         .hpoint = 0,
         .flags.output_invert = 1},
        {.gpio_num = LEDC_TURBINA_GPIO,
         .speed_mode = LEDC_MODE,
         .channel = LEDC_TURBINA_CHANNEL,
         .timer_sel = LEDC_TIMER,
         .duty = 0,
         .hpoint = 0,
         .flags.output_invert = 1},
    };

    ledc_channel_config(&amp;ledc_channel[0]);  // Potencia
    ledc_channel_config(&amp;ledc_channel[1]);  // Cilindro
    ledc_channel_config(&amp;ledc_channel[2]);  // Turbina

    spi_bus_config_t bus_cfg = {
        .miso_io_num = PIN_NUM_MISO,
        .mosi_io_num = -1,
        .sclk_io_num = PIN_NUM_CLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = (4 * 8),
        .flags = SPICOMMON_BUSFLAG_MASTER,
    };

    esp_err_t ret = spi_bus_initialize(HOST, &amp;bus_cfg, SPI_DMA_CH2);
    ESP_ERROR_CHECK(ret);

    spi_device_interface_config_t dev_cfg = {
        .command_bits = 0,
        .address_bits = 0,
        .dummy_bits = 0,
        .mode = 1,
        .duty_cycle_pos = 0,
        .cs_ena_pretrans = 0,
        .cs_ena_posttrans = 0,
        .clock_speed_hz = 4300000,
        .input_delay_ns = 100,
        .spics_io_num = PIN_CS_AR,
        // .flags = SPI_DEVICE_NO_DUMMY,
        .queue_size = 1,
    };
    ret = spi_bus_add_device(HOST, &amp;dev_cfg, &amp;sensor_ar);
    ESP_ERROR_CHECK(ret);

    spi_device_interface_config_t dev_cfg2 = {
        .command_bits = 0,
        .address_bits = 0,
        .dummy_bits = 0,
        .mode = 1,
        .duty_cycle_pos = 0,
        .cs_ena_pretrans = 0,
        .cs_ena_posttrans = 0,
        .clock_speed_hz = 4300000,
        .input_delay_ns = 100,
        .spics_io_num = PIN_CS_GRAO,
        // .flags = SPI_DEVICE_NO_DUMMY,
        .queue_size = 1,
    };
    ret = spi_bus_add_device(HOST, &amp;dev_cfg2, &amp;sensor_grao);
    ESP_ERROR_CHECK(ret);

    gpio_config_t io_conf = {};
    io_conf.intr_type = GPIO_INTR_DISABLE;
    io_conf.mode = GPIO_MODE_OUTPUT;
    io_conf.pin_bit_mask = GPIO_OUTPUT_SEL;
    io_conf.pull_down_en = 0;
    io_conf.pull_up_en = 0;
    gpio_config(&amp;io_conf);

    adc_calibration_init();

    ESP_ERROR_CHECK(adc1_config_width(ADC_WIDTH_BIT_DEFAULT));
    ESP_ERROR_CHECK(adc1_config_channel_atten(ADC1_EXAMPLE_CHAN0, ADC_EXAMPLE_ATTEN));

    cilindro_set_on(false);
    resfriador_set_on(false);
}

static uint32_t percentage_to_duty(int value) {
    const uint32_t in_min = 0, out_min = 0;
    const uint32_t in_max = 100, out_max = 8191;

    if (value &lt; 0)
        value = 0;
    else if (value &gt; 100)
        value = 100;

    uint32_t duty = (uint32_t)value;
    return (duty - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void cilindro_set_on(bool on) {
    if (on) {
        gpio_set_level(PIN_CILINDRO, 1);
        gpio_set_level(PIN_CILINDRO_EN, 1);
        is_cilindro_on = true;
    } else {
        gpio_set_level(PIN_CILINDRO, 0);
        gpio_set_level(PIN_CILINDRO_EN, 0);
        is_cilindro_on = false;
    }
}

bool get_resfriador_state() {
    return is_resfriador_on;
}

void resfriador_set_on(bool on) {
    if (on) {
        gpio_set_level(PIN_RESFRIADOR, 0);
        is_resfriador_on = true;
    } else {
        gpio_set_level(PIN_RESFRIADOR, 1);
        is_resfriador_on = false;
    }
}

void potencia_set_duty(int value) {
    ESP_LOGD(TAG, &quot;[POTÊNCIA DUTY]: %d&quot;, value);
    uint32_t duty = percentage_to_duty(value);

    ledc_set_duty(LEDC_MODE, LEDC_POTENCIA_CHANNEL, duty);
    ledc_update_duty(LEDC_MODE, LEDC_POTENCIA_CHANNEL);
}

void cilindro_set_duty(int value) {
    ESP_LOGD(TAG, &quot;[CILINDRO DUTY]: %d&quot;, value);
    uint32_t duty = percentage_to_duty(value);

    if (value &gt; 0 &amp;&amp; !is_cilindro_on) {
        cilindro_set_on(true);
        ESP_LOGD(TAG, &quot;[CILINDRO]: ON&quot;);
    } else if (value == 0 &amp;&amp; is_cilindro_on) {
        cilindro_set_on(false);
        ESP_LOGD(TAG, &quot;[CILINDRO]: OFF&quot;);
    }

    ledc_set_duty(LEDC_MODE, LEDC_CILINDRO_CHANNEL, duty);
    ledc_update_duty(LEDC_MODE, LEDC_CILINDRO_CHANNEL);
}

void turbina_set_duty(int value) {
    ESP_LOGD(TAG, &quot;[TURBINA DUTY]: %d&quot;, value);
    uint32_t duty = percentage_to_duty(value);

    ledc_set_duty(LEDC_MODE, LEDC_TURBINA_CHANNEL, duty);
    ledc_update_duty(LEDC_MODE, LEDC_TURBINA_CHANNEL);
}

float sample_sensor(spi_device_handle_t* dev) {
    uint16_t data;
    spi_transaction_t trans = {
        .tx_buffer = NULL,
        .rx_buffer = &amp;data,
        .length = 16,
        .rxlength = 16,
    };

    esp_err_t ret = spi_device_polling_transmit(*dev, &amp;trans);
    // ESP_ERROR_CHECK(ret);

    int16_t res = (int16_t)SPI_SWAP_DATA_RX(data, 16);

    if (res &amp; (1 &lt;&lt; 2)) {
        // ESP_LOGE(&quot;oi&quot;, &quot;Sensor is not connected\n&quot;);
        return 0;
    } else {
        res &gt;&gt;= 3;
        // printf(&quot;SPI res = %d temp=%f\n&quot;, res, res * 0.25);
        return (res * 0.25);
    }

    return 0;
}

int sample_sensor_ar() {
    float temperature = 0;

    temperature = sample_sensor(&amp;sensor_ar);
    // if (temperature == 0)
    //     ESP_LOGE(TAG, &quot;Algo errado AR&quot;);
    // else
    //     ESP_LOGE(TAG, &quot;Temp ar: %f&quot;, temperature);

    if (temperature &lt; 0) temperature = 0;
    return temperature;
}

int sample_sensor_grao() {
    float temperature = 0;

    temperature = sample_sensor(&amp;sensor_grao);
    /*
    if (temperature == 0)
        ESP_LOGE(TAG, &quot;Algo errado GRAO&quot;);
    else
        ESP_LOGE(TAG, &quot;Temp grao: %f&quot;, temperature);
    */
    if (temperature &lt; 0) temperature = 0;
    return temperature;
}

int sample_sensor_gas() {
    int adc_raw = 0;

    for (int i = 0; i &lt; 24; i++) {
        adc_raw += adc1_get_raw(ADC1_EXAMPLE_CHAN0);
    }

    return adc_raw / 24;
}
</text>
  </file>
 </directory>
 <directory name="..">
  <directory name="components">
   <directory name="common">
    <directory name="include">
     <file name="common.h">
      <text>#ifndef COMMON_H
#define COMMON_H

#include &quot;qpc.h&quot;
#include &quot;esp_log.h&quot;

enum Signals {
    UART_INPUT_TOUCH_SIG = Q_USER_SIG, /* the new request signal */
    UART_INPUT_SLIDER_SIG,
    UART_OUTPUT_PAGE_SIG,
    UART_OUTPUT_ICON_SIG,
    UART_OUTPUT_TEXT_SIG,
    UART_OUTPUT_NUMBER_SIG,
    UART_OUTPUT_CHART_SIG,
    UART_INPUT_CONFIG_SAVE_SIG,

    IHM_INPUT_TOUCH_SIG,
    IHM_INPUT_SLIDER_SIG,
    IHM_STAGE_TIMER_TIMEOUT_SIG,
    IHM_INPUT_CONFIG_SAVE_SIG,

    REQUEST_NEXT_STAGE_SIG,
    NOTIFY_NEXT_STAGE_SIG,
    REQUEST_NEXT_SUBSTAGE_SIG,
    NOTIFY_NEXT_SUBSTAGE_SIG,
    NOTIFY_SUBSTAGE_EXIT_SIG,

    PWM_TIMEOUT_SIG,
    SENSOR_TIMEOUT_SIG,

    REQUEST_RECIPES_SIG,
    RESPONSE_RECIPES_SIG,
    REQUEST_RECIPE_SIG,
    RESPONSE_RECIPE_SIG,

    REQUEST_ROASTS_SIG,
    REQUEST_ROAST_SIG,
    RESPONSE_ROASTS_SIG,
    RESPONSE_ROAST_SIG,

    REQUEST_MODE_SIG,
    NOTIFY_MODE_SIG,

    SENSOR_UPDATE_SIG,
    SENSOR_GAS_UPDATE_SIG,
    SENSOR_DATA_SIG,
    SENSOR_GAS_DATA_SIG,
    CHART_DATA_SIG,

    CONTROL_UPDATE_SIG,
    CONTROL_DATA_SIG,

    CONFIG_UPDATE_SIG,

    REQUEST_TRANSFORM_ROAST_SIG,
    DATA_RECIPE_TIMEOUT_SIG,

    REQUEST_SUMMARY_SIG,
    RESPONSE_SUMMARY_SIG,

    REQUEST_CONFIG_SIG,
    RESPONSE_CONFIG_SIG,
};

typedef enum ControlType {
    CONTROL_NONE,
    POTENCIA,
    CILINDRO,
    TURBINA,
    RESFRIADOR,
} ControlType;

typedef enum SensorTypeTag {
    SENSOR_AR,
    SENSOR_GRAO,
    SENSOR_GAS
} SensorType;

typedef enum PageTypeTag {
    PAGE_MAIN_MENU,
    PAGE_MANUAL_MODE,
    PAGE_RECIPES,
    PAGE_RECIPE,
    PAGE_ROASTS,
    PAGE_ROAST,
    PAGE_CONTROLS,
    PAGE_CONFIG
} PageType;

typedef enum ModeTypeTag {
    MODE_NONE,
    MODE_MANUAL,
    MODE_AUTO
} ModeType;

typedef enum SubstageTypeTag {
    SUB_IDLE,
    F,
    Q1,
    Q2,
} SubstageType;

typedef enum StageTypeTag {
    IDLE,
    PRE_HEAT,
    ROAST,
    COOL,
    SUMMARY,
} StageType;

typedef struct ModeDataTag {
    ModeType mode;
    char roast[25];
} ModeData;

typedef struct TempDataTag {
    int count;
    int temps[31];
    int deltas[31];
    int temp;
    int delta;
} TempData;

typedef struct CommandDataTag {
    char command[15];
    time_t time;
} CommandData;

typedef struct SensorDataTag {
    TempData ar;
    TempData grao;
    int max;
    int min;
    int max_delta;
    int min_delta;
    int grao_aux;
    int ar_aux;
} SensorData;

typedef struct RoastsResponseTag {
    uint8_t pageNum;
    char roast1[25];
    char roast2[25];
    char roast3[25];
    bool prevPage;
    bool nextPage;
} RoastsResponse;

typedef struct RoastResponseTag {
    char roast[25];
    SensorData *sensorData;
} RoastResponse;

typedef struct RecipesResponseTag {
    uint8_t pageNum;
    char roast1[25];
    char roast2[25];
    char roast3[25];
    bool prevPage;
    bool nextPage;
} RecipesResponse;

typedef struct RecipeResponseTag {
    char roast[25];
    SensorData *sensorData;
} RecipeResponse;

typedef struct ControlDataTag {
    uint16_t potencia;
    uint16_t cilindro;
    uint16_t turbina;
    uint16_t resfriador;
} ControlData;

typedef struct CommandDataTag {
    ControlData control_data;
    time_t timestamp;
} CommandData;

typedef struct RoastDataTag {
    time_t time_start;
    time_t time_end;
    SensorData sensor_data;
    ControlData control_data;
    char name[9];
} RoastData;

typedef struct RecipeDataTag {
    char name[25];
    time_t intervals[100];
    ControlType controls[100];
    int values[100];
    int count;
    int curr_command;
} RecipeData;

typedef struct ConfigTag {
    uint16_t max_pre_heat;
    uint16_t max_roast;
} Config;

typedef struct ControlStateTag {
    int potencia;
    int cilindro;
    ControlToggle turbina;
    ControlToggle resfriador;
} ControlState;

typedef struct RoastsPageDataTag {
    int page;
    char roast1[25];
    char roast2[25];
    char roast3[25];
    bool prev;
    bool next;
} RoastsPageData;

typedef struct RoastPageDataTag {
    char roast[25];
} RoastPageData;

typedef struct ControlPageDataTag {
    int sensor_grao;
    int sensor_ar;
    int potencia;
    int cilindro;
    int turbina;
    int resfriador;
}

typedef struct ConfigPageDataTag {
    uint16_t max_pre_heat;
    uint16_t max_roast;
} ConfigPageData;

typedef enum DataTypeTag {
    DATA_PAGE,
} DataType;

typedef struct PageDataTag {
    PageType page;
    union {
        ControlPageData control_data;
        ConfigPageData config_data;
    } data;
} PageData;

typedef union DataTag {
    PageData page_data;
} Data;

typedef struct IhmStateTag {
    ControlState control;
} IhmState;

$declare${Events}

$declare(AOs::Ihm_ctor)
$declare(AOs::Perif_ctor)
$declare(AOs::DataBroker_ctor)
$declare(AOs::Uart_ctor)

$declare(AOs::AO_Ihm)
$declare(AOs::AO_Perif)
$declare(AOs::AO_DataBroker)
$declare(AOs::AO_Uart)

$declare(Common)

#endif</text>
     </file>
    </directory>
    <file name="common.c">
     <text>#include &quot;common.h&quot;
#include &lt;string.h&gt;

Q_DEFINE_THIS_FILE

static const char *TAG = &quot;COMMON&quot;;

$define(Common)</text>
    </file>
   </directory>
  </directory>
 </directory>
</model>
